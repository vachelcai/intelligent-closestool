
ZNMT_MB.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00004180  080000c0  080000c0  000100c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000140  08004240  08004240  00014240  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08004380  08004380  00014380  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08004384  08004384  00014384  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000084  20000000  08004388  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          0000179c  20000084  0800440c  00020084  2**2
                  ALLOC
  7 ._user_heap_stack 00000600  20001820  0800440c  00021820  2**0
                  ALLOC
  8 .ARM.attributes 00000028  00000000  00000000  00020084  2**0
                  CONTENTS, READONLY
  9 .debug_info   00022c82  00000000  00000000  000200ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00004e4b  00000000  00000000  00042d2e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000c072  00000000  00000000  00047b79  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00000f20  00000000  00000000  00053bf0  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000018d0  00000000  00000000  00054b10  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00009688  00000000  00000000  000563e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00005c8f  00000000  00000000  0005fa68  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .comment      0000007c  00000000  00000000  000656f7  2**0
                  CONTENTS, READONLY
 17 .debug_frame  000031a0  00000000  00000000  00065774  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	20000084 	.word	0x20000084
 80000e0:	00000000 	.word	0x00000000
 80000e4:	08004228 	.word	0x08004228

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	20000088 	.word	0x20000088
 8000104:	08004228 	.word	0x08004228

08000108 <__udivsi3>:
 8000108:	2200      	movs	r2, #0
 800010a:	0843      	lsrs	r3, r0, #1
 800010c:	428b      	cmp	r3, r1
 800010e:	d374      	bcc.n	80001fa <__udivsi3+0xf2>
 8000110:	0903      	lsrs	r3, r0, #4
 8000112:	428b      	cmp	r3, r1
 8000114:	d35f      	bcc.n	80001d6 <__udivsi3+0xce>
 8000116:	0a03      	lsrs	r3, r0, #8
 8000118:	428b      	cmp	r3, r1
 800011a:	d344      	bcc.n	80001a6 <__udivsi3+0x9e>
 800011c:	0b03      	lsrs	r3, r0, #12
 800011e:	428b      	cmp	r3, r1
 8000120:	d328      	bcc.n	8000174 <__udivsi3+0x6c>
 8000122:	0c03      	lsrs	r3, r0, #16
 8000124:	428b      	cmp	r3, r1
 8000126:	d30d      	bcc.n	8000144 <__udivsi3+0x3c>
 8000128:	22ff      	movs	r2, #255	; 0xff
 800012a:	0209      	lsls	r1, r1, #8
 800012c:	ba12      	rev	r2, r2
 800012e:	0c03      	lsrs	r3, r0, #16
 8000130:	428b      	cmp	r3, r1
 8000132:	d302      	bcc.n	800013a <__udivsi3+0x32>
 8000134:	1212      	asrs	r2, r2, #8
 8000136:	0209      	lsls	r1, r1, #8
 8000138:	d065      	beq.n	8000206 <__udivsi3+0xfe>
 800013a:	0b03      	lsrs	r3, r0, #12
 800013c:	428b      	cmp	r3, r1
 800013e:	d319      	bcc.n	8000174 <__udivsi3+0x6c>
 8000140:	e000      	b.n	8000144 <__udivsi3+0x3c>
 8000142:	0a09      	lsrs	r1, r1, #8
 8000144:	0bc3      	lsrs	r3, r0, #15
 8000146:	428b      	cmp	r3, r1
 8000148:	d301      	bcc.n	800014e <__udivsi3+0x46>
 800014a:	03cb      	lsls	r3, r1, #15
 800014c:	1ac0      	subs	r0, r0, r3
 800014e:	4152      	adcs	r2, r2
 8000150:	0b83      	lsrs	r3, r0, #14
 8000152:	428b      	cmp	r3, r1
 8000154:	d301      	bcc.n	800015a <__udivsi3+0x52>
 8000156:	038b      	lsls	r3, r1, #14
 8000158:	1ac0      	subs	r0, r0, r3
 800015a:	4152      	adcs	r2, r2
 800015c:	0b43      	lsrs	r3, r0, #13
 800015e:	428b      	cmp	r3, r1
 8000160:	d301      	bcc.n	8000166 <__udivsi3+0x5e>
 8000162:	034b      	lsls	r3, r1, #13
 8000164:	1ac0      	subs	r0, r0, r3
 8000166:	4152      	adcs	r2, r2
 8000168:	0b03      	lsrs	r3, r0, #12
 800016a:	428b      	cmp	r3, r1
 800016c:	d301      	bcc.n	8000172 <__udivsi3+0x6a>
 800016e:	030b      	lsls	r3, r1, #12
 8000170:	1ac0      	subs	r0, r0, r3
 8000172:	4152      	adcs	r2, r2
 8000174:	0ac3      	lsrs	r3, r0, #11
 8000176:	428b      	cmp	r3, r1
 8000178:	d301      	bcc.n	800017e <__udivsi3+0x76>
 800017a:	02cb      	lsls	r3, r1, #11
 800017c:	1ac0      	subs	r0, r0, r3
 800017e:	4152      	adcs	r2, r2
 8000180:	0a83      	lsrs	r3, r0, #10
 8000182:	428b      	cmp	r3, r1
 8000184:	d301      	bcc.n	800018a <__udivsi3+0x82>
 8000186:	028b      	lsls	r3, r1, #10
 8000188:	1ac0      	subs	r0, r0, r3
 800018a:	4152      	adcs	r2, r2
 800018c:	0a43      	lsrs	r3, r0, #9
 800018e:	428b      	cmp	r3, r1
 8000190:	d301      	bcc.n	8000196 <__udivsi3+0x8e>
 8000192:	024b      	lsls	r3, r1, #9
 8000194:	1ac0      	subs	r0, r0, r3
 8000196:	4152      	adcs	r2, r2
 8000198:	0a03      	lsrs	r3, r0, #8
 800019a:	428b      	cmp	r3, r1
 800019c:	d301      	bcc.n	80001a2 <__udivsi3+0x9a>
 800019e:	020b      	lsls	r3, r1, #8
 80001a0:	1ac0      	subs	r0, r0, r3
 80001a2:	4152      	adcs	r2, r2
 80001a4:	d2cd      	bcs.n	8000142 <__udivsi3+0x3a>
 80001a6:	09c3      	lsrs	r3, r0, #7
 80001a8:	428b      	cmp	r3, r1
 80001aa:	d301      	bcc.n	80001b0 <__udivsi3+0xa8>
 80001ac:	01cb      	lsls	r3, r1, #7
 80001ae:	1ac0      	subs	r0, r0, r3
 80001b0:	4152      	adcs	r2, r2
 80001b2:	0983      	lsrs	r3, r0, #6
 80001b4:	428b      	cmp	r3, r1
 80001b6:	d301      	bcc.n	80001bc <__udivsi3+0xb4>
 80001b8:	018b      	lsls	r3, r1, #6
 80001ba:	1ac0      	subs	r0, r0, r3
 80001bc:	4152      	adcs	r2, r2
 80001be:	0943      	lsrs	r3, r0, #5
 80001c0:	428b      	cmp	r3, r1
 80001c2:	d301      	bcc.n	80001c8 <__udivsi3+0xc0>
 80001c4:	014b      	lsls	r3, r1, #5
 80001c6:	1ac0      	subs	r0, r0, r3
 80001c8:	4152      	adcs	r2, r2
 80001ca:	0903      	lsrs	r3, r0, #4
 80001cc:	428b      	cmp	r3, r1
 80001ce:	d301      	bcc.n	80001d4 <__udivsi3+0xcc>
 80001d0:	010b      	lsls	r3, r1, #4
 80001d2:	1ac0      	subs	r0, r0, r3
 80001d4:	4152      	adcs	r2, r2
 80001d6:	08c3      	lsrs	r3, r0, #3
 80001d8:	428b      	cmp	r3, r1
 80001da:	d301      	bcc.n	80001e0 <__udivsi3+0xd8>
 80001dc:	00cb      	lsls	r3, r1, #3
 80001de:	1ac0      	subs	r0, r0, r3
 80001e0:	4152      	adcs	r2, r2
 80001e2:	0883      	lsrs	r3, r0, #2
 80001e4:	428b      	cmp	r3, r1
 80001e6:	d301      	bcc.n	80001ec <__udivsi3+0xe4>
 80001e8:	008b      	lsls	r3, r1, #2
 80001ea:	1ac0      	subs	r0, r0, r3
 80001ec:	4152      	adcs	r2, r2
 80001ee:	0843      	lsrs	r3, r0, #1
 80001f0:	428b      	cmp	r3, r1
 80001f2:	d301      	bcc.n	80001f8 <__udivsi3+0xf0>
 80001f4:	004b      	lsls	r3, r1, #1
 80001f6:	1ac0      	subs	r0, r0, r3
 80001f8:	4152      	adcs	r2, r2
 80001fa:	1a41      	subs	r1, r0, r1
 80001fc:	d200      	bcs.n	8000200 <__udivsi3+0xf8>
 80001fe:	4601      	mov	r1, r0
 8000200:	4152      	adcs	r2, r2
 8000202:	4610      	mov	r0, r2
 8000204:	4770      	bx	lr
 8000206:	e7ff      	b.n	8000208 <__udivsi3+0x100>
 8000208:	b501      	push	{r0, lr}
 800020a:	2000      	movs	r0, #0
 800020c:	f000 f806 	bl	800021c <__aeabi_idiv0>
 8000210:	bd02      	pop	{r1, pc}
 8000212:	46c0      	nop			; (mov r8, r8)

08000214 <__aeabi_uidivmod>:
 8000214:	2900      	cmp	r1, #0
 8000216:	d0f7      	beq.n	8000208 <__udivsi3+0x100>
 8000218:	e776      	b.n	8000108 <__udivsi3>
 800021a:	4770      	bx	lr

0800021c <__aeabi_idiv0>:
 800021c:	4770      	bx	lr
 800021e:	46c0      	nop			; (mov r8, r8)

08000220 <HAL_Init>:
  */
HAL_StatusTypeDef HAL_Init(void)
{
  /* Configure Flash prefetch */ 
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000220:	2310      	movs	r3, #16
 8000222:	4a06      	ldr	r2, [pc, #24]	; (800023c <HAL_Init+0x1c>)
{
 8000224:	b510      	push	{r4, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000226:	6811      	ldr	r1, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */

  HAL_InitTick(TICK_INT_PRIORITY);
 8000228:	2000      	movs	r0, #0
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800022a:	430b      	orrs	r3, r1
 800022c:	6013      	str	r3, [r2, #0]
  HAL_InitTick(TICK_INT_PRIORITY);
 800022e:	f002 ff55 	bl	80030dc <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8000232:	f002 ff09 	bl	8003048 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 8000236:	2000      	movs	r0, #0
 8000238:	bd10      	pop	{r4, pc}
 800023a:	46c0      	nop			; (mov r8, r8)
 800023c:	40022000 	.word	0x40022000

08000240 <HAL_IncTick>:
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000240:	4a02      	ldr	r2, [pc, #8]	; (800024c <HAL_IncTick+0xc>)
 8000242:	6813      	ldr	r3, [r2, #0]
 8000244:	3301      	adds	r3, #1
 8000246:	6013      	str	r3, [r2, #0]
}
 8000248:	4770      	bx	lr
 800024a:	46c0      	nop			; (mov r8, r8)
 800024c:	200012a4 	.word	0x200012a4

08000250 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000250:	4b01      	ldr	r3, [pc, #4]	; (8000258 <HAL_GetTick+0x8>)
 8000252:	6818      	ldr	r0, [r3, #0]
}
 8000254:	4770      	bx	lr
 8000256:	46c0      	nop			; (mov r8, r8)
 8000258:	200012a4 	.word	0x200012a4

0800025c <HAL_ADC_Init>:
  *         of structure "ADC_InitTypeDef".
  * @param  hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
 800025c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800025e:	0004      	movs	r4, r0
  uint32_t tmpCFGR1 = 0U;

  /* Check ADC handle */
  if(hadc == NULL)
  {
    return HAL_ERROR;
 8000260:	2001      	movs	r0, #1
  if(hadc == NULL)
 8000262:	2c00      	cmp	r4, #0
 8000264:	d072      	beq.n	800034c <HAL_ADC_Init+0xf0>
  /* Refer to header of this file for more details on clock enabling procedure*/
  
  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  /* - ADC voltage regulator enable                                           */
  if (hadc->State == HAL_ADC_STATE_RESET)
 8000266:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8000268:	2b00      	cmp	r3, #0
 800026a:	d106      	bne.n	800027a <HAL_ADC_Init+0x1e>
  {
    /* Initialize ADC error code */
    ADC_CLEAR_ERRORCODE(hadc);
    
    /* Allocate lock resource and initialize it */
    hadc->Lock = HAL_UNLOCKED;
 800026c:	0022      	movs	r2, r4
 800026e:	3240      	adds	r2, #64	; 0x40
    ADC_CLEAR_ERRORCODE(hadc);
 8000270:	64a3      	str	r3, [r4, #72]	; 0x48
    
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8000272:	0020      	movs	r0, r4
    hadc->Lock = HAL_UNLOCKED;
 8000274:	7013      	strb	r3, [r2, #0]
    HAL_ADC_MspInit(hadc);
 8000276:	f002 ff03 	bl	8003080 <HAL_ADC_MspInit>
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed.                                                     */
  /* and if there is no conversion on going on regular group (ADC can be      */ 
  /* enabled anyway, in case of call of this function to update a parameter   */
  /* on the fly).                                                             */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
 800027a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800027c:	06db      	lsls	r3, r3, #27
 800027e:	d500      	bpl.n	8000282 <HAL_ADC_Init+0x26>
 8000280:	e079      	b.n	8000376 <HAL_ADC_Init+0x11a>
      (tmp_hal_status == HAL_OK)                                &&
      (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)          )
 8000282:	2204      	movs	r2, #4
 8000284:	6823      	ldr	r3, [r4, #0]
 8000286:	6898      	ldr	r0, [r3, #8]
 8000288:	4010      	ands	r0, r2
      (tmp_hal_status == HAL_OK)                                &&
 800028a:	d000      	beq.n	800028e <HAL_ADC_Init+0x32>
 800028c:	e073      	b.n	8000376 <HAL_ADC_Init+0x11a>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 800028e:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8000290:	4942      	ldr	r1, [pc, #264]	; (800039c <HAL_ADC_Init+0x140>)
 8000292:	4011      	ands	r1, r2
 8000294:	2202      	movs	r2, #2
 8000296:	430a      	orrs	r2, r1
    /* Parameters update conditioned to ADC state:                            */
    /* Parameters that can be updated only when ADC is disabled:              */
    /*  - ADC clock mode                                                      */
    /*  - ADC clock prescaler                                                 */
    /*  - ADC resolution                                                      */
    if (ADC_IS_ENABLE(hadc) == RESET)
 8000298:	2103      	movs	r1, #3
    ADC_STATE_CLR_SET(hadc->State,
 800029a:	6462      	str	r2, [r4, #68]	; 0x44
    if (ADC_IS_ENABLE(hadc) == RESET)
 800029c:	689a      	ldr	r2, [r3, #8]
 800029e:	400a      	ands	r2, r1
 80002a0:	2a01      	cmp	r2, #1
 80002a2:	d000      	beq.n	80002a6 <HAL_ADC_Init+0x4a>
 80002a4:	e06d      	b.n	8000382 <HAL_ADC_Init+0x126>
 80002a6:	6819      	ldr	r1, [r3, #0]
 80002a8:	4211      	tst	r1, r2
 80002aa:	d102      	bne.n	80002b2 <HAL_ADC_Init+0x56>
 80002ac:	68da      	ldr	r2, [r3, #12]
 80002ae:	0412      	lsls	r2, r2, #16
 80002b0:	d567      	bpl.n	8000382 <HAL_ADC_Init+0x126>
    /*  - external trigger polarity                                           */
    /*  - data alignment                                                      */
    /*  - resolution                                                          */
    /*  - scan direction                                                      */
    /*  - DMA continuous request                                              */
    hadc->Instance->CFGR1 &= ~( ADC_CFGR1_DISCEN  |
 80002b2:	68da      	ldr	r2, [r3, #12]
 80002b4:	493a      	ldr	r1, [pc, #232]	; (80003a0 <HAL_ADC_Init+0x144>)
                                ADC_CFGR1_SCANDIR |
                                ADC_CFGR1_DMACFG   );

    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT(hadc->Init.LowPowerAutoWait)        |
                 ADC_CFGR1_AUTOOFF(hadc->Init.LowPowerAutoPowerOff)     |
                 ADC_CFGR1_CONTINUOUS(hadc->Init.ContinuousConvMode)    |
 80002b6:	6a25      	ldr	r5, [r4, #32]
    hadc->Instance->CFGR1 &= ~( ADC_CFGR1_DISCEN  |
 80002b8:	400a      	ands	r2, r1
 80002ba:	60da      	str	r2, [r3, #12]
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT(hadc->Init.LowPowerAutoWait)        |
 80002bc:	69a2      	ldr	r2, [r4, #24]
                 ADC_CFGR1_CONTINUOUS(hadc->Init.ContinuousConvMode)    |
 80002be:	036f      	lsls	r7, r5, #13
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT(hadc->Init.LowPowerAutoWait)        |
 80002c0:	0391      	lsls	r1, r2, #14
                 ADC_CFGR1_AUTOOFF(hadc->Init.LowPowerAutoPowerOff)     |
 80002c2:	69e2      	ldr	r2, [r4, #28]
 80002c4:	03d2      	lsls	r2, r2, #15
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT(hadc->Init.LowPowerAutoWait)        |
 80002c6:	4311      	orrs	r1, r2
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                  |
 80002c8:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80002ca:	3a01      	subs	r2, #1
 80002cc:	1e56      	subs	r6, r2, #1
 80002ce:	41b2      	sbcs	r2, r6
 80002d0:	0316      	lsls	r6, r2, #12
 80002d2:	68e2      	ldr	r2, [r4, #12]
 80002d4:	4311      	orrs	r1, r2
                 hadc->Init.DataAlign                                   |
                 ADC_SCANDIR(hadc->Init.ScanConvMode)                   |
 80002d6:	6922      	ldr	r2, [r4, #16]
 80002d8:	430f      	orrs	r7, r1
 80002da:	2a02      	cmp	r2, #2
 80002dc:	d100      	bne.n	80002e0 <HAL_ADC_Init+0x84>
 80002de:	2004      	movs	r0, #4
                 ADC_CFGR1_DMACONTREQ(hadc->Init.DMAContinuousRequests)  );
 80002e0:	6b22      	ldr	r2, [r4, #48]	; 0x30
    
    /* Enable discontinuous mode only if continuous mode is disabled */
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 80002e2:	6a61      	ldr	r1, [r4, #36]	; 0x24
                 ADC_CFGR1_DMACONTREQ(hadc->Init.DMAContinuousRequests)  );
 80002e4:	0052      	lsls	r2, r2, #1
                 ADC_SCANDIR(hadc->Init.ScanConvMode)                   |
 80002e6:	433a      	orrs	r2, r7
 80002e8:	4332      	orrs	r2, r6
 80002ea:	4302      	orrs	r2, r0
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 80002ec:	2901      	cmp	r1, #1
 80002ee:	d104      	bne.n	80002fa <HAL_ADC_Init+0x9e>
    {
      if (hadc->Init.ContinuousConvMode == DISABLE)
 80002f0:	2d00      	cmp	r5, #0
 80002f2:	d12c      	bne.n	800034e <HAL_ADC_Init+0xf2>
      {
        /* Enable the selected ADC group regular discontinuous mode */
        tmpCFGR1 |= ADC_CFGR1_DISCEN;
 80002f4:	2180      	movs	r1, #128	; 0x80
 80002f6:	0249      	lsls	r1, r1, #9
 80002f8:	430a      	orrs	r2, r1
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 80002fa:	20c2      	movs	r0, #194	; 0xc2
 80002fc:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80002fe:	30ff      	adds	r0, #255	; 0xff
 8000300:	4281      	cmp	r1, r0
 8000302:	d002      	beq.n	800030a <HAL_ADC_Init+0xae>
    {
      tmpCFGR1 |= ( hadc->Init.ExternalTrigConv    |
 8000304:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8000306:	4301      	orrs	r1, r0
 8000308:	430a      	orrs	r2, r1
    /* Management of parameters "SamplingTimeCommon" and "SamplingTime"       */
    /* (obsolete): sampling time set in this function if parameter            */
    /*  "SamplingTimeCommon" has been set to a valid sampling time.           */
    /* Otherwise, sampling time is set into ADC channel initialization        */
    /* structure with parameter "SamplingTime" (obsolete).                    */
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 800030a:	2080      	movs	r0, #128	; 0x80
    hadc->Instance->CFGR1 |= tmpCFGR1;
 800030c:	68d9      	ldr	r1, [r3, #12]
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 800030e:	0540      	lsls	r0, r0, #21
    hadc->Instance->CFGR1 |= tmpCFGR1;
 8000310:	4311      	orrs	r1, r2
 8000312:	60d9      	str	r1, [r3, #12]
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8000314:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8000316:	4281      	cmp	r1, r0
 8000318:	d002      	beq.n	8000320 <HAL_ADC_Init+0xc4>
 800031a:	1e48      	subs	r0, r1, #1
 800031c:	2806      	cmp	r0, #6
 800031e:	d807      	bhi.n	8000330 <HAL_ADC_Init+0xd4>
    {
      /* Channel sampling time configuration */
      /* Clear the old sample time */
      hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 8000320:	2507      	movs	r5, #7
 8000322:	6958      	ldr	r0, [r3, #20]
      
      /* Set the new sample time */
      hadc->Instance->SMPR |= ADC_SMPR_SET(hadc->Init.SamplingTimeCommon);
 8000324:	4029      	ands	r1, r5
      hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 8000326:	43a8      	bics	r0, r5
 8000328:	6158      	str	r0, [r3, #20]
      hadc->Instance->SMPR |= ADC_SMPR_SET(hadc->Init.SamplingTimeCommon);
 800032a:	6958      	ldr	r0, [r3, #20]
 800032c:	4301      	orrs	r1, r0
 800032e:	6159      	str	r1, [r3, #20]
    /* Check back that ADC registers have effectively been configured to      */
    /* ensure of no potential problem of ADC core IP clocking.                */
    /* Check through register CFGR1 (excluding analog watchdog configuration: */
    /* set into separate dedicated function, and bits of ADC resolution set   */
    /* out of temporary variable 'tmpCFGR1').                                 */
    if ((hadc->Instance->CFGR1 & ~(ADC_CFGR1_AWDCH | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL | ADC_CFGR1_RES))
 8000330:	68db      	ldr	r3, [r3, #12]
 8000332:	491c      	ldr	r1, [pc, #112]	; (80003a4 <HAL_ADC_Init+0x148>)
 8000334:	400b      	ands	r3, r1
 8000336:	429a      	cmp	r2, r3
 8000338:	d111      	bne.n	800035e <HAL_ADC_Init+0x102>
         == tmpCFGR1)
    {
      /* Set ADC error code to none */
      ADC_CLEAR_ERRORCODE(hadc);
 800033a:	2000      	movs	r0, #0
      
      /* Set the ADC state */
      ADC_STATE_CLR_SET(hadc->State,
 800033c:	2203      	movs	r2, #3
      ADC_CLEAR_ERRORCODE(hadc);
 800033e:	64a0      	str	r0, [r4, #72]	; 0x48
      ADC_STATE_CLR_SET(hadc->State,
 8000340:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8000342:	4393      	bics	r3, r2
 8000344:	001a      	movs	r2, r3
 8000346:	2301      	movs	r3, #1
 8000348:	4313      	orrs	r3, r2
 800034a:	6463      	str	r3, [r4, #68]	; 0x44
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Return function status */
  return tmp_hal_status;
}
 800034c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800034e:	2020      	movs	r0, #32
 8000350:	6c65      	ldr	r5, [r4, #68]	; 0x44
 8000352:	4328      	orrs	r0, r5
 8000354:	6460      	str	r0, [r4, #68]	; 0x44
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8000356:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8000358:	4301      	orrs	r1, r0
 800035a:	64a1      	str	r1, [r4, #72]	; 0x48
 800035c:	e7cd      	b.n	80002fa <HAL_ADC_Init+0x9e>
      ADC_STATE_CLR_SET(hadc->State,
 800035e:	2212      	movs	r2, #18
 8000360:	6c63      	ldr	r3, [r4, #68]	; 0x44
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8000362:	2001      	movs	r0, #1
      ADC_STATE_CLR_SET(hadc->State,
 8000364:	4393      	bics	r3, r2
 8000366:	001a      	movs	r2, r3
 8000368:	2310      	movs	r3, #16
 800036a:	4313      	orrs	r3, r2
 800036c:	6463      	str	r3, [r4, #68]	; 0x44
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800036e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8000370:	4303      	orrs	r3, r0
 8000372:	64a3      	str	r3, [r4, #72]	; 0x48
 8000374:	e7ea      	b.n	800034c <HAL_ADC_Init+0xf0>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8000376:	2310      	movs	r3, #16
 8000378:	6c62      	ldr	r2, [r4, #68]	; 0x44
    tmp_hal_status = HAL_ERROR;
 800037a:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800037c:	4313      	orrs	r3, r2
 800037e:	6463      	str	r3, [r4, #68]	; 0x44
 8000380:	e7e4      	b.n	800034c <HAL_ADC_Init+0xf0>
      MODIFY_REG(hadc->Instance->CFGR1,
 8000382:	2118      	movs	r1, #24
 8000384:	68da      	ldr	r2, [r3, #12]
 8000386:	438a      	bics	r2, r1
 8000388:	68a1      	ldr	r1, [r4, #8]
 800038a:	430a      	orrs	r2, r1
 800038c:	60da      	str	r2, [r3, #12]
      MODIFY_REG(hadc->Instance->CFGR2    ,
 800038e:	6919      	ldr	r1, [r3, #16]
 8000390:	6862      	ldr	r2, [r4, #4]
 8000392:	0089      	lsls	r1, r1, #2
 8000394:	0889      	lsrs	r1, r1, #2
 8000396:	4311      	orrs	r1, r2
 8000398:	6119      	str	r1, [r3, #16]
 800039a:	e78a      	b.n	80002b2 <HAL_ADC_Init+0x56>
 800039c:	fffffefd 	.word	0xfffffefd
 80003a0:	fffe0219 	.word	0xfffe0219
 80003a4:	833fffe7 	.word	0x833fffe7

080003a8 <HAL_ADC_ConfigChannel>:
  * @param  hadc ADC handle
  * @param  sConfig Structure of ADC channel for regular group.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{
 80003a8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  __IO uint32_t wait_loop_index = 0U;
 80003aa:	2300      	movs	r3, #0
  {
    assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  }
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80003ac:	0004      	movs	r4, r0
  __IO uint32_t wait_loop_index = 0U;
 80003ae:	9301      	str	r3, [sp, #4]
  __HAL_LOCK(hadc);
 80003b0:	3440      	adds	r4, #64	; 0x40
 80003b2:	7823      	ldrb	r3, [r4, #0]
{
 80003b4:	0005      	movs	r5, r0
  __HAL_LOCK(hadc);
 80003b6:	2002      	movs	r0, #2
 80003b8:	2b01      	cmp	r3, #1
 80003ba:	d02b      	beq.n	8000414 <HAL_ADC_ConfigChannel+0x6c>
 80003bc:	2301      	movs	r3, #1
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel sampling time                                                 */
  /*  - Management of internal measurement channels: VrefInt/TempSensor/Vbat  */
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 80003be:	682a      	ldr	r2, [r5, #0]
  if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 80003c0:	6bae      	ldr	r6, [r5, #56]	; 0x38
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 80003c2:	6890      	ldr	r0, [r2, #8]
  __HAL_LOCK(hadc);
 80003c4:	7023      	strb	r3, [r4, #0]
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 80003c6:	0740      	lsls	r0, r0, #29
 80003c8:	d452      	bmi.n	8000470 <HAL_ADC_ConfigChannel+0xc8>
  {
    /* Configure channel: depending on rank setting, add it or remove it from */
    /* ADC conversion sequencer.                                              */
    if (sConfig->Rank != ADC_RANK_NONE)
 80003ca:	482c      	ldr	r0, [pc, #176]	; (800047c <HAL_ADC_ConfigChannel+0xd4>)
 80003cc:	684f      	ldr	r7, [r1, #4]
 80003ce:	680d      	ldr	r5, [r1, #0]
 80003d0:	4287      	cmp	r7, r0
 80003d2:	d03b      	beq.n	800044c <HAL_ADC_ConfigChannel+0xa4>
    {
      /* Regular sequence configuration */
      /* Set the channel selection register from the selected channel */
      hadc->Instance->CHSELR |= ADC_CHSELR_CHANNEL(sConfig->Channel);
 80003d4:	40ab      	lsls	r3, r5
 80003d6:	0018      	movs	r0, r3
      /* Channel sampling time configuration */
      /* Management of parameters "SamplingTimeCommon" and "SamplingTime"     */
      /* (obsolete): sampling time set in this function with                  */
      /* parameter "SamplingTime" (obsolete) only if not already set into     */
      /* ADC initialization structure with parameter "SamplingTimeCommon".    */
      if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 80003d8:	2380      	movs	r3, #128	; 0x80
      hadc->Instance->CHSELR |= ADC_CHSELR_CHANNEL(sConfig->Channel);
 80003da:	6a97      	ldr	r7, [r2, #40]	; 0x28
      if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 80003dc:	055b      	lsls	r3, r3, #21
      hadc->Instance->CHSELR |= ADC_CHSELR_CHANNEL(sConfig->Channel);
 80003de:	4338      	orrs	r0, r7
 80003e0:	6290      	str	r0, [r2, #40]	; 0x28
      if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 80003e2:	429e      	cmp	r6, r3
 80003e4:	d00f      	beq.n	8000406 <HAL_ADC_ConfigChannel+0x5e>
 80003e6:	3e01      	subs	r6, #1
 80003e8:	2e06      	cmp	r6, #6
 80003ea:	d90c      	bls.n	8000406 <HAL_ADC_ConfigChannel+0x5e>
      {
        /* Modify sampling time if needed (not needed in case of reoccurrence */
        /* for several channels programmed consecutively into the sequencer)  */
        if (sConfig->SamplingTime != ADC_GET_SAMPLINGTIME(hadc))
 80003ec:	688b      	ldr	r3, [r1, #8]
 80003ee:	2107      	movs	r1, #7
 80003f0:	6950      	ldr	r0, [r2, #20]
 80003f2:	4008      	ands	r0, r1
 80003f4:	4283      	cmp	r3, r0
 80003f6:	d006      	beq.n	8000406 <HAL_ADC_ConfigChannel+0x5e>
        {
          /* Channel sampling time configuration */
          /* Clear the old sample time */
          hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 80003f8:	6950      	ldr	r0, [r2, #20]
          
          /* Set the new sample time */
          hadc->Instance->SMPR |= ADC_SMPR_SET(sConfig->SamplingTime);
 80003fa:	400b      	ands	r3, r1
          hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 80003fc:	4388      	bics	r0, r1
 80003fe:	6150      	str	r0, [r2, #20]
          hadc->Instance->SMPR |= ADC_SMPR_SET(sConfig->SamplingTime);
 8000400:	6950      	ldr	r0, [r2, #20]
 8000402:	4303      	orrs	r3, r0
 8000404:	6153      	str	r3, [r2, #20]
      /* internal measurement paths enable: If internal channel selected,     */
      /* enable dedicated internal buffers and path.                          */
      /* Note: these internal measurement paths can be disabled using         */
      /*       HAL_ADC_DeInit() or removing the channel from sequencer with   */
      /*       channel configuration parameter "Rank".                        */
      if(ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 8000406:	002b      	movs	r3, r5
 8000408:	3b10      	subs	r3, #16
 800040a:	2b01      	cmp	r3, #1
 800040c:	d903      	bls.n	8000416 <HAL_ADC_ConfigChannel+0x6e>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800040e:	2000      	movs	r0, #0
    
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8000410:	2300      	movs	r3, #0
 8000412:	7023      	strb	r3, [r4, #0]
  
  /* Return function status */
  return tmp_hal_status;
}
 8000414:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        ADC->CCR |= ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 8000416:	4b1a      	ldr	r3, [pc, #104]	; (8000480 <HAL_ADC_ConfigChannel+0xd8>)
 8000418:	2280      	movs	r2, #128	; 0x80
 800041a:	6819      	ldr	r1, [r3, #0]
 800041c:	2d10      	cmp	r5, #16
 800041e:	d013      	beq.n	8000448 <HAL_ADC_ConfigChannel+0xa0>
 8000420:	03d2      	lsls	r2, r2, #15
 8000422:	430a      	orrs	r2, r1
 8000424:	601a      	str	r2, [r3, #0]
        if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 8000426:	2d10      	cmp	r5, #16
 8000428:	d1f1      	bne.n	800040e <HAL_ADC_ConfigChannel+0x66>
          wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 800042a:	4b16      	ldr	r3, [pc, #88]	; (8000484 <HAL_ADC_ConfigChannel+0xdc>)
 800042c:	4916      	ldr	r1, [pc, #88]	; (8000488 <HAL_ADC_ConfigChannel+0xe0>)
 800042e:	6818      	ldr	r0, [r3, #0]
 8000430:	f7ff fe6a 	bl	8000108 <__udivsi3>
 8000434:	230a      	movs	r3, #10
 8000436:	4358      	muls	r0, r3
 8000438:	9001      	str	r0, [sp, #4]
          while(wait_loop_index != 0U)
 800043a:	9b01      	ldr	r3, [sp, #4]
 800043c:	2b00      	cmp	r3, #0
 800043e:	d0e6      	beq.n	800040e <HAL_ADC_ConfigChannel+0x66>
            wait_loop_index--;
 8000440:	9b01      	ldr	r3, [sp, #4]
 8000442:	3b01      	subs	r3, #1
 8000444:	9301      	str	r3, [sp, #4]
 8000446:	e7f8      	b.n	800043a <HAL_ADC_ConfigChannel+0x92>
        ADC->CCR |= ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 8000448:	0412      	lsls	r2, r2, #16
 800044a:	e7ea      	b.n	8000422 <HAL_ADC_ConfigChannel+0x7a>
      hadc->Instance->CHSELR &= ~ADC_CHSELR_CHANNEL(sConfig->Channel);
 800044c:	40ab      	lsls	r3, r5
 800044e:	6a91      	ldr	r1, [r2, #40]	; 0x28
 8000450:	4399      	bics	r1, r3
      if(ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 8000452:	002b      	movs	r3, r5
 8000454:	3b10      	subs	r3, #16
      hadc->Instance->CHSELR &= ~ADC_CHSELR_CHANNEL(sConfig->Channel);
 8000456:	6291      	str	r1, [r2, #40]	; 0x28
      if(ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 8000458:	2b01      	cmp	r3, #1
 800045a:	d8d8      	bhi.n	800040e <HAL_ADC_ConfigChannel+0x66>
        ADC->CCR &= ~ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 800045c:	4b08      	ldr	r3, [pc, #32]	; (8000480 <HAL_ADC_ConfigChannel+0xd8>)
 800045e:	681a      	ldr	r2, [r3, #0]
 8000460:	2d10      	cmp	r5, #16
 8000462:	d003      	beq.n	800046c <HAL_ADC_ConfigChannel+0xc4>
 8000464:	4909      	ldr	r1, [pc, #36]	; (800048c <HAL_ADC_ConfigChannel+0xe4>)
 8000466:	400a      	ands	r2, r1
 8000468:	601a      	str	r2, [r3, #0]
 800046a:	e7d0      	b.n	800040e <HAL_ADC_ConfigChannel+0x66>
 800046c:	4908      	ldr	r1, [pc, #32]	; (8000490 <HAL_ADC_ConfigChannel+0xe8>)
 800046e:	e7fa      	b.n	8000466 <HAL_ADC_ConfigChannel+0xbe>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8000470:	2220      	movs	r2, #32
 8000472:	6c69      	ldr	r1, [r5, #68]	; 0x44
    tmp_hal_status = HAL_ERROR;
 8000474:	0018      	movs	r0, r3
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8000476:	430a      	orrs	r2, r1
 8000478:	646a      	str	r2, [r5, #68]	; 0x44
 800047a:	e7c9      	b.n	8000410 <HAL_ADC_ConfigChannel+0x68>
 800047c:	00001001 	.word	0x00001001
 8000480:	40012708 	.word	0x40012708
 8000484:	20000004 	.word	0x20000004
 8000488:	000f4240 	.word	0x000f4240
 800048c:	ffbfffff 	.word	0xffbfffff
 8000490:	ff7fffff 	.word	0xff7fffff

08000494 <HAL_NVIC_SetPriority>:
  *         with stm32f0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0 based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000494:	b570      	push	{r4, r5, r6, lr}
 8000496:	0189      	lsls	r1, r1, #6
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8000498:	2800      	cmp	r0, #0
 800049a:	da14      	bge.n	80004c6 <HAL_NVIC_SetPriority+0x32>
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800049c:	230f      	movs	r3, #15
 800049e:	b2c0      	uxtb	r0, r0
 80004a0:	4003      	ands	r3, r0
 80004a2:	3b08      	subs	r3, #8
 80004a4:	4a11      	ldr	r2, [pc, #68]	; (80004ec <HAL_NVIC_SetPriority+0x58>)
 80004a6:	089b      	lsrs	r3, r3, #2
 80004a8:	009b      	lsls	r3, r3, #2
 80004aa:	189b      	adds	r3, r3, r2
 80004ac:	2203      	movs	r2, #3
 80004ae:	4010      	ands	r0, r2
 80004b0:	4090      	lsls	r0, r2
 80004b2:	32fc      	adds	r2, #252	; 0xfc
 80004b4:	0015      	movs	r5, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 80004b6:	4011      	ands	r1, r2
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80004b8:	4085      	lsls	r5, r0
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 80004ba:	4081      	lsls	r1, r0
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80004bc:	69dc      	ldr	r4, [r3, #28]
 80004be:	43ac      	bics	r4, r5
 80004c0:	4321      	orrs	r1, r4
 80004c2:	61d9      	str	r1, [r3, #28]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
}
 80004c4:	bd70      	pop	{r4, r5, r6, pc}
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80004c6:	2503      	movs	r5, #3
 80004c8:	0883      	lsrs	r3, r0, #2
 80004ca:	4028      	ands	r0, r5
 80004cc:	40a8      	lsls	r0, r5
 80004ce:	35fc      	adds	r5, #252	; 0xfc
 80004d0:	002e      	movs	r6, r5
 80004d2:	4a07      	ldr	r2, [pc, #28]	; (80004f0 <HAL_NVIC_SetPriority+0x5c>)
 80004d4:	009b      	lsls	r3, r3, #2
 80004d6:	189b      	adds	r3, r3, r2
 80004d8:	22c0      	movs	r2, #192	; 0xc0
 80004da:	4086      	lsls	r6, r0
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 80004dc:	4029      	ands	r1, r5
 80004de:	4081      	lsls	r1, r0
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80004e0:	0092      	lsls	r2, r2, #2
 80004e2:	589c      	ldr	r4, [r3, r2]
 80004e4:	43b4      	bics	r4, r6
 80004e6:	4321      	orrs	r1, r4
 80004e8:	5099      	str	r1, [r3, r2]
 80004ea:	e7eb      	b.n	80004c4 <HAL_NVIC_SetPriority+0x30>
 80004ec:	e000ed00 	.word	0xe000ed00
 80004f0:	e000e100 	.word	0xe000e100

080004f4 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80004f4:	231f      	movs	r3, #31
 80004f6:	4018      	ands	r0, r3
 80004f8:	3b1e      	subs	r3, #30
 80004fa:	4083      	lsls	r3, r0
 80004fc:	4a01      	ldr	r2, [pc, #4]	; (8000504 <HAL_NVIC_EnableIRQ+0x10>)
 80004fe:	6013      	str	r3, [r2, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8000500:	4770      	bx	lr
 8000502:	46c0      	nop			; (mov r8, r8)
 8000504:	e000e100 	.word	0xe000e100

08000508 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{ 
 8000508:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull)); 

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 800050a:	680b      	ldr	r3, [r1, #0]
{ 
 800050c:	b087      	sub	sp, #28
  while (((GPIO_Init->Pin) >> position) != RESET)
 800050e:	9302      	str	r3, [sp, #8]
  uint32_t position = 0x00U;
 8000510:	2300      	movs	r3, #0
{ 
 8000512:	9101      	str	r1, [sp, #4]
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000514:	9a02      	ldr	r2, [sp, #8]
 8000516:	40da      	lsrs	r2, r3
 8000518:	d101      	bne.n	800051e <HAL_GPIO_Init+0x16>
      }
    }
    
    position++;
  } 
}
 800051a:	b007      	add	sp, #28
 800051c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 800051e:	2201      	movs	r2, #1
 8000520:	409a      	lsls	r2, r3
 8000522:	9203      	str	r2, [sp, #12]
 8000524:	9903      	ldr	r1, [sp, #12]
 8000526:	9a02      	ldr	r2, [sp, #8]
 8000528:	400a      	ands	r2, r1
 800052a:	9200      	str	r2, [sp, #0]
    if(iocurrent)
 800052c:	d100      	bne.n	8000530 <HAL_GPIO_Init+0x28>
 800052e:	e08c      	b.n	800064a <HAL_GPIO_Init+0x142>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
 8000530:	9a01      	ldr	r2, [sp, #4]
 8000532:	2110      	movs	r1, #16
 8000534:	6852      	ldr	r2, [r2, #4]
 8000536:	0016      	movs	r6, r2
 8000538:	438e      	bics	r6, r1
 800053a:	2e02      	cmp	r6, #2
 800053c:	d10e      	bne.n	800055c <HAL_GPIO_Init+0x54>
        CLEAR_BIT(temp, 0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;      
 800053e:	2507      	movs	r5, #7
 8000540:	401d      	ands	r5, r3
 8000542:	00ad      	lsls	r5, r5, #2
 8000544:	3901      	subs	r1, #1
 8000546:	40a9      	lsls	r1, r5
        temp = GPIOx->AFR[position >> 3];
 8000548:	08dc      	lsrs	r4, r3, #3
 800054a:	00a4      	lsls	r4, r4, #2
 800054c:	1904      	adds	r4, r0, r4
 800054e:	6a27      	ldr	r7, [r4, #32]
        CLEAR_BIT(temp, 0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;      
 8000550:	438f      	bics	r7, r1
        SET_BIT(temp, (uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));       
 8000552:	9901      	ldr	r1, [sp, #4]
 8000554:	6909      	ldr	r1, [r1, #16]
 8000556:	40a9      	lsls	r1, r5
 8000558:	430f      	orrs	r7, r1
        GPIOx->AFR[position >> 3U] = temp;
 800055a:	6227      	str	r7, [r4, #32]
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2U));   
 800055c:	2403      	movs	r4, #3
 800055e:	005f      	lsls	r7, r3, #1
 8000560:	40bc      	lsls	r4, r7
 8000562:	43e4      	mvns	r4, r4
      temp = GPIOx->MODER;
 8000564:	6805      	ldr	r5, [r0, #0]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000566:	3e01      	subs	r6, #1
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2U));   
 8000568:	4025      	ands	r5, r4
 800056a:	46ac      	mov	ip, r5
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800056c:	2503      	movs	r5, #3
 800056e:	4015      	ands	r5, r2
 8000570:	40bd      	lsls	r5, r7
 8000572:	4661      	mov	r1, ip
 8000574:	430d      	orrs	r5, r1
      GPIOx->MODER = temp;
 8000576:	6005      	str	r5, [r0, #0]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000578:	2e01      	cmp	r6, #1
 800057a:	d80f      	bhi.n	800059c <HAL_GPIO_Init+0x94>
        SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 800057c:	9901      	ldr	r1, [sp, #4]
        temp = GPIOx->OSPEEDR; 
 800057e:	6886      	ldr	r6, [r0, #8]
        SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 8000580:	68cd      	ldr	r5, [r1, #12]
        CLEAR_BIT(temp, GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8000582:	4026      	ands	r6, r4
        SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 8000584:	40bd      	lsls	r5, r7
 8000586:	4335      	orrs	r5, r6
        GPIOx->OSPEEDR = temp;
 8000588:	6085      	str	r5, [r0, #8]
        temp = GPIOx->OTYPER;
 800058a:	6846      	ldr	r6, [r0, #4]
        CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 800058c:	9903      	ldr	r1, [sp, #12]
        SET_BIT(temp, ((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 800058e:	0915      	lsrs	r5, r2, #4
        CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 8000590:	438e      	bics	r6, r1
        SET_BIT(temp, ((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8000592:	2101      	movs	r1, #1
 8000594:	400d      	ands	r5, r1
 8000596:	409d      	lsls	r5, r3
 8000598:	4335      	orrs	r5, r6
        GPIOx->OTYPER = temp;
 800059a:	6045      	str	r5, [r0, #4]
      temp = GPIOx->PUPDR;
 800059c:	68c5      	ldr	r5, [r0, #12]
      SET_BIT(temp, (GPIO_Init->Pull) << (position * 2U));
 800059e:	9901      	ldr	r1, [sp, #4]
      CLEAR_BIT(temp, GPIO_PUPDR_PUPDR0 << (position * 2U));
 80005a0:	402c      	ands	r4, r5
      SET_BIT(temp, (GPIO_Init->Pull) << (position * 2U));
 80005a2:	688d      	ldr	r5, [r1, #8]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 80005a4:	2180      	movs	r1, #128	; 0x80
      SET_BIT(temp, (GPIO_Init->Pull) << (position * 2U));
 80005a6:	40bd      	lsls	r5, r7
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 80005a8:	0549      	lsls	r1, r1, #21
      SET_BIT(temp, (GPIO_Init->Pull) << (position * 2U));
 80005aa:	432c      	orrs	r4, r5
      GPIOx->PUPDR = temp;
 80005ac:	60c4      	str	r4, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 80005ae:	420a      	tst	r2, r1
 80005b0:	d04b      	beq.n	800064a <HAL_GPIO_Init+0x142>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80005b2:	2101      	movs	r1, #1
 80005b4:	4c26      	ldr	r4, [pc, #152]	; (8000650 <HAL_GPIO_Init+0x148>)
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 80005b6:	2603      	movs	r6, #3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80005b8:	69a5      	ldr	r5, [r4, #24]
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 80005ba:	401e      	ands	r6, r3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80005bc:	430d      	orrs	r5, r1
 80005be:	61a5      	str	r5, [r4, #24]
 80005c0:	69a4      	ldr	r4, [r4, #24]
        temp = SYSCFG->EXTICR[position >> 2];
 80005c2:	089d      	lsrs	r5, r3, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80005c4:	400c      	ands	r4, r1
 80005c6:	9405      	str	r4, [sp, #20]
 80005c8:	9c05      	ldr	r4, [sp, #20]
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 80005ca:	240f      	movs	r4, #15
 80005cc:	4921      	ldr	r1, [pc, #132]	; (8000654 <HAL_GPIO_Init+0x14c>)
 80005ce:	00ad      	lsls	r5, r5, #2
 80005d0:	00b6      	lsls	r6, r6, #2
 80005d2:	186d      	adds	r5, r5, r1
 80005d4:	40b4      	lsls	r4, r6
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80005d6:	2190      	movs	r1, #144	; 0x90
        temp = SYSCFG->EXTICR[position >> 2];
 80005d8:	68af      	ldr	r7, [r5, #8]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80005da:	05c9      	lsls	r1, r1, #23
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 80005dc:	43a7      	bics	r7, r4
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80005de:	2400      	movs	r4, #0
 80005e0:	4288      	cmp	r0, r1
 80005e2:	d00c      	beq.n	80005fe <HAL_GPIO_Init+0xf6>
 80005e4:	491c      	ldr	r1, [pc, #112]	; (8000658 <HAL_GPIO_Init+0x150>)
 80005e6:	3401      	adds	r4, #1
 80005e8:	4288      	cmp	r0, r1
 80005ea:	d008      	beq.n	80005fe <HAL_GPIO_Init+0xf6>
 80005ec:	491b      	ldr	r1, [pc, #108]	; (800065c <HAL_GPIO_Init+0x154>)
 80005ee:	3401      	adds	r4, #1
 80005f0:	4288      	cmp	r0, r1
 80005f2:	d004      	beq.n	80005fe <HAL_GPIO_Init+0xf6>
 80005f4:	491a      	ldr	r1, [pc, #104]	; (8000660 <HAL_GPIO_Init+0x158>)
 80005f6:	3403      	adds	r4, #3
 80005f8:	4288      	cmp	r0, r1
 80005fa:	d100      	bne.n	80005fe <HAL_GPIO_Init+0xf6>
 80005fc:	3c02      	subs	r4, #2
 80005fe:	40b4      	lsls	r4, r6
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 8000600:	9900      	ldr	r1, [sp, #0]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000602:	433c      	orrs	r4, r7
          SET_BIT(temp, iocurrent); 
 8000604:	000e      	movs	r6, r1
        SYSCFG->EXTICR[position >> 2] = temp;
 8000606:	60ac      	str	r4, [r5, #8]
        temp = EXTI->IMR;
 8000608:	4c16      	ldr	r4, [pc, #88]	; (8000664 <HAL_GPIO_Init+0x15c>)
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 800060a:	43cd      	mvns	r5, r1
        temp = EXTI->IMR;
 800060c:	6827      	ldr	r7, [r4, #0]
          SET_BIT(temp, iocurrent); 
 800060e:	433e      	orrs	r6, r7
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8000610:	03d1      	lsls	r1, r2, #15
 8000612:	d401      	bmi.n	8000618 <HAL_GPIO_Init+0x110>
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 8000614:	003e      	movs	r6, r7
 8000616:	402e      	ands	r6, r5
        EXTI->IMR = temp;
 8000618:	6026      	str	r6, [r4, #0]
        temp = EXTI->EMR;
 800061a:	6867      	ldr	r7, [r4, #4]
          SET_BIT(temp, iocurrent); 
 800061c:	9e00      	ldr	r6, [sp, #0]
 800061e:	433e      	orrs	r6, r7
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000620:	0391      	lsls	r1, r2, #14
 8000622:	d401      	bmi.n	8000628 <HAL_GPIO_Init+0x120>
        CLEAR_BIT(temp, (uint32_t)iocurrent);      
 8000624:	003e      	movs	r6, r7
 8000626:	402e      	ands	r6, r5
        EXTI->EMR = temp;
 8000628:	6066      	str	r6, [r4, #4]
        temp = EXTI->RTSR;
 800062a:	68a7      	ldr	r7, [r4, #8]
          SET_BIT(temp, iocurrent); 
 800062c:	9e00      	ldr	r6, [sp, #0]
 800062e:	433e      	orrs	r6, r7
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8000630:	02d1      	lsls	r1, r2, #11
 8000632:	d401      	bmi.n	8000638 <HAL_GPIO_Init+0x130>
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
 8000634:	003e      	movs	r6, r7
 8000636:	402e      	ands	r6, r5
        EXTI->RTSR = temp;
 8000638:	60a6      	str	r6, [r4, #8]
        temp = EXTI->FTSR;
 800063a:	68e6      	ldr	r6, [r4, #12]
          SET_BIT(temp, iocurrent); 
 800063c:	9f00      	ldr	r7, [sp, #0]
 800063e:	4337      	orrs	r7, r6
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000640:	0292      	lsls	r2, r2, #10
 8000642:	d401      	bmi.n	8000648 <HAL_GPIO_Init+0x140>
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
 8000644:	402e      	ands	r6, r5
 8000646:	0037      	movs	r7, r6
        EXTI->FTSR = temp;
 8000648:	60e7      	str	r7, [r4, #12]
    position++;
 800064a:	3301      	adds	r3, #1
 800064c:	e762      	b.n	8000514 <HAL_GPIO_Init+0xc>
 800064e:	46c0      	nop			; (mov r8, r8)
 8000650:	40021000 	.word	0x40021000
 8000654:	40010000 	.word	0x40010000
 8000658:	48000400 	.word	0x48000400
 800065c:	48000800 	.word	0x48000800
 8000660:	48000c00 	.word	0x48000c00
 8000664:	40010400 	.word	0x40010400

08000668 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8000668:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800066a:	6803      	ldr	r3, [r0, #0]
{
 800066c:	b085      	sub	sp, #20
 800066e:	0005      	movs	r5, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000670:	07db      	lsls	r3, r3, #31
 8000672:	d42f      	bmi.n	80006d4 <HAL_RCC_OscConfig+0x6c>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8000674:	682b      	ldr	r3, [r5, #0]
 8000676:	079b      	lsls	r3, r3, #30
 8000678:	d500      	bpl.n	800067c <HAL_RCC_OscConfig+0x14>
 800067a:	e081      	b.n	8000780 <HAL_RCC_OscConfig+0x118>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800067c:	682b      	ldr	r3, [r5, #0]
 800067e:	071b      	lsls	r3, r3, #28
 8000680:	d500      	bpl.n	8000684 <HAL_RCC_OscConfig+0x1c>
 8000682:	e0bc      	b.n	80007fe <HAL_RCC_OscConfig+0x196>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8000684:	682b      	ldr	r3, [r5, #0]
 8000686:	075b      	lsls	r3, r3, #29
 8000688:	d500      	bpl.n	800068c <HAL_RCC_OscConfig+0x24>
 800068a:	e0df      	b.n	800084c <HAL_RCC_OscConfig+0x1e4>
      __HAL_RCC_PWR_CLK_DISABLE();
    }
  }

  /*----------------------------- HSI14 Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI14) == RCC_OSCILLATORTYPE_HSI14)
 800068c:	682b      	ldr	r3, [r5, #0]
 800068e:	06db      	lsls	r3, r3, #27
 8000690:	d51a      	bpl.n	80006c8 <HAL_RCC_OscConfig+0x60>
    /* Check the parameters */
    assert_param(IS_RCC_HSI14(RCC_OscInitStruct->HSI14State));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSI14CalibrationValue));

    /* Check the HSI14 State */
    if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ON)
 8000692:	696a      	ldr	r2, [r5, #20]
 8000694:	4cb5      	ldr	r4, [pc, #724]	; (800096c <HAL_RCC_OscConfig+0x304>)
 8000696:	2304      	movs	r3, #4
 8000698:	2a01      	cmp	r2, #1
 800069a:	d000      	beq.n	800069e <HAL_RCC_OscConfig+0x36>
 800069c:	e14b      	b.n	8000936 <HAL_RCC_OscConfig+0x2ce>
    {
      /* Disable ADC control of the Internal High Speed oscillator HSI14 */
      __HAL_RCC_HSI14ADC_DISABLE();
 800069e:	6b61      	ldr	r1, [r4, #52]	; 0x34

      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till HSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 80006a0:	2602      	movs	r6, #2
      __HAL_RCC_HSI14ADC_DISABLE();
 80006a2:	430b      	orrs	r3, r1
 80006a4:	6363      	str	r3, [r4, #52]	; 0x34
      __HAL_RCC_HSI14_ENABLE();
 80006a6:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80006a8:	431a      	orrs	r2, r3
 80006aa:	6362      	str	r2, [r4, #52]	; 0x34
      tickstart = HAL_GetTick();
 80006ac:	f7ff fdd0 	bl	8000250 <HAL_GetTick>
 80006b0:	0007      	movs	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 80006b2:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80006b4:	4233      	tst	r3, r6
 80006b6:	d100      	bne.n	80006ba <HAL_RCC_OscConfig+0x52>
 80006b8:	e136      	b.n	8000928 <HAL_RCC_OscConfig+0x2c0>
    {
      /* Enable ADC control of the Internal High Speed oscillator HSI14 */
      __HAL_RCC_HSI14ADC_ENABLE();

      /* Adjusts the Internal High Speed oscillator 14Mhz (HSI14) calibration value. */
      __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSI14CalibrationValue);
 80006ba:	21f8      	movs	r1, #248	; 0xf8
 80006bc:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80006be:	69ab      	ldr	r3, [r5, #24]
 80006c0:	438a      	bics	r2, r1
 80006c2:	00db      	lsls	r3, r3, #3
 80006c4:	4313      	orrs	r3, r2
 80006c6:	6363      	str	r3, [r4, #52]	; 0x34
#endif /* RCC_HSI48_SUPPORT */
       
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80006c8:	6a29      	ldr	r1, [r5, #32]
 80006ca:	2900      	cmp	r1, #0
 80006cc:	d000      	beq.n	80006d0 <HAL_RCC_OscConfig+0x68>
 80006ce:	e159      	b.n	8000984 <HAL_RCC_OscConfig+0x31c>
    {
      return HAL_ERROR;
    }
  }
  
  return HAL_OK;
 80006d0:	2000      	movs	r0, #0
 80006d2:	e013      	b.n	80006fc <HAL_RCC_OscConfig+0x94>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 80006d4:	210c      	movs	r1, #12
 80006d6:	4ca5      	ldr	r4, [pc, #660]	; (800096c <HAL_RCC_OscConfig+0x304>)
 80006d8:	6862      	ldr	r2, [r4, #4]
 80006da:	400a      	ands	r2, r1
 80006dc:	2a04      	cmp	r2, #4
 80006de:	d006      	beq.n	80006ee <HAL_RCC_OscConfig+0x86>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80006e0:	6863      	ldr	r3, [r4, #4]
 80006e2:	400b      	ands	r3, r1
 80006e4:	2b08      	cmp	r3, #8
 80006e6:	d10b      	bne.n	8000700 <HAL_RCC_OscConfig+0x98>
 80006e8:	6863      	ldr	r3, [r4, #4]
 80006ea:	03db      	lsls	r3, r3, #15
 80006ec:	d508      	bpl.n	8000700 <HAL_RCC_OscConfig+0x98>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80006ee:	6823      	ldr	r3, [r4, #0]
 80006f0:	039b      	lsls	r3, r3, #14
 80006f2:	d5bf      	bpl.n	8000674 <HAL_RCC_OscConfig+0xc>
 80006f4:	686b      	ldr	r3, [r5, #4]
 80006f6:	2b00      	cmp	r3, #0
 80006f8:	d1bc      	bne.n	8000674 <HAL_RCC_OscConfig+0xc>
        return HAL_ERROR;
 80006fa:	2001      	movs	r0, #1
}
 80006fc:	b005      	add	sp, #20
 80006fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000700:	686b      	ldr	r3, [r5, #4]
 8000702:	2b01      	cmp	r3, #1
 8000704:	d113      	bne.n	800072e <HAL_RCC_OscConfig+0xc6>
 8000706:	2380      	movs	r3, #128	; 0x80
 8000708:	6822      	ldr	r2, [r4, #0]
 800070a:	025b      	lsls	r3, r3, #9
 800070c:	4313      	orrs	r3, r2
 800070e:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8000710:	f7ff fd9e 	bl	8000250 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000714:	2680      	movs	r6, #128	; 0x80
        tickstart = HAL_GetTick();
 8000716:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000718:	02b6      	lsls	r6, r6, #10
 800071a:	6823      	ldr	r3, [r4, #0]
 800071c:	4233      	tst	r3, r6
 800071e:	d1a9      	bne.n	8000674 <HAL_RCC_OscConfig+0xc>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000720:	f7ff fd96 	bl	8000250 <HAL_GetTick>
 8000724:	1bc0      	subs	r0, r0, r7
 8000726:	2864      	cmp	r0, #100	; 0x64
 8000728:	d9f7      	bls.n	800071a <HAL_RCC_OscConfig+0xb2>
            return HAL_TIMEOUT;
 800072a:	2003      	movs	r0, #3
 800072c:	e7e6      	b.n	80006fc <HAL_RCC_OscConfig+0x94>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800072e:	2b00      	cmp	r3, #0
 8000730:	d116      	bne.n	8000760 <HAL_RCC_OscConfig+0xf8>
 8000732:	6823      	ldr	r3, [r4, #0]
 8000734:	4a8e      	ldr	r2, [pc, #568]	; (8000970 <HAL_RCC_OscConfig+0x308>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000736:	2680      	movs	r6, #128	; 0x80
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000738:	4013      	ands	r3, r2
 800073a:	6023      	str	r3, [r4, #0]
 800073c:	6823      	ldr	r3, [r4, #0]
 800073e:	4a8d      	ldr	r2, [pc, #564]	; (8000974 <HAL_RCC_OscConfig+0x30c>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000740:	02b6      	lsls	r6, r6, #10
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000742:	4013      	ands	r3, r2
 8000744:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8000746:	f7ff fd83 	bl	8000250 <HAL_GetTick>
 800074a:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800074c:	6823      	ldr	r3, [r4, #0]
 800074e:	4233      	tst	r3, r6
 8000750:	d100      	bne.n	8000754 <HAL_RCC_OscConfig+0xec>
 8000752:	e78f      	b.n	8000674 <HAL_RCC_OscConfig+0xc>
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000754:	f7ff fd7c 	bl	8000250 <HAL_GetTick>
 8000758:	1bc0      	subs	r0, r0, r7
 800075a:	2864      	cmp	r0, #100	; 0x64
 800075c:	d9f6      	bls.n	800074c <HAL_RCC_OscConfig+0xe4>
 800075e:	e7e4      	b.n	800072a <HAL_RCC_OscConfig+0xc2>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000760:	2b05      	cmp	r3, #5
 8000762:	d105      	bne.n	8000770 <HAL_RCC_OscConfig+0x108>
 8000764:	2380      	movs	r3, #128	; 0x80
 8000766:	6822      	ldr	r2, [r4, #0]
 8000768:	02db      	lsls	r3, r3, #11
 800076a:	4313      	orrs	r3, r2
 800076c:	6023      	str	r3, [r4, #0]
 800076e:	e7ca      	b.n	8000706 <HAL_RCC_OscConfig+0x9e>
 8000770:	6823      	ldr	r3, [r4, #0]
 8000772:	4a7f      	ldr	r2, [pc, #508]	; (8000970 <HAL_RCC_OscConfig+0x308>)
 8000774:	4013      	ands	r3, r2
 8000776:	6023      	str	r3, [r4, #0]
 8000778:	6823      	ldr	r3, [r4, #0]
 800077a:	4a7e      	ldr	r2, [pc, #504]	; (8000974 <HAL_RCC_OscConfig+0x30c>)
 800077c:	4013      	ands	r3, r2
 800077e:	e7c6      	b.n	800070e <HAL_RCC_OscConfig+0xa6>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 8000780:	220c      	movs	r2, #12
 8000782:	4c7a      	ldr	r4, [pc, #488]	; (800096c <HAL_RCC_OscConfig+0x304>)
 8000784:	6863      	ldr	r3, [r4, #4]
 8000786:	4213      	tst	r3, r2
 8000788:	d006      	beq.n	8000798 <HAL_RCC_OscConfig+0x130>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 800078a:	6863      	ldr	r3, [r4, #4]
 800078c:	4013      	ands	r3, r2
 800078e:	2b08      	cmp	r3, #8
 8000790:	d110      	bne.n	80007b4 <HAL_RCC_OscConfig+0x14c>
 8000792:	6863      	ldr	r3, [r4, #4]
 8000794:	03db      	lsls	r3, r3, #15
 8000796:	d40d      	bmi.n	80007b4 <HAL_RCC_OscConfig+0x14c>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8000798:	6823      	ldr	r3, [r4, #0]
 800079a:	079b      	lsls	r3, r3, #30
 800079c:	d502      	bpl.n	80007a4 <HAL_RCC_OscConfig+0x13c>
 800079e:	68eb      	ldr	r3, [r5, #12]
 80007a0:	2b01      	cmp	r3, #1
 80007a2:	d1aa      	bne.n	80006fa <HAL_RCC_OscConfig+0x92>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80007a4:	21f8      	movs	r1, #248	; 0xf8
 80007a6:	6822      	ldr	r2, [r4, #0]
 80007a8:	692b      	ldr	r3, [r5, #16]
 80007aa:	438a      	bics	r2, r1
 80007ac:	00db      	lsls	r3, r3, #3
 80007ae:	4313      	orrs	r3, r2
 80007b0:	6023      	str	r3, [r4, #0]
 80007b2:	e763      	b.n	800067c <HAL_RCC_OscConfig+0x14>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80007b4:	68ea      	ldr	r2, [r5, #12]
 80007b6:	2301      	movs	r3, #1
 80007b8:	2a00      	cmp	r2, #0
 80007ba:	d00f      	beq.n	80007dc <HAL_RCC_OscConfig+0x174>
        __HAL_RCC_HSI_ENABLE();
 80007bc:	6822      	ldr	r2, [r4, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80007be:	2602      	movs	r6, #2
        __HAL_RCC_HSI_ENABLE();
 80007c0:	4313      	orrs	r3, r2
 80007c2:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 80007c4:	f7ff fd44 	bl	8000250 <HAL_GetTick>
 80007c8:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80007ca:	6823      	ldr	r3, [r4, #0]
 80007cc:	4233      	tst	r3, r6
 80007ce:	d1e9      	bne.n	80007a4 <HAL_RCC_OscConfig+0x13c>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80007d0:	f7ff fd3e 	bl	8000250 <HAL_GetTick>
 80007d4:	1bc0      	subs	r0, r0, r7
 80007d6:	2802      	cmp	r0, #2
 80007d8:	d9f7      	bls.n	80007ca <HAL_RCC_OscConfig+0x162>
 80007da:	e7a6      	b.n	800072a <HAL_RCC_OscConfig+0xc2>
        __HAL_RCC_HSI_DISABLE();
 80007dc:	6822      	ldr	r2, [r4, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80007de:	2602      	movs	r6, #2
        __HAL_RCC_HSI_DISABLE();
 80007e0:	439a      	bics	r2, r3
 80007e2:	6022      	str	r2, [r4, #0]
        tickstart = HAL_GetTick();
 80007e4:	f7ff fd34 	bl	8000250 <HAL_GetTick>
 80007e8:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80007ea:	6823      	ldr	r3, [r4, #0]
 80007ec:	4233      	tst	r3, r6
 80007ee:	d100      	bne.n	80007f2 <HAL_RCC_OscConfig+0x18a>
 80007f0:	e744      	b.n	800067c <HAL_RCC_OscConfig+0x14>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80007f2:	f7ff fd2d 	bl	8000250 <HAL_GetTick>
 80007f6:	1bc0      	subs	r0, r0, r7
 80007f8:	2802      	cmp	r0, #2
 80007fa:	d9f6      	bls.n	80007ea <HAL_RCC_OscConfig+0x182>
 80007fc:	e795      	b.n	800072a <HAL_RCC_OscConfig+0xc2>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 80007fe:	69ea      	ldr	r2, [r5, #28]
 8000800:	2301      	movs	r3, #1
 8000802:	4c5a      	ldr	r4, [pc, #360]	; (800096c <HAL_RCC_OscConfig+0x304>)
 8000804:	2a00      	cmp	r2, #0
 8000806:	d010      	beq.n	800082a <HAL_RCC_OscConfig+0x1c2>
      __HAL_RCC_LSI_ENABLE();
 8000808:	6a62      	ldr	r2, [r4, #36]	; 0x24
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800080a:	2602      	movs	r6, #2
      __HAL_RCC_LSI_ENABLE();
 800080c:	4313      	orrs	r3, r2
 800080e:	6263      	str	r3, [r4, #36]	; 0x24
      tickstart = HAL_GetTick();
 8000810:	f7ff fd1e 	bl	8000250 <HAL_GetTick>
 8000814:	0007      	movs	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8000816:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000818:	4233      	tst	r3, r6
 800081a:	d000      	beq.n	800081e <HAL_RCC_OscConfig+0x1b6>
 800081c:	e732      	b.n	8000684 <HAL_RCC_OscConfig+0x1c>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800081e:	f7ff fd17 	bl	8000250 <HAL_GetTick>
 8000822:	1bc0      	subs	r0, r0, r7
 8000824:	2802      	cmp	r0, #2
 8000826:	d9f6      	bls.n	8000816 <HAL_RCC_OscConfig+0x1ae>
 8000828:	e77f      	b.n	800072a <HAL_RCC_OscConfig+0xc2>
      __HAL_RCC_LSI_DISABLE();
 800082a:	6a62      	ldr	r2, [r4, #36]	; 0x24
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800082c:	2602      	movs	r6, #2
      __HAL_RCC_LSI_DISABLE();
 800082e:	439a      	bics	r2, r3
 8000830:	6262      	str	r2, [r4, #36]	; 0x24
      tickstart = HAL_GetTick();
 8000832:	f7ff fd0d 	bl	8000250 <HAL_GetTick>
 8000836:	0007      	movs	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8000838:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800083a:	4233      	tst	r3, r6
 800083c:	d100      	bne.n	8000840 <HAL_RCC_OscConfig+0x1d8>
 800083e:	e721      	b.n	8000684 <HAL_RCC_OscConfig+0x1c>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8000840:	f7ff fd06 	bl	8000250 <HAL_GetTick>
 8000844:	1bc0      	subs	r0, r0, r7
 8000846:	2802      	cmp	r0, #2
 8000848:	d9f6      	bls.n	8000838 <HAL_RCC_OscConfig+0x1d0>
 800084a:	e76e      	b.n	800072a <HAL_RCC_OscConfig+0xc2>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800084c:	2280      	movs	r2, #128	; 0x80
    FlagStatus       pwrclkchanged = RESET;
 800084e:	2100      	movs	r1, #0
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000850:	4c46      	ldr	r4, [pc, #280]	; (800096c <HAL_RCC_OscConfig+0x304>)
 8000852:	0552      	lsls	r2, r2, #21
 8000854:	69e3      	ldr	r3, [r4, #28]
    FlagStatus       pwrclkchanged = RESET;
 8000856:	9100      	str	r1, [sp, #0]
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000858:	4213      	tst	r3, r2
 800085a:	d108      	bne.n	800086e <HAL_RCC_OscConfig+0x206>
      __HAL_RCC_PWR_CLK_ENABLE();
 800085c:	69e3      	ldr	r3, [r4, #28]
 800085e:	4313      	orrs	r3, r2
 8000860:	61e3      	str	r3, [r4, #28]
 8000862:	69e3      	ldr	r3, [r4, #28]
 8000864:	4013      	ands	r3, r2
 8000866:	9303      	str	r3, [sp, #12]
 8000868:	9b03      	ldr	r3, [sp, #12]
      pwrclkchanged = SET;
 800086a:	2301      	movs	r3, #1
 800086c:	9300      	str	r3, [sp, #0]
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800086e:	2780      	movs	r7, #128	; 0x80
 8000870:	4e41      	ldr	r6, [pc, #260]	; (8000978 <HAL_RCC_OscConfig+0x310>)
 8000872:	007f      	lsls	r7, r7, #1
 8000874:	6833      	ldr	r3, [r6, #0]
 8000876:	423b      	tst	r3, r7
 8000878:	d006      	beq.n	8000888 <HAL_RCC_OscConfig+0x220>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800087a:	68ab      	ldr	r3, [r5, #8]
 800087c:	2b01      	cmp	r3, #1
 800087e:	d113      	bne.n	80008a8 <HAL_RCC_OscConfig+0x240>
 8000880:	6a22      	ldr	r2, [r4, #32]
 8000882:	4313      	orrs	r3, r2
 8000884:	6223      	str	r3, [r4, #32]
 8000886:	e030      	b.n	80008ea <HAL_RCC_OscConfig+0x282>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8000888:	6833      	ldr	r3, [r6, #0]
 800088a:	433b      	orrs	r3, r7
 800088c:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 800088e:	f7ff fcdf 	bl	8000250 <HAL_GetTick>
 8000892:	9001      	str	r0, [sp, #4]
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000894:	6833      	ldr	r3, [r6, #0]
 8000896:	423b      	tst	r3, r7
 8000898:	d1ef      	bne.n	800087a <HAL_RCC_OscConfig+0x212>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800089a:	f7ff fcd9 	bl	8000250 <HAL_GetTick>
 800089e:	9b01      	ldr	r3, [sp, #4]
 80008a0:	1ac0      	subs	r0, r0, r3
 80008a2:	2864      	cmp	r0, #100	; 0x64
 80008a4:	d9f6      	bls.n	8000894 <HAL_RCC_OscConfig+0x22c>
 80008a6:	e740      	b.n	800072a <HAL_RCC_OscConfig+0xc2>
 80008a8:	2201      	movs	r2, #1
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80008aa:	2b00      	cmp	r3, #0
 80008ac:	d114      	bne.n	80008d8 <HAL_RCC_OscConfig+0x270>
 80008ae:	6a23      	ldr	r3, [r4, #32]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80008b0:	2702      	movs	r7, #2
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80008b2:	4393      	bics	r3, r2
 80008b4:	6223      	str	r3, [r4, #32]
 80008b6:	6a23      	ldr	r3, [r4, #32]
 80008b8:	3203      	adds	r2, #3
 80008ba:	4393      	bics	r3, r2
 80008bc:	6223      	str	r3, [r4, #32]
      tickstart = HAL_GetTick();
 80008be:	f7ff fcc7 	bl	8000250 <HAL_GetTick>
 80008c2:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80008c4:	6a23      	ldr	r3, [r4, #32]
 80008c6:	423b      	tst	r3, r7
 80008c8:	d025      	beq.n	8000916 <HAL_RCC_OscConfig+0x2ae>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80008ca:	f7ff fcc1 	bl	8000250 <HAL_GetTick>
 80008ce:	4b2b      	ldr	r3, [pc, #172]	; (800097c <HAL_RCC_OscConfig+0x314>)
 80008d0:	1b80      	subs	r0, r0, r6
 80008d2:	4298      	cmp	r0, r3
 80008d4:	d9f6      	bls.n	80008c4 <HAL_RCC_OscConfig+0x25c>
 80008d6:	e728      	b.n	800072a <HAL_RCC_OscConfig+0xc2>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80008d8:	2b05      	cmp	r3, #5
 80008da:	d10b      	bne.n	80008f4 <HAL_RCC_OscConfig+0x28c>
 80008dc:	6a21      	ldr	r1, [r4, #32]
 80008de:	3b01      	subs	r3, #1
 80008e0:	430b      	orrs	r3, r1
 80008e2:	6223      	str	r3, [r4, #32]
 80008e4:	6a23      	ldr	r3, [r4, #32]
 80008e6:	431a      	orrs	r2, r3
 80008e8:	6222      	str	r2, [r4, #32]
      tickstart = HAL_GetTick();
 80008ea:	f7ff fcb1 	bl	8000250 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80008ee:	2702      	movs	r7, #2
      tickstart = HAL_GetTick();
 80008f0:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80008f2:	e00d      	b.n	8000910 <HAL_RCC_OscConfig+0x2a8>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80008f4:	6a23      	ldr	r3, [r4, #32]
 80008f6:	4393      	bics	r3, r2
 80008f8:	2204      	movs	r2, #4
 80008fa:	6223      	str	r3, [r4, #32]
 80008fc:	6a23      	ldr	r3, [r4, #32]
 80008fe:	4393      	bics	r3, r2
 8000900:	e7c0      	b.n	8000884 <HAL_RCC_OscConfig+0x21c>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000902:	f7ff fca5 	bl	8000250 <HAL_GetTick>
 8000906:	4b1d      	ldr	r3, [pc, #116]	; (800097c <HAL_RCC_OscConfig+0x314>)
 8000908:	1b80      	subs	r0, r0, r6
 800090a:	4298      	cmp	r0, r3
 800090c:	d900      	bls.n	8000910 <HAL_RCC_OscConfig+0x2a8>
 800090e:	e70c      	b.n	800072a <HAL_RCC_OscConfig+0xc2>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000910:	6a23      	ldr	r3, [r4, #32]
 8000912:	423b      	tst	r3, r7
 8000914:	d0f5      	beq.n	8000902 <HAL_RCC_OscConfig+0x29a>
    if(pwrclkchanged == SET)
 8000916:	9b00      	ldr	r3, [sp, #0]
 8000918:	2b01      	cmp	r3, #1
 800091a:	d000      	beq.n	800091e <HAL_RCC_OscConfig+0x2b6>
 800091c:	e6b6      	b.n	800068c <HAL_RCC_OscConfig+0x24>
      __HAL_RCC_PWR_CLK_DISABLE();
 800091e:	69e3      	ldr	r3, [r4, #28]
 8000920:	4a17      	ldr	r2, [pc, #92]	; (8000980 <HAL_RCC_OscConfig+0x318>)
 8000922:	4013      	ands	r3, r2
 8000924:	61e3      	str	r3, [r4, #28]
 8000926:	e6b1      	b.n	800068c <HAL_RCC_OscConfig+0x24>
        if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 8000928:	f7ff fc92 	bl	8000250 <HAL_GetTick>
 800092c:	1bc0      	subs	r0, r0, r7
 800092e:	2802      	cmp	r0, #2
 8000930:	d800      	bhi.n	8000934 <HAL_RCC_OscConfig+0x2cc>
 8000932:	e6be      	b.n	80006b2 <HAL_RCC_OscConfig+0x4a>
 8000934:	e6f9      	b.n	800072a <HAL_RCC_OscConfig+0xc2>
    else if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ADC_CONTROL)
 8000936:	3205      	adds	r2, #5
 8000938:	d103      	bne.n	8000942 <HAL_RCC_OscConfig+0x2da>
      __HAL_RCC_HSI14ADC_ENABLE();
 800093a:	6b62      	ldr	r2, [r4, #52]	; 0x34
 800093c:	439a      	bics	r2, r3
 800093e:	6362      	str	r2, [r4, #52]	; 0x34
 8000940:	e6bb      	b.n	80006ba <HAL_RCC_OscConfig+0x52>
      __HAL_RCC_HSI14ADC_DISABLE();
 8000942:	6b62      	ldr	r2, [r4, #52]	; 0x34
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 8000944:	2602      	movs	r6, #2
      __HAL_RCC_HSI14ADC_DISABLE();
 8000946:	4313      	orrs	r3, r2
      __HAL_RCC_HSI14_DISABLE();
 8000948:	2201      	movs	r2, #1
      __HAL_RCC_HSI14ADC_DISABLE();
 800094a:	6363      	str	r3, [r4, #52]	; 0x34
      __HAL_RCC_HSI14_DISABLE();
 800094c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800094e:	4393      	bics	r3, r2
 8000950:	6363      	str	r3, [r4, #52]	; 0x34
      tickstart = HAL_GetTick();
 8000952:	f7ff fc7d 	bl	8000250 <HAL_GetTick>
 8000956:	0007      	movs	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 8000958:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800095a:	4233      	tst	r3, r6
 800095c:	d100      	bne.n	8000960 <HAL_RCC_OscConfig+0x2f8>
 800095e:	e6b3      	b.n	80006c8 <HAL_RCC_OscConfig+0x60>
        if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 8000960:	f7ff fc76 	bl	8000250 <HAL_GetTick>
 8000964:	1bc0      	subs	r0, r0, r7
 8000966:	2802      	cmp	r0, #2
 8000968:	d9f6      	bls.n	8000958 <HAL_RCC_OscConfig+0x2f0>
 800096a:	e6de      	b.n	800072a <HAL_RCC_OscConfig+0xc2>
 800096c:	40021000 	.word	0x40021000
 8000970:	fffeffff 	.word	0xfffeffff
 8000974:	fffbffff 	.word	0xfffbffff
 8000978:	40007000 	.word	0x40007000
 800097c:	00001388 	.word	0x00001388
 8000980:	efffffff 	.word	0xefffffff
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8000984:	220c      	movs	r2, #12
 8000986:	4c26      	ldr	r4, [pc, #152]	; (8000a20 <HAL_RCC_OscConfig+0x3b8>)
      return HAL_ERROR;
 8000988:	2001      	movs	r0, #1
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800098a:	6863      	ldr	r3, [r4, #4]
 800098c:	4013      	ands	r3, r2
 800098e:	2b08      	cmp	r3, #8
 8000990:	d100      	bne.n	8000994 <HAL_RCC_OscConfig+0x32c>
 8000992:	e6b3      	b.n	80006fc <HAL_RCC_OscConfig+0x94>
        __HAL_RCC_PLL_DISABLE();
 8000994:	6823      	ldr	r3, [r4, #0]
 8000996:	4a23      	ldr	r2, [pc, #140]	; (8000a24 <HAL_RCC_OscConfig+0x3bc>)
 8000998:	4013      	ands	r3, r2
 800099a:	6023      	str	r3, [r4, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800099c:	2902      	cmp	r1, #2
 800099e:	d12f      	bne.n	8000a00 <HAL_RCC_OscConfig+0x398>
        tickstart = HAL_GetTick();
 80009a0:	f7ff fc56 	bl	8000250 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80009a4:	2680      	movs	r6, #128	; 0x80
        tickstart = HAL_GetTick();
 80009a6:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80009a8:	04b6      	lsls	r6, r6, #18
 80009aa:	6823      	ldr	r3, [r4, #0]
 80009ac:	4233      	tst	r3, r6
 80009ae:	d121      	bne.n	80009f4 <HAL_RCC_OscConfig+0x38c>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80009b0:	220f      	movs	r2, #15
 80009b2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80009b4:	4393      	bics	r3, r2
 80009b6:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 80009b8:	4313      	orrs	r3, r2
 80009ba:	62e3      	str	r3, [r4, #44]	; 0x2c
 80009bc:	6a69      	ldr	r1, [r5, #36]	; 0x24
 80009be:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80009c0:	6862      	ldr	r2, [r4, #4]
 80009c2:	430b      	orrs	r3, r1
 80009c4:	4918      	ldr	r1, [pc, #96]	; (8000a28 <HAL_RCC_OscConfig+0x3c0>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 80009c6:	2580      	movs	r5, #128	; 0x80
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80009c8:	400a      	ands	r2, r1
 80009ca:	4313      	orrs	r3, r2
 80009cc:	6063      	str	r3, [r4, #4]
        __HAL_RCC_PLL_ENABLE();
 80009ce:	2380      	movs	r3, #128	; 0x80
 80009d0:	6822      	ldr	r2, [r4, #0]
 80009d2:	045b      	lsls	r3, r3, #17
 80009d4:	4313      	orrs	r3, r2
 80009d6:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 80009d8:	f7ff fc3a 	bl	8000250 <HAL_GetTick>
 80009dc:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 80009de:	04ad      	lsls	r5, r5, #18
 80009e0:	6823      	ldr	r3, [r4, #0]
 80009e2:	422b      	tst	r3, r5
 80009e4:	d000      	beq.n	80009e8 <HAL_RCC_OscConfig+0x380>
 80009e6:	e673      	b.n	80006d0 <HAL_RCC_OscConfig+0x68>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80009e8:	f7ff fc32 	bl	8000250 <HAL_GetTick>
 80009ec:	1b80      	subs	r0, r0, r6
 80009ee:	2802      	cmp	r0, #2
 80009f0:	d9f6      	bls.n	80009e0 <HAL_RCC_OscConfig+0x378>
 80009f2:	e69a      	b.n	800072a <HAL_RCC_OscConfig+0xc2>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80009f4:	f7ff fc2c 	bl	8000250 <HAL_GetTick>
 80009f8:	1bc0      	subs	r0, r0, r7
 80009fa:	2802      	cmp	r0, #2
 80009fc:	d9d5      	bls.n	80009aa <HAL_RCC_OscConfig+0x342>
 80009fe:	e694      	b.n	800072a <HAL_RCC_OscConfig+0xc2>
        tickstart = HAL_GetTick();
 8000a00:	f7ff fc26 	bl	8000250 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000a04:	2580      	movs	r5, #128	; 0x80
        tickstart = HAL_GetTick();
 8000a06:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000a08:	04ad      	lsls	r5, r5, #18
 8000a0a:	6823      	ldr	r3, [r4, #0]
 8000a0c:	422b      	tst	r3, r5
 8000a0e:	d100      	bne.n	8000a12 <HAL_RCC_OscConfig+0x3aa>
 8000a10:	e65e      	b.n	80006d0 <HAL_RCC_OscConfig+0x68>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000a12:	f7ff fc1d 	bl	8000250 <HAL_GetTick>
 8000a16:	1b80      	subs	r0, r0, r6
 8000a18:	2802      	cmp	r0, #2
 8000a1a:	d9f6      	bls.n	8000a0a <HAL_RCC_OscConfig+0x3a2>
 8000a1c:	e685      	b.n	800072a <HAL_RCC_OscConfig+0xc2>
 8000a1e:	46c0      	nop			; (mov r8, r8)
 8000a20:	40021000 	.word	0x40021000
 8000a24:	feffffff 	.word	0xfeffffff
 8000a28:	ffc2ffff 	.word	0xffc2ffff

08000a2c <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *         
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8000a2c:	b570      	push	{r4, r5, r6, lr}
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 8000a2e:	4c14      	ldr	r4, [pc, #80]	; (8000a80 <HAL_RCC_GetSysClockFreq+0x54>)
{
 8000a30:	b088      	sub	sp, #32
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 8000a32:	2210      	movs	r2, #16
 8000a34:	0021      	movs	r1, r4
 8000a36:	4668      	mov	r0, sp
 8000a38:	f002 fcb2 	bl	80033a0 <memcpy>
                                         10U, 11U, 12U, 13U, 14U, 15U, 16U, 16U};
  const uint8_t aPredivFactorTable[16] = { 1U, 2U,  3U,  4U,  5U,  6U,  7U,  8U,
 8000a3c:	0021      	movs	r1, r4
 8000a3e:	ad04      	add	r5, sp, #16
 8000a40:	2210      	movs	r2, #16
 8000a42:	3110      	adds	r1, #16
 8000a44:	0028      	movs	r0, r5
 8000a46:	f002 fcab 	bl	80033a0 <memcpy>
  uint32_t sysclockfreq = 0U;
  
  tmpreg = RCC->CFGR;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 8000a4a:	220c      	movs	r2, #12
  tmpreg = RCC->CFGR;
 8000a4c:	4e0d      	ldr	r6, [pc, #52]	; (8000a84 <HAL_RCC_GetSysClockFreq+0x58>)
 8000a4e:	6873      	ldr	r3, [r6, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 8000a50:	401a      	ands	r2, r3
 8000a52:	2a08      	cmp	r2, #8
 8000a54:	d111      	bne.n	8000a7a <HAL_RCC_GetSysClockFreq+0x4e>
      sysclockfreq = HSE_VALUE;
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 8000a56:	200f      	movs	r0, #15
 8000a58:	466a      	mov	r2, sp
 8000a5a:	0c99      	lsrs	r1, r3, #18
 8000a5c:	4001      	ands	r1, r0
 8000a5e:	5c54      	ldrb	r4, [r2, r1]
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 8000a60:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8000a62:	4002      	ands	r2, r0
 8000a64:	5ca9      	ldrb	r1, [r5, r2]
      if ((tmpreg & RCC_CFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
 8000a66:	03db      	lsls	r3, r3, #15
 8000a68:	d505      	bpl.n	8000a76 <HAL_RCC_GetSysClockFreq+0x4a>
      {
        /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV * PLLMUL */
        pllclk = (HSE_VALUE / prediv) * pllmul;
 8000a6a:	4807      	ldr	r0, [pc, #28]	; (8000a88 <HAL_RCC_GetSysClockFreq+0x5c>)
 8000a6c:	f7ff fb4c 	bl	8000108 <__udivsi3>
#if  (defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F070x6) || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC))
        /* HSI used as PLL clock source : PLLCLK = HSI/PREDIV * PLLMUL */
        pllclk = (HSI_VALUE / prediv) * pllmul;
#else
        /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
        pllclk = (uint32_t)((HSI_VALUE >> 1U) * pllmul);
 8000a70:	4360      	muls	r0, r4
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8000a72:	b008      	add	sp, #32
 8000a74:	bd70      	pop	{r4, r5, r6, pc}
        pllclk = (uint32_t)((HSI_VALUE >> 1U) * pllmul);
 8000a76:	4805      	ldr	r0, [pc, #20]	; (8000a8c <HAL_RCC_GetSysClockFreq+0x60>)
 8000a78:	e7fa      	b.n	8000a70 <HAL_RCC_GetSysClockFreq+0x44>
      sysclockfreq = HSE_VALUE;
 8000a7a:	4803      	ldr	r0, [pc, #12]	; (8000a88 <HAL_RCC_GetSysClockFreq+0x5c>)
  return sysclockfreq;
 8000a7c:	e7f9      	b.n	8000a72 <HAL_RCC_GetSysClockFreq+0x46>
 8000a7e:	46c0      	nop			; (mov r8, r8)
 8000a80:	08004240 	.word	0x08004240
 8000a84:	40021000 	.word	0x40021000
 8000a88:	007a1200 	.word	0x007a1200
 8000a8c:	003d0900 	.word	0x003d0900

08000a90 <HAL_RCC_ClockConfig>:
{
 8000a90:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8000a92:	2201      	movs	r2, #1
 8000a94:	4c43      	ldr	r4, [pc, #268]	; (8000ba4 <HAL_RCC_ClockConfig+0x114>)
{
 8000a96:	0006      	movs	r6, r0
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8000a98:	6823      	ldr	r3, [r4, #0]
{
 8000a9a:	000f      	movs	r7, r1
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8000a9c:	4013      	ands	r3, r2
 8000a9e:	428b      	cmp	r3, r1
 8000aa0:	d31c      	bcc.n	8000adc <HAL_RCC_ClockConfig+0x4c>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8000aa2:	6832      	ldr	r2, [r6, #0]
 8000aa4:	0793      	lsls	r3, r2, #30
 8000aa6:	d423      	bmi.n	8000af0 <HAL_RCC_ClockConfig+0x60>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8000aa8:	07d3      	lsls	r3, r2, #31
 8000aaa:	d429      	bmi.n	8000b00 <HAL_RCC_ClockConfig+0x70>
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 8000aac:	2301      	movs	r3, #1
 8000aae:	6822      	ldr	r2, [r4, #0]
 8000ab0:	401a      	ands	r2, r3
 8000ab2:	4297      	cmp	r7, r2
 8000ab4:	d367      	bcc.n	8000b86 <HAL_RCC_ClockConfig+0xf6>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8000ab6:	6833      	ldr	r3, [r6, #0]
 8000ab8:	4c3b      	ldr	r4, [pc, #236]	; (8000ba8 <HAL_RCC_ClockConfig+0x118>)
 8000aba:	075b      	lsls	r3, r3, #29
 8000abc:	d46a      	bmi.n	8000b94 <HAL_RCC_ClockConfig+0x104>
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
 8000abe:	f7ff ffb5 	bl	8000a2c <HAL_RCC_GetSysClockFreq>
 8000ac2:	6863      	ldr	r3, [r4, #4]
 8000ac4:	4a39      	ldr	r2, [pc, #228]	; (8000bac <HAL_RCC_ClockConfig+0x11c>)
 8000ac6:	061b      	lsls	r3, r3, #24
 8000ac8:	0f1b      	lsrs	r3, r3, #28
 8000aca:	5cd3      	ldrb	r3, [r2, r3]
 8000acc:	40d8      	lsrs	r0, r3
 8000ace:	4b38      	ldr	r3, [pc, #224]	; (8000bb0 <HAL_RCC_ClockConfig+0x120>)
 8000ad0:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 8000ad2:	2000      	movs	r0, #0
 8000ad4:	f002 fb02 	bl	80030dc <HAL_InitTick>
  return HAL_OK;
 8000ad8:	2000      	movs	r0, #0
 8000ada:	e008      	b.n	8000aee <HAL_RCC_ClockConfig+0x5e>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000adc:	6823      	ldr	r3, [r4, #0]
 8000ade:	4393      	bics	r3, r2
 8000ae0:	430b      	orrs	r3, r1
 8000ae2:	6023      	str	r3, [r4, #0]
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8000ae4:	6823      	ldr	r3, [r4, #0]
 8000ae6:	4013      	ands	r3, r2
 8000ae8:	4299      	cmp	r1, r3
 8000aea:	d0da      	beq.n	8000aa2 <HAL_RCC_ClockConfig+0x12>
      return HAL_ERROR;
 8000aec:	2001      	movs	r0, #1
}
 8000aee:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8000af0:	20f0      	movs	r0, #240	; 0xf0
 8000af2:	492d      	ldr	r1, [pc, #180]	; (8000ba8 <HAL_RCC_ClockConfig+0x118>)
 8000af4:	684b      	ldr	r3, [r1, #4]
 8000af6:	4383      	bics	r3, r0
 8000af8:	68b0      	ldr	r0, [r6, #8]
 8000afa:	4303      	orrs	r3, r0
 8000afc:	604b      	str	r3, [r1, #4]
 8000afe:	e7d3      	b.n	8000aa8 <HAL_RCC_ClockConfig+0x18>
 8000b00:	4d29      	ldr	r5, [pc, #164]	; (8000ba8 <HAL_RCC_ClockConfig+0x118>)
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000b02:	6872      	ldr	r2, [r6, #4]
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000b04:	682b      	ldr	r3, [r5, #0]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000b06:	2a01      	cmp	r2, #1
 8000b08:	d11a      	bne.n	8000b40 <HAL_RCC_ClockConfig+0xb0>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000b0a:	039b      	lsls	r3, r3, #14
 8000b0c:	d5ee      	bpl.n	8000aec <HAL_RCC_ClockConfig+0x5c>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8000b0e:	2103      	movs	r1, #3
 8000b10:	686b      	ldr	r3, [r5, #4]
 8000b12:	438b      	bics	r3, r1
 8000b14:	4313      	orrs	r3, r2
 8000b16:	606b      	str	r3, [r5, #4]
    tickstart = HAL_GetTick();
 8000b18:	f7ff fb9a 	bl	8000250 <HAL_GetTick>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000b1c:	6873      	ldr	r3, [r6, #4]
    tickstart = HAL_GetTick();
 8000b1e:	9001      	str	r0, [sp, #4]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000b20:	2b01      	cmp	r3, #1
 8000b22:	d115      	bne.n	8000b50 <HAL_RCC_ClockConfig+0xc0>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8000b24:	220c      	movs	r2, #12
 8000b26:	686b      	ldr	r3, [r5, #4]
 8000b28:	4013      	ands	r3, r2
 8000b2a:	2b04      	cmp	r3, #4
 8000b2c:	d0be      	beq.n	8000aac <HAL_RCC_ClockConfig+0x1c>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000b2e:	f7ff fb8f 	bl	8000250 <HAL_GetTick>
 8000b32:	9b01      	ldr	r3, [sp, #4]
 8000b34:	1ac0      	subs	r0, r0, r3
 8000b36:	4b1f      	ldr	r3, [pc, #124]	; (8000bb4 <HAL_RCC_ClockConfig+0x124>)
 8000b38:	4298      	cmp	r0, r3
 8000b3a:	d9f3      	bls.n	8000b24 <HAL_RCC_ClockConfig+0x94>
          return HAL_TIMEOUT;
 8000b3c:	2003      	movs	r0, #3
 8000b3e:	e7d6      	b.n	8000aee <HAL_RCC_ClockConfig+0x5e>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000b40:	2a02      	cmp	r2, #2
 8000b42:	d102      	bne.n	8000b4a <HAL_RCC_ClockConfig+0xba>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8000b44:	019b      	lsls	r3, r3, #6
 8000b46:	d4e2      	bmi.n	8000b0e <HAL_RCC_ClockConfig+0x7e>
 8000b48:	e7d0      	b.n	8000aec <HAL_RCC_ClockConfig+0x5c>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000b4a:	079b      	lsls	r3, r3, #30
 8000b4c:	d4df      	bmi.n	8000b0e <HAL_RCC_ClockConfig+0x7e>
 8000b4e:	e7cd      	b.n	8000aec <HAL_RCC_ClockConfig+0x5c>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000b50:	2b02      	cmp	r3, #2
 8000b52:	d012      	beq.n	8000b7a <HAL_RCC_ClockConfig+0xea>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8000b54:	220c      	movs	r2, #12
 8000b56:	686b      	ldr	r3, [r5, #4]
 8000b58:	4213      	tst	r3, r2
 8000b5a:	d0a7      	beq.n	8000aac <HAL_RCC_ClockConfig+0x1c>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000b5c:	f7ff fb78 	bl	8000250 <HAL_GetTick>
 8000b60:	9b01      	ldr	r3, [sp, #4]
 8000b62:	1ac0      	subs	r0, r0, r3
 8000b64:	4b13      	ldr	r3, [pc, #76]	; (8000bb4 <HAL_RCC_ClockConfig+0x124>)
 8000b66:	4298      	cmp	r0, r3
 8000b68:	d9f4      	bls.n	8000b54 <HAL_RCC_ClockConfig+0xc4>
 8000b6a:	e7e7      	b.n	8000b3c <HAL_RCC_ClockConfig+0xac>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000b6c:	f7ff fb70 	bl	8000250 <HAL_GetTick>
 8000b70:	9b01      	ldr	r3, [sp, #4]
 8000b72:	1ac0      	subs	r0, r0, r3
 8000b74:	4b0f      	ldr	r3, [pc, #60]	; (8000bb4 <HAL_RCC_ClockConfig+0x124>)
 8000b76:	4298      	cmp	r0, r3
 8000b78:	d8e0      	bhi.n	8000b3c <HAL_RCC_ClockConfig+0xac>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8000b7a:	220c      	movs	r2, #12
 8000b7c:	686b      	ldr	r3, [r5, #4]
 8000b7e:	4013      	ands	r3, r2
 8000b80:	2b08      	cmp	r3, #8
 8000b82:	d1f3      	bne.n	8000b6c <HAL_RCC_ClockConfig+0xdc>
 8000b84:	e792      	b.n	8000aac <HAL_RCC_ClockConfig+0x1c>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000b86:	6822      	ldr	r2, [r4, #0]
 8000b88:	439a      	bics	r2, r3
 8000b8a:	6022      	str	r2, [r4, #0]
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8000b8c:	6822      	ldr	r2, [r4, #0]
 8000b8e:	421a      	tst	r2, r3
 8000b90:	d1ac      	bne.n	8000aec <HAL_RCC_ClockConfig+0x5c>
 8000b92:	e790      	b.n	8000ab6 <HAL_RCC_ClockConfig+0x26>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_ClkInitStruct->APB1CLKDivider);
 8000b94:	6863      	ldr	r3, [r4, #4]
 8000b96:	4a08      	ldr	r2, [pc, #32]	; (8000bb8 <HAL_RCC_ClockConfig+0x128>)
 8000b98:	4013      	ands	r3, r2
 8000b9a:	68f2      	ldr	r2, [r6, #12]
 8000b9c:	4313      	orrs	r3, r2
 8000b9e:	6063      	str	r3, [r4, #4]
 8000ba0:	e78d      	b.n	8000abe <HAL_RCC_ClockConfig+0x2e>
 8000ba2:	46c0      	nop			; (mov r8, r8)
 8000ba4:	40022000 	.word	0x40022000
 8000ba8:	40021000 	.word	0x40021000
 8000bac:	080042cf 	.word	0x080042cf
 8000bb0:	20000004 	.word	0x20000004
 8000bb4:	00001388 	.word	0x00001388
 8000bb8:	fffff8ff 	.word	0xfffff8ff

08000bbc <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE) >> RCC_CFGR_PPRE_BITNUMBER]);
 8000bbc:	4b04      	ldr	r3, [pc, #16]	; (8000bd0 <HAL_RCC_GetPCLK1Freq+0x14>)
 8000bbe:	4a05      	ldr	r2, [pc, #20]	; (8000bd4 <HAL_RCC_GetPCLK1Freq+0x18>)
 8000bc0:	685b      	ldr	r3, [r3, #4]
 8000bc2:	055b      	lsls	r3, r3, #21
 8000bc4:	0f5b      	lsrs	r3, r3, #29
 8000bc6:	5cd3      	ldrb	r3, [r2, r3]
 8000bc8:	4a03      	ldr	r2, [pc, #12]	; (8000bd8 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8000bca:	6810      	ldr	r0, [r2, #0]
 8000bcc:	40d8      	lsrs	r0, r3
}    
 8000bce:	4770      	bx	lr
 8000bd0:	40021000 	.word	0x40021000
 8000bd4:	080042df 	.word	0x080042df
 8000bd8:	20000004 	.word	0x20000004

08000bdc <HAL_RCC_GetClockConfig>:
  /* Check the parameters */
  assert_param(RCC_ClkInitStruct != NULL);
  assert_param(pFLatency != NULL);

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1;
 8000bdc:	2307      	movs	r3, #7
{
 8000bde:	b510      	push	{r4, lr}
  
  /* Get the SYSCLK configuration --------------------------------------------*/ 
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8000be0:	2403      	movs	r4, #3
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1;
 8000be2:	6003      	str	r3, [r0, #0]
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8000be4:	4b09      	ldr	r3, [pc, #36]	; (8000c0c <HAL_RCC_GetClockConfig+0x30>)
 8000be6:	685a      	ldr	r2, [r3, #4]
 8000be8:	4022      	ands	r2, r4
 8000bea:	6042      	str	r2, [r0, #4]
  
  /* Get the HCLK configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
 8000bec:	685a      	ldr	r2, [r3, #4]
 8000bee:	34ed      	adds	r4, #237	; 0xed
 8000bf0:	4022      	ands	r2, r4
 8000bf2:	6082      	str	r2, [r0, #8]
  
  /* Get the APB1 configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE);   
 8000bf4:	22e0      	movs	r2, #224	; 0xe0
 8000bf6:	685b      	ldr	r3, [r3, #4]
 8000bf8:	00d2      	lsls	r2, r2, #3
 8000bfa:	4013      	ands	r3, r2
  /* Get the Flash Wait State (Latency) configuration ------------------------*/   
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
 8000bfc:	2201      	movs	r2, #1
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE);   
 8000bfe:	60c3      	str	r3, [r0, #12]
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
 8000c00:	4b03      	ldr	r3, [pc, #12]	; (8000c10 <HAL_RCC_GetClockConfig+0x34>)
 8000c02:	681b      	ldr	r3, [r3, #0]
 8000c04:	4013      	ands	r3, r2
 8000c06:	600b      	str	r3, [r1, #0]
}
 8000c08:	bd10      	pop	{r4, pc}
 8000c0a:	46c0      	nop			; (mov r8, r8)
 8000c0c:	40021000 	.word	0x40021000
 8000c10:	40022000 	.word	0x40022000

08000c14 <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) and RCC_BDCR register are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8000c14:	b5f0      	push	{r4, r5, r6, r7, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
  
  /*---------------------------- RTC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8000c16:	6803      	ldr	r3, [r0, #0]
{
 8000c18:	b085      	sub	sp, #20
 8000c1a:	0005      	movs	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8000c1c:	03db      	lsls	r3, r3, #15
 8000c1e:	d528      	bpl.n	8000c72 <HAL_RCCEx_PeriphCLKConfig+0x5e>
    FlagStatus       pwrclkchanged = RESET;

    /* As soon as function is called to change RTC clock source, activation of the 
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000c20:	2280      	movs	r2, #128	; 0x80
    FlagStatus       pwrclkchanged = RESET;
 8000c22:	2100      	movs	r1, #0
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000c24:	4c37      	ldr	r4, [pc, #220]	; (8000d04 <HAL_RCCEx_PeriphCLKConfig+0xf0>)
 8000c26:	0552      	lsls	r2, r2, #21
 8000c28:	69e3      	ldr	r3, [r4, #28]
    FlagStatus       pwrclkchanged = RESET;
 8000c2a:	9100      	str	r1, [sp, #0]
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000c2c:	4213      	tst	r3, r2
 8000c2e:	d108      	bne.n	8000c42 <HAL_RCCEx_PeriphCLKConfig+0x2e>
    {
    __HAL_RCC_PWR_CLK_ENABLE();
 8000c30:	69e3      	ldr	r3, [r4, #28]
 8000c32:	4313      	orrs	r3, r2
 8000c34:	61e3      	str	r3, [r4, #28]
 8000c36:	69e3      	ldr	r3, [r4, #28]
 8000c38:	4013      	ands	r3, r2
 8000c3a:	9303      	str	r3, [sp, #12]
 8000c3c:	9b03      	ldr	r3, [sp, #12]
      pwrclkchanged = SET;
 8000c3e:	2301      	movs	r3, #1
 8000c40:	9300      	str	r3, [sp, #0]
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000c42:	2780      	movs	r7, #128	; 0x80
 8000c44:	4e30      	ldr	r6, [pc, #192]	; (8000d08 <HAL_RCCEx_PeriphCLKConfig+0xf4>)
 8000c46:	007f      	lsls	r7, r7, #1
 8000c48:	6833      	ldr	r3, [r6, #0]
 8000c4a:	423b      	tst	r3, r7
 8000c4c:	d026      	beq.n	8000c9c <HAL_RCCEx_PeriphCLKConfig+0x88>
        }
      }
    }
    
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
    temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8000c4e:	22c0      	movs	r2, #192	; 0xc0
 8000c50:	6a23      	ldr	r3, [r4, #32]
 8000c52:	0092      	lsls	r2, r2, #2
 8000c54:	4013      	ands	r3, r2
 8000c56:	4e2d      	ldr	r6, [pc, #180]	; (8000d0c <HAL_RCCEx_PeriphCLKConfig+0xf8>)
    if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8000c58:	d132      	bne.n	8000cc0 <HAL_RCCEx_PeriphCLKConfig+0xac>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8000c5a:	6a23      	ldr	r3, [r4, #32]
 8000c5c:	401e      	ands	r6, r3
 8000c5e:	686b      	ldr	r3, [r5, #4]
 8000c60:	431e      	orrs	r6, r3

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 8000c62:	9b00      	ldr	r3, [sp, #0]
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8000c64:	6226      	str	r6, [r4, #32]
    if(pwrclkchanged == SET)
 8000c66:	2b01      	cmp	r3, #1
 8000c68:	d103      	bne.n	8000c72 <HAL_RCCEx_PeriphCLKConfig+0x5e>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8000c6a:	69e3      	ldr	r3, [r4, #28]
 8000c6c:	4a28      	ldr	r2, [pc, #160]	; (8000d10 <HAL_RCCEx_PeriphCLKConfig+0xfc>)
 8000c6e:	4013      	ands	r3, r2
 8000c70:	61e3      	str	r3, [r4, #28]
    }
  }

  /*------------------------------- USART1 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8000c72:	682a      	ldr	r2, [r5, #0]
 8000c74:	07d3      	lsls	r3, r2, #31
 8000c76:	d506      	bpl.n	8000c86 <HAL_RCCEx_PeriphCLKConfig+0x72>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
    
    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8000c78:	2003      	movs	r0, #3
 8000c7a:	4922      	ldr	r1, [pc, #136]	; (8000d04 <HAL_RCCEx_PeriphCLKConfig+0xf0>)
 8000c7c:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8000c7e:	4383      	bics	r3, r0
 8000c80:	68a8      	ldr	r0, [r5, #8]
 8000c82:	4303      	orrs	r3, r0
 8000c84:	630b      	str	r3, [r1, #48]	; 0x30
#endif /* STM32F042x6 || STM32F048xx ||                */
       /* STM32F051x8 || STM32F058xx ||                */
       /* STM32F071xB || STM32F072xB || STM32F078xx || */
       /* STM32F091xC || STM32F098xx */
  
  return HAL_OK;
 8000c86:	2000      	movs	r0, #0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8000c88:	0693      	lsls	r3, r2, #26
 8000c8a:	d517      	bpl.n	8000cbc <HAL_RCCEx_PeriphCLKConfig+0xa8>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8000c8c:	2110      	movs	r1, #16
 8000c8e:	4a1d      	ldr	r2, [pc, #116]	; (8000d04 <HAL_RCCEx_PeriphCLKConfig+0xf0>)
 8000c90:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8000c92:	438b      	bics	r3, r1
 8000c94:	68e9      	ldr	r1, [r5, #12]
 8000c96:	430b      	orrs	r3, r1
 8000c98:	6313      	str	r3, [r2, #48]	; 0x30
 8000c9a:	e00f      	b.n	8000cbc <HAL_RCCEx_PeriphCLKConfig+0xa8>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8000c9c:	6833      	ldr	r3, [r6, #0]
 8000c9e:	433b      	orrs	r3, r7
 8000ca0:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 8000ca2:	f7ff fad5 	bl	8000250 <HAL_GetTick>
 8000ca6:	9001      	str	r0, [sp, #4]
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000ca8:	6833      	ldr	r3, [r6, #0]
 8000caa:	423b      	tst	r3, r7
 8000cac:	d1cf      	bne.n	8000c4e <HAL_RCCEx_PeriphCLKConfig+0x3a>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8000cae:	f7ff facf 	bl	8000250 <HAL_GetTick>
 8000cb2:	9b01      	ldr	r3, [sp, #4]
 8000cb4:	1ac0      	subs	r0, r0, r3
 8000cb6:	2864      	cmp	r0, #100	; 0x64
 8000cb8:	d9f6      	bls.n	8000ca8 <HAL_RCCEx_PeriphCLKConfig+0x94>
          return HAL_TIMEOUT;
 8000cba:	2003      	movs	r0, #3
}
 8000cbc:	b005      	add	sp, #20
 8000cbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8000cc0:	6869      	ldr	r1, [r5, #4]
 8000cc2:	400a      	ands	r2, r1
 8000cc4:	4293      	cmp	r3, r2
 8000cc6:	d0c8      	beq.n	8000c5a <HAL_RCCEx_PeriphCLKConfig+0x46>
      __HAL_RCC_BACKUPRESET_FORCE();
 8000cc8:	2380      	movs	r3, #128	; 0x80
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8000cca:	6a22      	ldr	r2, [r4, #32]
      __HAL_RCC_BACKUPRESET_FORCE();
 8000ccc:	6a20      	ldr	r0, [r4, #32]
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8000cce:	0011      	movs	r1, r2
      __HAL_RCC_BACKUPRESET_FORCE();
 8000cd0:	025b      	lsls	r3, r3, #9
 8000cd2:	4303      	orrs	r3, r0
 8000cd4:	6223      	str	r3, [r4, #32]
      __HAL_RCC_BACKUPRESET_RELEASE();
 8000cd6:	6a23      	ldr	r3, [r4, #32]
 8000cd8:	480e      	ldr	r0, [pc, #56]	; (8000d14 <HAL_RCCEx_PeriphCLKConfig+0x100>)
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8000cda:	4031      	ands	r1, r6
      __HAL_RCC_BACKUPRESET_RELEASE();
 8000cdc:	4003      	ands	r3, r0
 8000cde:	6223      	str	r3, [r4, #32]
      RCC->BDCR = temp_reg;
 8000ce0:	6221      	str	r1, [r4, #32]
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
 8000ce2:	07d3      	lsls	r3, r2, #31
 8000ce4:	d5b9      	bpl.n	8000c5a <HAL_RCCEx_PeriphCLKConfig+0x46>
        tickstart = HAL_GetTick();
 8000ce6:	f7ff fab3 	bl	8000250 <HAL_GetTick>
 8000cea:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000cec:	2202      	movs	r2, #2
 8000cee:	6a23      	ldr	r3, [r4, #32]
 8000cf0:	4213      	tst	r3, r2
 8000cf2:	d1b2      	bne.n	8000c5a <HAL_RCCEx_PeriphCLKConfig+0x46>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8000cf4:	f7ff faac 	bl	8000250 <HAL_GetTick>
 8000cf8:	4b07      	ldr	r3, [pc, #28]	; (8000d18 <HAL_RCCEx_PeriphCLKConfig+0x104>)
 8000cfa:	1bc0      	subs	r0, r0, r7
 8000cfc:	4298      	cmp	r0, r3
 8000cfe:	d9f5      	bls.n	8000cec <HAL_RCCEx_PeriphCLKConfig+0xd8>
 8000d00:	e7db      	b.n	8000cba <HAL_RCCEx_PeriphCLKConfig+0xa6>
 8000d02:	46c0      	nop			; (mov r8, r8)
 8000d04:	40021000 	.word	0x40021000
 8000d08:	40007000 	.word	0x40007000
 8000d0c:	fffffcff 	.word	0xfffffcff
 8000d10:	efffffff 	.word	0xefffffff
 8000d14:	fffeffff 	.word	0xfffeffff
 8000d18:	00001388 	.word	0x00001388

08000d1c <HAL_TIM_Base_MspInit>:
 8000d1c:	4770      	bx	lr

08000d1e <HAL_TIM_Base_Start_IT>:
{
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

   /* Enable the TIM Update interrupt */
   __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8000d1e:	2201      	movs	r2, #1
 8000d20:	6803      	ldr	r3, [r0, #0]
 8000d22:	68d9      	ldr	r1, [r3, #12]
   /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);

  /* Return function status */
  return HAL_OK;
}
 8000d24:	2000      	movs	r0, #0
   __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8000d26:	4311      	orrs	r1, r2
 8000d28:	60d9      	str	r1, [r3, #12]
  __HAL_TIM_ENABLE(htim);
 8000d2a:	6819      	ldr	r1, [r3, #0]
 8000d2c:	430a      	orrs	r2, r1
 8000d2e:	601a      	str	r2, [r3, #0]
}
 8000d30:	4770      	bx	lr

08000d32 <HAL_TIM_OC_DelayElapsedCallback>:
 8000d32:	4770      	bx	lr

08000d34 <HAL_TIM_IC_CaptureCallback>:
 8000d34:	4770      	bx	lr

08000d36 <HAL_TIM_PWM_PulseFinishedCallback>:
 8000d36:	4770      	bx	lr

08000d38 <HAL_TIM_TriggerCallback>:
 8000d38:	4770      	bx	lr

08000d3a <HAL_TIM_IRQHandler>:
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
  /* Capture compare 1 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8000d3a:	2202      	movs	r2, #2
 8000d3c:	6803      	ldr	r3, [r0, #0]
{
 8000d3e:	b510      	push	{r4, lr}
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8000d40:	6919      	ldr	r1, [r3, #16]
{
 8000d42:	0004      	movs	r4, r0
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8000d44:	4211      	tst	r1, r2
 8000d46:	d00e      	beq.n	8000d66 <HAL_TIM_IRQHandler+0x2c>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
 8000d48:	68d9      	ldr	r1, [r3, #12]
 8000d4a:	4211      	tst	r1, r2
 8000d4c:	d00b      	beq.n	8000d66 <HAL_TIM_IRQHandler+0x2c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8000d4e:	3a05      	subs	r2, #5
 8000d50:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;

        /* Input capture event */
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8000d52:	699b      	ldr	r3, [r3, #24]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8000d54:	3204      	adds	r2, #4
 8000d56:	7702      	strb	r2, [r0, #28]
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8000d58:	079b      	lsls	r3, r3, #30
 8000d5a:	d100      	bne.n	8000d5e <HAL_TIM_IRQHandler+0x24>
 8000d5c:	e079      	b.n	8000e52 <HAL_TIM_IRQHandler+0x118>
        {
          HAL_TIM_IC_CaptureCallback(htim);
 8000d5e:	f7ff ffe9 	bl	8000d34 <HAL_TIM_IC_CaptureCallback>
        else
        {
          HAL_TIM_OC_DelayElapsedCallback(htim);
          HAL_TIM_PWM_PulseFinishedCallback(htim);
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8000d62:	2300      	movs	r3, #0
 8000d64:	7723      	strb	r3, [r4, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8000d66:	2204      	movs	r2, #4
 8000d68:	6823      	ldr	r3, [r4, #0]
 8000d6a:	6919      	ldr	r1, [r3, #16]
 8000d6c:	4211      	tst	r1, r2
 8000d6e:	d010      	beq.n	8000d92 <HAL_TIM_IRQHandler+0x58>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
 8000d70:	68d9      	ldr	r1, [r3, #12]
 8000d72:	4211      	tst	r1, r2
 8000d74:	d00d      	beq.n	8000d92 <HAL_TIM_IRQHandler+0x58>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8000d76:	3a09      	subs	r2, #9
 8000d78:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8000d7a:	3207      	adds	r2, #7
 8000d7c:	7722      	strb	r2, [r4, #28]
      /* Input capture event */
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8000d7e:	699a      	ldr	r2, [r3, #24]
 8000d80:	23c0      	movs	r3, #192	; 0xc0
 8000d82:	009b      	lsls	r3, r3, #2
      {
        HAL_TIM_IC_CaptureCallback(htim);
 8000d84:	0020      	movs	r0, r4
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8000d86:	421a      	tst	r2, r3
 8000d88:	d069      	beq.n	8000e5e <HAL_TIM_IRQHandler+0x124>
        HAL_TIM_IC_CaptureCallback(htim);
 8000d8a:	f7ff ffd3 	bl	8000d34 <HAL_TIM_IC_CaptureCallback>
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8000d8e:	2300      	movs	r3, #0
 8000d90:	7723      	strb	r3, [r4, #28]
    }
  }
  /* Capture compare 3 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8000d92:	2208      	movs	r2, #8
 8000d94:	6823      	ldr	r3, [r4, #0]
 8000d96:	6919      	ldr	r1, [r3, #16]
 8000d98:	4211      	tst	r1, r2
 8000d9a:	d00e      	beq.n	8000dba <HAL_TIM_IRQHandler+0x80>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
 8000d9c:	68d9      	ldr	r1, [r3, #12]
 8000d9e:	4211      	tst	r1, r2
 8000da0:	d00b      	beq.n	8000dba <HAL_TIM_IRQHandler+0x80>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8000da2:	3a11      	subs	r2, #17
 8000da4:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8000da6:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8000da8:	320d      	adds	r2, #13
 8000daa:	7722      	strb	r2, [r4, #28]
      {
        HAL_TIM_IC_CaptureCallback(htim);
 8000dac:	0020      	movs	r0, r4
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8000dae:	079b      	lsls	r3, r3, #30
 8000db0:	d05b      	beq.n	8000e6a <HAL_TIM_IRQHandler+0x130>
        HAL_TIM_IC_CaptureCallback(htim);
 8000db2:	f7ff ffbf 	bl	8000d34 <HAL_TIM_IC_CaptureCallback>
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8000db6:	2300      	movs	r3, #0
 8000db8:	7723      	strb	r3, [r4, #28]
    }
  }
  /* Capture compare 4 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8000dba:	2210      	movs	r2, #16
 8000dbc:	6823      	ldr	r3, [r4, #0]
 8000dbe:	6919      	ldr	r1, [r3, #16]
 8000dc0:	4211      	tst	r1, r2
 8000dc2:	d010      	beq.n	8000de6 <HAL_TIM_IRQHandler+0xac>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
 8000dc4:	68d9      	ldr	r1, [r3, #12]
 8000dc6:	4211      	tst	r1, r2
 8000dc8:	d00d      	beq.n	8000de6 <HAL_TIM_IRQHandler+0xac>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8000dca:	3a21      	subs	r2, #33	; 0x21
 8000dcc:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8000dce:	3219      	adds	r2, #25
 8000dd0:	7722      	strb	r2, [r4, #28]
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8000dd2:	69da      	ldr	r2, [r3, #28]
 8000dd4:	23c0      	movs	r3, #192	; 0xc0
 8000dd6:	009b      	lsls	r3, r3, #2
      {
        HAL_TIM_IC_CaptureCallback(htim);
 8000dd8:	0020      	movs	r0, r4
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8000dda:	421a      	tst	r2, r3
 8000ddc:	d04b      	beq.n	8000e76 <HAL_TIM_IRQHandler+0x13c>
        HAL_TIM_IC_CaptureCallback(htim);
 8000dde:	f7ff ffa9 	bl	8000d34 <HAL_TIM_IC_CaptureCallback>
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8000de2:	2300      	movs	r3, #0
 8000de4:	7723      	strb	r3, [r4, #28]
    }
  }
  /* TIM Update event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8000de6:	2201      	movs	r2, #1
 8000de8:	6823      	ldr	r3, [r4, #0]
 8000dea:	6919      	ldr	r1, [r3, #16]
 8000dec:	4211      	tst	r1, r2
 8000dee:	d007      	beq.n	8000e00 <HAL_TIM_IRQHandler+0xc6>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
 8000df0:	68d9      	ldr	r1, [r3, #12]
 8000df2:	4211      	tst	r1, r2
 8000df4:	d004      	beq.n	8000e00 <HAL_TIM_IRQHandler+0xc6>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8000df6:	3a03      	subs	r2, #3
 8000df8:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8000dfa:	0020      	movs	r0, r4
 8000dfc:	f002 f8be 	bl	8002f7c <HAL_TIM_PeriodElapsedCallback>
    }
  }
  /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8000e00:	2280      	movs	r2, #128	; 0x80
 8000e02:	6823      	ldr	r3, [r4, #0]
 8000e04:	6919      	ldr	r1, [r3, #16]
 8000e06:	4211      	tst	r1, r2
 8000e08:	d008      	beq.n	8000e1c <HAL_TIM_IRQHandler+0xe2>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 8000e0a:	68d9      	ldr	r1, [r3, #12]
 8000e0c:	4211      	tst	r1, r2
 8000e0e:	d005      	beq.n	8000e1c <HAL_TIM_IRQHandler+0xe2>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8000e10:	3a02      	subs	r2, #2
 8000e12:	3aff      	subs	r2, #255	; 0xff
 8000e14:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8000e16:	0020      	movs	r0, r4
 8000e18:	f000 f898 	bl	8000f4c <HAL_TIMEx_BreakCallback>
    }
  }
  /* TIM Trigger detection event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8000e1c:	2240      	movs	r2, #64	; 0x40
 8000e1e:	6823      	ldr	r3, [r4, #0]
 8000e20:	6919      	ldr	r1, [r3, #16]
 8000e22:	4211      	tst	r1, r2
 8000e24:	d007      	beq.n	8000e36 <HAL_TIM_IRQHandler+0xfc>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
 8000e26:	68d9      	ldr	r1, [r3, #12]
 8000e28:	4211      	tst	r1, r2
 8000e2a:	d004      	beq.n	8000e36 <HAL_TIM_IRQHandler+0xfc>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8000e2c:	3a81      	subs	r2, #129	; 0x81
 8000e2e:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8000e30:	0020      	movs	r0, r4
 8000e32:	f7ff ff81 	bl	8000d38 <HAL_TIM_TriggerCallback>
    }
  }
  /* TIM commutation event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8000e36:	2220      	movs	r2, #32
 8000e38:	6823      	ldr	r3, [r4, #0]
 8000e3a:	6919      	ldr	r1, [r3, #16]
 8000e3c:	4211      	tst	r1, r2
 8000e3e:	d007      	beq.n	8000e50 <HAL_TIM_IRQHandler+0x116>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
 8000e40:	68d9      	ldr	r1, [r3, #12]
 8000e42:	4211      	tst	r1, r2
 8000e44:	d004      	beq.n	8000e50 <HAL_TIM_IRQHandler+0x116>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8000e46:	3a41      	subs	r2, #65	; 0x41
 8000e48:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutationCallback(htim);
 8000e4a:	0020      	movs	r0, r4
 8000e4c:	f000 f87d 	bl	8000f4a <HAL_TIMEx_CommutationCallback>
    }
  }
}
 8000e50:	bd10      	pop	{r4, pc}
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8000e52:	f7ff ff6e 	bl	8000d32 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8000e56:	0020      	movs	r0, r4
 8000e58:	f7ff ff6d 	bl	8000d36 <HAL_TIM_PWM_PulseFinishedCallback>
 8000e5c:	e781      	b.n	8000d62 <HAL_TIM_IRQHandler+0x28>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8000e5e:	f7ff ff68 	bl	8000d32 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8000e62:	0020      	movs	r0, r4
 8000e64:	f7ff ff67 	bl	8000d36 <HAL_TIM_PWM_PulseFinishedCallback>
 8000e68:	e791      	b.n	8000d8e <HAL_TIM_IRQHandler+0x54>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8000e6a:	f7ff ff62 	bl	8000d32 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8000e6e:	0020      	movs	r0, r4
 8000e70:	f7ff ff61 	bl	8000d36 <HAL_TIM_PWM_PulseFinishedCallback>
 8000e74:	e79f      	b.n	8000db6 <HAL_TIM_IRQHandler+0x7c>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8000e76:	f7ff ff5c 	bl	8000d32 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8000e7a:	0020      	movs	r0, r4
 8000e7c:	f7ff ff5b 	bl	8000d36 <HAL_TIM_PWM_PulseFinishedCallback>
 8000e80:	e7af      	b.n	8000de2 <HAL_TIM_IRQHandler+0xa8>
	...

08000e84 <TIM_Base_SetConfig>:
{
  uint32_t tmpcr1 = 0U;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8000e84:	4a1c      	ldr	r2, [pc, #112]	; (8000ef8 <TIM_Base_SetConfig+0x74>)
{
 8000e86:	b510      	push	{r4, lr}
  tmpcr1 = TIMx->CR1;
 8000e88:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8000e8a:	4290      	cmp	r0, r2
 8000e8c:	d002      	beq.n	8000e94 <TIM_Base_SetConfig+0x10>
 8000e8e:	4c1b      	ldr	r4, [pc, #108]	; (8000efc <TIM_Base_SetConfig+0x78>)
 8000e90:	42a0      	cmp	r0, r4
 8000e92:	d108      	bne.n	8000ea6 <TIM_Base_SetConfig+0x22>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8000e94:	2470      	movs	r4, #112	; 0x70
 8000e96:	43a3      	bics	r3, r4
    tmpcr1 |= Structure->CounterMode;
 8000e98:	684c      	ldr	r4, [r1, #4]
 8000e9a:	4323      	orrs	r3, r4
  }

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8000e9c:	4290      	cmp	r0, r2
 8000e9e:	d00e      	beq.n	8000ebe <TIM_Base_SetConfig+0x3a>
 8000ea0:	4c16      	ldr	r4, [pc, #88]	; (8000efc <TIM_Base_SetConfig+0x78>)
 8000ea2:	42a0      	cmp	r0, r4
 8000ea4:	d00b      	beq.n	8000ebe <TIM_Base_SetConfig+0x3a>
 8000ea6:	4c16      	ldr	r4, [pc, #88]	; (8000f00 <TIM_Base_SetConfig+0x7c>)
 8000ea8:	42a0      	cmp	r0, r4
 8000eaa:	d008      	beq.n	8000ebe <TIM_Base_SetConfig+0x3a>
 8000eac:	4c15      	ldr	r4, [pc, #84]	; (8000f04 <TIM_Base_SetConfig+0x80>)
 8000eae:	42a0      	cmp	r0, r4
 8000eb0:	d005      	beq.n	8000ebe <TIM_Base_SetConfig+0x3a>
 8000eb2:	4c15      	ldr	r4, [pc, #84]	; (8000f08 <TIM_Base_SetConfig+0x84>)
 8000eb4:	42a0      	cmp	r0, r4
 8000eb6:	d002      	beq.n	8000ebe <TIM_Base_SetConfig+0x3a>
 8000eb8:	4c14      	ldr	r4, [pc, #80]	; (8000f0c <TIM_Base_SetConfig+0x88>)
 8000eba:	42a0      	cmp	r0, r4
 8000ebc:	d103      	bne.n	8000ec6 <TIM_Base_SetConfig+0x42>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8000ebe:	4c14      	ldr	r4, [pc, #80]	; (8000f10 <TIM_Base_SetConfig+0x8c>)
 8000ec0:	4023      	ands	r3, r4
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8000ec2:	68cc      	ldr	r4, [r1, #12]
 8000ec4:	4323      	orrs	r3, r4
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8000ec6:	2480      	movs	r4, #128	; 0x80
 8000ec8:	43a3      	bics	r3, r4
 8000eca:	694c      	ldr	r4, [r1, #20]
 8000ecc:	4323      	orrs	r3, r4

  TIMx->CR1 = tmpcr1;
 8000ece:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8000ed0:	688b      	ldr	r3, [r1, #8]
 8000ed2:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8000ed4:	680b      	ldr	r3, [r1, #0]
 8000ed6:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8000ed8:	4290      	cmp	r0, r2
 8000eda:	d008      	beq.n	8000eee <TIM_Base_SetConfig+0x6a>
 8000edc:	4b09      	ldr	r3, [pc, #36]	; (8000f04 <TIM_Base_SetConfig+0x80>)
 8000ede:	4298      	cmp	r0, r3
 8000ee0:	d005      	beq.n	8000eee <TIM_Base_SetConfig+0x6a>
 8000ee2:	4b09      	ldr	r3, [pc, #36]	; (8000f08 <TIM_Base_SetConfig+0x84>)
 8000ee4:	4298      	cmp	r0, r3
 8000ee6:	d002      	beq.n	8000eee <TIM_Base_SetConfig+0x6a>
 8000ee8:	4b08      	ldr	r3, [pc, #32]	; (8000f0c <TIM_Base_SetConfig+0x88>)
 8000eea:	4298      	cmp	r0, r3
 8000eec:	d101      	bne.n	8000ef2 <TIM_Base_SetConfig+0x6e>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8000eee:	690b      	ldr	r3, [r1, #16]
 8000ef0:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_EGR_UG;
 8000ef2:	2301      	movs	r3, #1
 8000ef4:	6143      	str	r3, [r0, #20]
}
 8000ef6:	bd10      	pop	{r4, pc}
 8000ef8:	40012c00 	.word	0x40012c00
 8000efc:	40000400 	.word	0x40000400
 8000f00:	40002000 	.word	0x40002000
 8000f04:	40014000 	.word	0x40014000
 8000f08:	40014400 	.word	0x40014400
 8000f0c:	40014800 	.word	0x40014800
 8000f10:	fffffcff 	.word	0xfffffcff

08000f14 <HAL_TIM_Base_Init>:
{
 8000f14:	b570      	push	{r4, r5, r6, lr}
 8000f16:	0004      	movs	r4, r0
    return HAL_ERROR;
 8000f18:	2001      	movs	r0, #1
  if(htim == NULL)
 8000f1a:	2c00      	cmp	r4, #0
 8000f1c:	d014      	beq.n	8000f48 <HAL_TIM_Base_Init+0x34>
  if(htim->State == HAL_TIM_STATE_RESET)
 8000f1e:	0025      	movs	r5, r4
 8000f20:	353d      	adds	r5, #61	; 0x3d
 8000f22:	782b      	ldrb	r3, [r5, #0]
 8000f24:	b2db      	uxtb	r3, r3
 8000f26:	2b00      	cmp	r3, #0
 8000f28:	d105      	bne.n	8000f36 <HAL_TIM_Base_Init+0x22>
    htim->Lock = HAL_UNLOCKED;
 8000f2a:	0022      	movs	r2, r4
 8000f2c:	323c      	adds	r2, #60	; 0x3c
 8000f2e:	7013      	strb	r3, [r2, #0]
    HAL_TIM_Base_MspInit(htim);
 8000f30:	0020      	movs	r0, r4
 8000f32:	f7ff fef3 	bl	8000d1c <HAL_TIM_Base_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;
 8000f36:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8000f38:	6820      	ldr	r0, [r4, #0]
  htim->State= HAL_TIM_STATE_BUSY;
 8000f3a:	702b      	strb	r3, [r5, #0]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8000f3c:	1d21      	adds	r1, r4, #4
 8000f3e:	f7ff ffa1 	bl	8000e84 <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 8000f42:	2301      	movs	r3, #1
  return HAL_OK;
 8000f44:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
 8000f46:	702b      	strb	r3, [r5, #0]
}
 8000f48:	bd70      	pop	{r4, r5, r6, pc}

08000f4a <HAL_TIMEx_CommutationCallback>:
 8000f4a:	4770      	bx	lr

08000f4c <HAL_TIMEx_BreakCallback>:
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 8000f4c:	4770      	bx	lr

08000f4e <LL_GPIO_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: GPIO registers are initialized according to GPIO_InitStruct content
  *          - ERROR:   Not applicable
  */
ErrorStatus LL_GPIO_Init(GPIO_TypeDef *GPIOx, LL_GPIO_InitTypeDef *GPIO_InitStruct)
{
 8000f4e:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t pinpos     = 0x00000000U;
 8000f50:	2600      	movs	r6, #0
  /* ------------------------- Configure the port pins ---------------- */
  /* Initialize  pinpos on first pin set */
  /* pinpos = 0; useless as already done in default initialization */

  /* Configure the port pins */
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 8000f52:	680f      	ldr	r7, [r1, #0]
{
 8000f54:	b085      	sub	sp, #20
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 8000f56:	003b      	movs	r3, r7
 8000f58:	40f3      	lsrs	r3, r6
 8000f5a:	d10c      	bne.n	8000f76 <LL_GPIO_Init+0x28>
      }
    }
    pinpos++;
  }

  if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 8000f5c:	684b      	ldr	r3, [r1, #4]
 8000f5e:	3b01      	subs	r3, #1
 8000f60:	2b01      	cmp	r3, #1
 8000f62:	d805      	bhi.n	8000f70 <LL_GPIO_Init+0x22>
  *         @arg @ref LL_GPIO_OUTPUT_OPENDRAIN
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinOutputType(GPIO_TypeDef *GPIOx, uint32_t PinMask, uint32_t OutputType)
{
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8000f64:	68ca      	ldr	r2, [r1, #12]
 8000f66:	6843      	ldr	r3, [r0, #4]
 8000f68:	437a      	muls	r2, r7
 8000f6a:	43bb      	bics	r3, r7
 8000f6c:	4313      	orrs	r3, r2
 8000f6e:	6043      	str	r3, [r0, #4]
    /* Output mode configuration*/
    LL_GPIO_SetPinOutputType(GPIOx, GPIO_InitStruct->Pin, GPIO_InitStruct->OutputType);

  }
  return (SUCCESS);
}
 8000f70:	2001      	movs	r0, #1
 8000f72:	b005      	add	sp, #20
 8000f74:	bdf0      	pop	{r4, r5, r6, r7, pc}
    currentpin = (GPIO_InitStruct->Pin) & (0x00000001U << pinpos);
 8000f76:	2301      	movs	r3, #1
 8000f78:	40b3      	lsls	r3, r6
 8000f7a:	403b      	ands	r3, r7
    if (currentpin)
 8000f7c:	d036      	beq.n	8000fec <LL_GPIO_Init+0x9e>
      LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);
 8000f7e:	684a      	ldr	r2, [r1, #4]
  MODIFY_REG(GPIOx->MODER, ((Pin * Pin) * GPIO_MODER_MODER0), ((Pin * Pin) * Mode));
 8000f80:	2503      	movs	r5, #3
 8000f82:	9201      	str	r2, [sp, #4]
 8000f84:	001a      	movs	r2, r3
 8000f86:	435a      	muls	r2, r3
 8000f88:	4355      	muls	r5, r2
 8000f8a:	43ed      	mvns	r5, r5
 8000f8c:	6804      	ldr	r4, [r0, #0]
 8000f8e:	9502      	str	r5, [sp, #8]
 8000f90:	402c      	ands	r4, r5
 8000f92:	9d01      	ldr	r5, [sp, #4]
 8000f94:	4355      	muls	r5, r2
 8000f96:	432c      	orrs	r4, r5
 8000f98:	6004      	str	r4, [r0, #0]
      if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 8000f9a:	9c01      	ldr	r4, [sp, #4]
 8000f9c:	3c01      	subs	r4, #1
 8000f9e:	2c01      	cmp	r4, #1
 8000fa0:	d80a      	bhi.n	8000fb8 <LL_GPIO_Init+0x6a>
  *         @arg @ref LL_GPIO_SPEED_FREQ_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinSpeed(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t  Speed)
{
  MODIFY_REG(GPIOx->OSPEEDR, ((Pin * Pin) * GPIO_OSPEEDR_OSPEEDR0), ((Pin * Pin) * Speed));
 8000fa2:	6884      	ldr	r4, [r0, #8]
 8000fa4:	46a4      	mov	ip, r4
 8000fa6:	4665      	mov	r5, ip
 8000fa8:	688c      	ldr	r4, [r1, #8]
 8000faa:	4354      	muls	r4, r2
 8000fac:	9403      	str	r4, [sp, #12]
 8000fae:	9c02      	ldr	r4, [sp, #8]
 8000fb0:	4025      	ands	r5, r4
 8000fb2:	9c03      	ldr	r4, [sp, #12]
 8000fb4:	432c      	orrs	r4, r5
 8000fb6:	6084      	str	r4, [r0, #8]
  *         @arg @ref LL_GPIO_PULL_DOWN
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Pull)
{
  MODIFY_REG(GPIOx->PUPDR, ((Pin * Pin) * GPIO_PUPDR_PUPDR0), ((Pin * Pin) * Pull));
 8000fb8:	68c4      	ldr	r4, [r0, #12]
 8000fba:	46a4      	mov	ip, r4
 8000fbc:	4665      	mov	r5, ip
 8000fbe:	690c      	ldr	r4, [r1, #16]
 8000fc0:	4354      	muls	r4, r2
 8000fc2:	9403      	str	r4, [sp, #12]
 8000fc4:	9c02      	ldr	r4, [sp, #8]
 8000fc6:	402c      	ands	r4, r5
 8000fc8:	0025      	movs	r5, r4
 8000fca:	9c03      	ldr	r4, [sp, #12]
 8000fcc:	4325      	orrs	r5, r4
      if (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE)
 8000fce:	9c01      	ldr	r4, [sp, #4]
 8000fd0:	60c5      	str	r5, [r0, #12]
 8000fd2:	2c02      	cmp	r4, #2
 8000fd4:	d10a      	bne.n	8000fec <LL_GPIO_Init+0x9e>
 8000fd6:	694c      	ldr	r4, [r1, #20]
        if (currentpin < LL_GPIO_PIN_8)
 8000fd8:	2bff      	cmp	r3, #255	; 0xff
 8000fda:	d809      	bhi.n	8000ff0 <LL_GPIO_Init+0xa2>
  *         @arg @ref LL_GPIO_AF_7
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetAFPin_0_7(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate)
{
  MODIFY_REG(GPIOx->AFR[0], ((((Pin * Pin) * Pin) * Pin) * GPIO_AFRL_AFSEL0),
 8000fdc:	250f      	movs	r5, #15
 8000fde:	4352      	muls	r2, r2
 8000fe0:	4355      	muls	r5, r2
 8000fe2:	4362      	muls	r2, r4
 8000fe4:	6a03      	ldr	r3, [r0, #32]
 8000fe6:	43ab      	bics	r3, r5
 8000fe8:	4313      	orrs	r3, r2
 8000fea:	6203      	str	r3, [r0, #32]
    pinpos++;
 8000fec:	3601      	adds	r6, #1
 8000fee:	e7b2      	b.n	8000f56 <LL_GPIO_Init+0x8>
  *         @arg @ref LL_GPIO_AF_7
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetAFPin_8_15(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate)
{
  MODIFY_REG(GPIOx->AFR[1], (((((Pin >> 8U) * (Pin >> 8U)) * (Pin >> 8U)) * (Pin >> 8U)) * GPIO_AFRH_AFSEL8),
 8000ff0:	220f      	movs	r2, #15
 8000ff2:	0a1b      	lsrs	r3, r3, #8
 8000ff4:	435b      	muls	r3, r3
 8000ff6:	435b      	muls	r3, r3
 8000ff8:	435a      	muls	r2, r3
 8000ffa:	4363      	muls	r3, r4
 8000ffc:	6a45      	ldr	r5, [r0, #36]	; 0x24
 8000ffe:	4395      	bics	r5, r2
 8001000:	431d      	orrs	r5, r3
 8001002:	6245      	str	r5, [r0, #36]	; 0x24
 8001004:	e7f2      	b.n	8000fec <LL_GPIO_Init+0x9e>
	...

08001008 <RCC_GetHCLKClockFreq>:
  *         @arg @ref LL_RCC_SYSCLK_DIV_256
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  */
__STATIC_INLINE uint32_t LL_RCC_GetAHBPrescaler(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 8001008:	4b03      	ldr	r3, [pc, #12]	; (8001018 <RCC_GetHCLKClockFreq+0x10>)
  * @retval HCLK clock frequency (in Hz)
  */
uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)
{
  /* HCLK clock frequency */
  return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
 800100a:	4a04      	ldr	r2, [pc, #16]	; (800101c <RCC_GetHCLKClockFreq+0x14>)
 800100c:	685b      	ldr	r3, [r3, #4]
 800100e:	061b      	lsls	r3, r3, #24
 8001010:	0f1b      	lsrs	r3, r3, #28
 8001012:	5cd3      	ldrb	r3, [r2, r3]
 8001014:	40d8      	lsrs	r0, r3
}
 8001016:	4770      	bx	lr
 8001018:	40021000 	.word	0x40021000
 800101c:	080042cf 	.word	0x080042cf

08001020 <RCC_GetPCLK1ClockFreq>:
  *         @arg @ref LL_RCC_APB1_DIV_8
  *         @arg @ref LL_RCC_APB1_DIV_16
  */
__STATIC_INLINE uint32_t LL_RCC_GetAPB1Prescaler(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE));
 8001020:	4b03      	ldr	r3, [pc, #12]	; (8001030 <RCC_GetPCLK1ClockFreq+0x10>)
  * @retval PCLK1 clock frequency (in Hz)
  */
uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
{
  /* PCLK1 clock frequency */
  return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
 8001022:	4a04      	ldr	r2, [pc, #16]	; (8001034 <RCC_GetPCLK1ClockFreq+0x14>)
 8001024:	685b      	ldr	r3, [r3, #4]
 8001026:	055b      	lsls	r3, r3, #21
 8001028:	0f5b      	lsrs	r3, r3, #29
 800102a:	5cd3      	ldrb	r3, [r2, r3]
 800102c:	40d8      	lsrs	r0, r3
}
 800102e:	4770      	bx	lr
 8001030:	40021000 	.word	0x40021000
 8001034:	080042df 	.word	0x080042df

08001038 <RCC_PLL_GetFreqDomain_SYS>:
  *
  *         (*) value not defined in all devices
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLSRC));
 8001038:	4b09      	ldr	r3, [pc, #36]	; (8001060 <RCC_PLL_GetFreqDomain_SYS+0x28>)
/**
  * @brief  Return PLL clock frequency used for system domain
  * @retval PLL clock frequency (in Hz)
  */
uint32_t RCC_PLL_GetFreqDomain_SYS(void)
{
 800103a:	b570      	push	{r4, r5, r6, lr}
 800103c:	685a      	ldr	r2, [r3, #4]
  /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL divider) * PLL Multiplicator */

  /* Get PLL source */
  pllsource = LL_RCC_PLL_GetMainSource();

  switch (pllsource)
 800103e:	03d2      	lsls	r2, r2, #15
 8001040:	d50c      	bpl.n	800105c <RCC_PLL_GetFreqDomain_SYS+0x24>
      pllinputfreq = HSI48_VALUE;
      break;
#endif /* RCC_HSI48_SUPPORT */

    case LL_RCC_PLLSOURCE_HSE:       /* HSE used as PLL clock source */
      pllinputfreq = HSE_VALUE;
 8001042:	4808      	ldr	r0, [pc, #32]	; (8001064 <RCC_PLL_GetFreqDomain_SYS+0x2c>)
  *         @arg @ref LL_RCC_PREDIV_DIV_15
  *         @arg @ref LL_RCC_PREDIV_DIV_16
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetPrediv(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PREDIV));
 8001044:	250f      	movs	r5, #15
 8001046:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLMUL));
 8001048:	685c      	ldr	r4, [r3, #4]
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PREDIV));
 800104a:	4029      	ands	r1, r5
      break;
  }
#if defined(RCC_PLLSRC_PREDIV1_SUPPORT)
  return __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetMultiplicator(), LL_RCC_PLL_GetPrediv());
#else
  return __LL_RCC_CALC_PLLCLK_FREQ((pllinputfreq / (LL_RCC_PLL_GetPrediv() + 1U)), LL_RCC_PLL_GetMultiplicator());
 800104c:	3101      	adds	r1, #1
 800104e:	f7ff f85b 	bl	8000108 <__udivsi3>
 8001052:	0ca4      	lsrs	r4, r4, #18
 8001054:	402c      	ands	r4, r5
 8001056:	3402      	adds	r4, #2
 8001058:	4360      	muls	r0, r4
#endif /* RCC_PLLSRC_PREDIV1_SUPPORT */
}
 800105a:	bd70      	pop	{r4, r5, r6, pc}
      pllinputfreq = HSI_VALUE / 2U;
 800105c:	4802      	ldr	r0, [pc, #8]	; (8001068 <RCC_PLL_GetFreqDomain_SYS+0x30>)
 800105e:	e7f1      	b.n	8001044 <RCC_PLL_GetFreqDomain_SYS+0xc>
 8001060:	40021000 	.word	0x40021000
 8001064:	007a1200 	.word	0x007a1200
 8001068:	003d0900 	.word	0x003d0900

0800106c <RCC_GetSystemClockFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 800106c:	220c      	movs	r2, #12
 800106e:	4b05      	ldr	r3, [pc, #20]	; (8001084 <RCC_GetSystemClockFreq+0x18>)
{
 8001070:	b510      	push	{r4, lr}
 8001072:	685b      	ldr	r3, [r3, #4]
 8001074:	4013      	ands	r3, r2
  switch (LL_RCC_GetSysClkSource())
 8001076:	2b08      	cmp	r3, #8
 8001078:	d102      	bne.n	8001080 <RCC_GetSystemClockFreq+0x14>
      frequency = RCC_PLL_GetFreqDomain_SYS();
 800107a:	f7ff ffdd 	bl	8001038 <RCC_PLL_GetFreqDomain_SYS>
}
 800107e:	bd10      	pop	{r4, pc}
      frequency = HSI_VALUE;
 8001080:	4801      	ldr	r0, [pc, #4]	; (8001088 <RCC_GetSystemClockFreq+0x1c>)
  return frequency;
 8001082:	e7fc      	b.n	800107e <RCC_GetSystemClockFreq+0x12>
 8001084:	40021000 	.word	0x40021000
 8001088:	007a1200 	.word	0x007a1200

0800108c <LL_RCC_GetSystemClocksFreq>:
{
 800108c:	b510      	push	{r4, lr}
 800108e:	0004      	movs	r4, r0
  RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();
 8001090:	f7ff ffec 	bl	800106c <RCC_GetSystemClockFreq>
 8001094:	6020      	str	r0, [r4, #0]
  RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);
 8001096:	f7ff ffb7 	bl	8001008 <RCC_GetHCLKClockFreq>
 800109a:	6060      	str	r0, [r4, #4]
  RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);
 800109c:	f7ff ffc0 	bl	8001020 <RCC_GetPCLK1ClockFreq>
 80010a0:	60a0      	str	r0, [r4, #8]
}
 80010a2:	bd10      	pop	{r4, pc}

080010a4 <LL_RCC_GetUSARTClockFreq>:
{
 80010a4:	b510      	push	{r4, lr}
  if (USARTxSource == LL_RCC_USART1_CLKSOURCE)
 80010a6:	2800      	cmp	r0, #0
 80010a8:	d11e      	bne.n	80010e8 <LL_RCC_GetUSARTClockFreq+0x44>
  return (uint32_t)(READ_BIT(RCC->CFGR3, (RCC_CFGR3_USART1SW << USARTx)) | (USARTx << 24U));
 80010aa:	2103      	movs	r1, #3
 80010ac:	4a0f      	ldr	r2, [pc, #60]	; (80010ec <LL_RCC_GetUSARTClockFreq+0x48>)
 80010ae:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80010b0:	400b      	ands	r3, r1
    switch (LL_RCC_GetUSARTClockSource(USARTxSource))
 80010b2:	2b02      	cmp	r3, #2
 80010b4:	d00b      	beq.n	80010ce <LL_RCC_GetUSARTClockFreq+0x2a>
 80010b6:	428b      	cmp	r3, r1
 80010b8:	d004      	beq.n	80010c4 <LL_RCC_GetUSARTClockFreq+0x20>
 80010ba:	2b01      	cmp	r3, #1
 80010bc:	d10d      	bne.n	80010da <LL_RCC_GetUSARTClockFreq+0x36>
        usart_frequency = RCC_GetSystemClockFreq();
 80010be:	f7ff ffd5 	bl	800106c <RCC_GetSystemClockFreq>
}
 80010c2:	bd10      	pop	{r4, pc}
  return (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY));
 80010c4:	6813      	ldr	r3, [r2, #0]
        if (LL_RCC_HSI_IsReady())
 80010c6:	079b      	lsls	r3, r3, #30
 80010c8:	d5fb      	bpl.n	80010c2 <LL_RCC_GetUSARTClockFreq+0x1e>
          usart_frequency = HSI_VALUE;
 80010ca:	4809      	ldr	r0, [pc, #36]	; (80010f0 <LL_RCC_GetUSARTClockFreq+0x4c>)
 80010cc:	e7f9      	b.n	80010c2 <LL_RCC_GetUSARTClockFreq+0x1e>
  return (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY));
 80010ce:	6a12      	ldr	r2, [r2, #32]
        if (LL_RCC_LSE_IsReady())
 80010d0:	421a      	tst	r2, r3
 80010d2:	d0f6      	beq.n	80010c2 <LL_RCC_GetUSARTClockFreq+0x1e>
          usart_frequency = LSE_VALUE;
 80010d4:	2080      	movs	r0, #128	; 0x80
 80010d6:	0200      	lsls	r0, r0, #8
 80010d8:	e7f3      	b.n	80010c2 <LL_RCC_GetUSARTClockFreq+0x1e>
        usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
 80010da:	f7ff ffc7 	bl	800106c <RCC_GetSystemClockFreq>
 80010de:	f7ff ff93 	bl	8001008 <RCC_GetHCLKClockFreq>
 80010e2:	f7ff ff9d 	bl	8001020 <RCC_GetPCLK1ClockFreq>
        break;
 80010e6:	e7ec      	b.n	80010c2 <LL_RCC_GetUSARTClockFreq+0x1e>
  uint32_t usart_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
 80010e8:	2000      	movs	r0, #0
 80010ea:	e7ea      	b.n	80010c2 <LL_RCC_GetUSARTClockFreq+0x1e>
 80010ec:	40021000 	.word	0x40021000
 80010f0:	007a1200 	.word	0x007a1200

080010f4 <LL_USART_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: USART registers are initialized according to USART_InitStruct content
  *          - ERROR: Problem occurred during USART Registers initialization
  */
ErrorStatus LL_USART_Init(USART_TypeDef *USARTx, LL_USART_InitTypeDef *USART_InitStruct)
{
 80010f4:	b530      	push	{r4, r5, lr}
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsEnabled(USART_TypeDef *USARTx)
{
  return (READ_BIT(USARTx->CR1, USART_CR1_UE) == (USART_CR1_UE));
 80010f6:	6803      	ldr	r3, [r0, #0]
 80010f8:	0004      	movs	r4, r0
 80010fa:	2001      	movs	r0, #1
 80010fc:	b085      	sub	sp, #20
 80010fe:	000d      	movs	r5, r1
 8001100:	4018      	ands	r0, r3
  assert_param(IS_LL_USART_HWCONTROL(USART_InitStruct->HardwareFlowControl));
  assert_param(IS_LL_USART_OVERSAMPLING(USART_InitStruct->OverSampling));

  /* USART needs to be in disabled state, in order to be able to configure some bits in
     CRx registers */
  if (LL_USART_IsEnabled(USARTx) == 0U)
 8001102:	d002      	beq.n	800110a <LL_USART_Init+0x16>
  ErrorStatus status = ERROR;
 8001104:	2000      	movs	r0, #0
    }
  }
  /* Endif (=> USART not in Disabled state => return ERROR) */

  return (status);
}
 8001106:	b005      	add	sp, #20
 8001108:	bd30      	pop	{r4, r5, pc}
    MODIFY_REG(USARTx->CR1,
 800110a:	684b      	ldr	r3, [r1, #4]
 800110c:	68c9      	ldr	r1, [r1, #12]
 800110e:	6822      	ldr	r2, [r4, #0]
 8001110:	430b      	orrs	r3, r1
 8001112:	6929      	ldr	r1, [r5, #16]
 8001114:	430b      	orrs	r3, r1
 8001116:	69a9      	ldr	r1, [r5, #24]
 8001118:	430b      	orrs	r3, r1
 800111a:	491c      	ldr	r1, [pc, #112]	; (800118c <LL_USART_Init+0x98>)
 800111c:	400a      	ands	r2, r1
 800111e:	4313      	orrs	r3, r2
 8001120:	6023      	str	r3, [r4, #0]
  *         (*) Values not available on all devices
  * @retval None
  */
__STATIC_INLINE void LL_USART_SetStopBitsLength(USART_TypeDef *USARTx, uint32_t StopBits)
{
  MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 8001122:	6863      	ldr	r3, [r4, #4]
 8001124:	4a1a      	ldr	r2, [pc, #104]	; (8001190 <LL_USART_Init+0x9c>)
 8001126:	4013      	ands	r3, r2
 8001128:	68aa      	ldr	r2, [r5, #8]
 800112a:	4313      	orrs	r3, r2
 800112c:	6063      	str	r3, [r4, #4]
  *         @arg @ref LL_USART_HWCONTROL_RTS_CTS
  * @retval None
  */
__STATIC_INLINE void LL_USART_SetHWFlowCtrl(USART_TypeDef *USARTx, uint32_t HardwareFlowControl)
{
  MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 800112e:	68a3      	ldr	r3, [r4, #8]
 8001130:	4a18      	ldr	r2, [pc, #96]	; (8001194 <LL_USART_Init+0xa0>)
 8001132:	4013      	ands	r3, r2
 8001134:	696a      	ldr	r2, [r5, #20]
 8001136:	4313      	orrs	r3, r2
 8001138:	60a3      	str	r3, [r4, #8]
    if (USARTx == USART1)
 800113a:	4b17      	ldr	r3, [pc, #92]	; (8001198 <LL_USART_Init+0xa4>)
 800113c:	429c      	cmp	r4, r3
 800113e:	d118      	bne.n	8001172 <LL_USART_Init+0x7e>
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART1_CLKSOURCE);
 8001140:	f7ff ffb0 	bl	80010a4 <LL_RCC_GetUSARTClockFreq>
    if ((periphclk != LL_RCC_PERIPH_FREQUENCY_NO)
 8001144:	2800      	cmp	r0, #0
 8001146:	d0dd      	beq.n	8001104 <LL_USART_Init+0x10>
        && (USART_InitStruct->BaudRate != 0U))
 8001148:	6829      	ldr	r1, [r5, #0]
 800114a:	2900      	cmp	r1, #0
 800114c:	d0da      	beq.n	8001104 <LL_USART_Init+0x10>
                                          uint32_t BaudRate)
{
  register uint32_t usartdiv = 0x0U;
  register uint32_t brrtemp = 0x0U;

  if (OverSampling == LL_USART_OVERSAMPLING_8)
 800114e:	2280      	movs	r2, #128	; 0x80
 8001150:	69ad      	ldr	r5, [r5, #24]
 8001152:	0212      	lsls	r2, r2, #8
 8001154:	084b      	lsrs	r3, r1, #1
 8001156:	4295      	cmp	r5, r2
 8001158:	d113      	bne.n	8001182 <LL_USART_Init+0x8e>
  {
    usartdiv = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
 800115a:	0040      	lsls	r0, r0, #1
 800115c:	18c0      	adds	r0, r0, r3
 800115e:	f7fe ffd3 	bl	8000108 <__udivsi3>
    brrtemp = usartdiv & 0xFFF0U;
 8001162:	4b0e      	ldr	r3, [pc, #56]	; (800119c <LL_USART_Init+0xa8>)
 8001164:	4003      	ands	r3, r0
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8001166:	0700      	lsls	r0, r0, #28
 8001168:	0f40      	lsrs	r0, r0, #29
 800116a:	4318      	orrs	r0, r3
    USARTx->BRR = brrtemp;
  }
  else
  {
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
 800116c:	60e0      	str	r0, [r4, #12]
      status = SUCCESS;
 800116e:	2001      	movs	r0, #1
 8001170:	e7c9      	b.n	8001106 <LL_USART_Init+0x12>
    else if (USARTx == USART2)
 8001172:	4b0b      	ldr	r3, [pc, #44]	; (80011a0 <LL_USART_Init+0xac>)
 8001174:	429c      	cmp	r4, r3
 8001176:	d1c5      	bne.n	8001104 <LL_USART_Init+0x10>
      LL_RCC_GetSystemClocksFreq(&RCC_Clocks);
 8001178:	a801      	add	r0, sp, #4
 800117a:	f7ff ff87 	bl	800108c <LL_RCC_GetSystemClocksFreq>
      periphclk = RCC_Clocks.PCLK1_Frequency;
 800117e:	9803      	ldr	r0, [sp, #12]
 8001180:	e7e0      	b.n	8001144 <LL_USART_Init+0x50>
 8001182:	1818      	adds	r0, r3, r0
 8001184:	f7fe ffc0 	bl	8000108 <__udivsi3>
 8001188:	b280      	uxth	r0, r0
 800118a:	e7ef      	b.n	800116c <LL_USART_Init+0x78>
 800118c:	ffff69f3 	.word	0xffff69f3
 8001190:	ffffcfff 	.word	0xffffcfff
 8001194:	fffffcff 	.word	0xfffffcff
 8001198:	40013800 	.word	0x40013800
 800119c:	0000fff0 	.word	0x0000fff0
 80011a0:	40004400 	.word	0x40004400

080011a4 <FATFS_LinkDriverEx>:
  * @param  lun : only used for USB Key Disk to add multi-lun management
            else the paramter must be equal to 0
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriverEx(Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
 80011a4:	b530      	push	{r4, r5, lr}
  uint8_t ret = 1;
 80011a6:	2401      	movs	r4, #1
  uint8_t DiskNum = 0;
  
  if(disk.nbr <= _VOLUMES)
 80011a8:	4b0e      	ldr	r3, [pc, #56]	; (80011e4 <FATFS_LinkDriverEx+0x40>)
 80011aa:	7a5d      	ldrb	r5, [r3, #9]
 80011ac:	42a5      	cmp	r5, r4
 80011ae:	d816      	bhi.n	80011de <FATFS_LinkDriverEx+0x3a>
  {
    disk.is_initialized[disk.nbr] = 0;
 80011b0:	2400      	movs	r4, #0
 80011b2:	7a5d      	ldrb	r5, [r3, #9]
 80011b4:	b2ed      	uxtb	r5, r5
 80011b6:	555c      	strb	r4, [r3, r5]
    disk.drv[disk.nbr] = drv;  
 80011b8:	7a5d      	ldrb	r5, [r3, #9]
 80011ba:	00ad      	lsls	r5, r5, #2
 80011bc:	195d      	adds	r5, r3, r5
 80011be:	6068      	str	r0, [r5, #4]
    disk.lun[disk.nbr] = lun;  
 80011c0:	7a58      	ldrb	r0, [r3, #9]
 80011c2:	1818      	adds	r0, r3, r0
 80011c4:	7202      	strb	r2, [r0, #8]
    DiskNum = disk.nbr++;
 80011c6:	7a5a      	ldrb	r2, [r3, #9]
 80011c8:	b2d2      	uxtb	r2, r2
 80011ca:	1c50      	adds	r0, r2, #1
 80011cc:	b2c0      	uxtb	r0, r0
 80011ce:	7258      	strb	r0, [r3, #9]
    path[0] = DiskNum + '0';
    path[1] = ':';
 80011d0:	233a      	movs	r3, #58	; 0x3a
    path[0] = DiskNum + '0';
 80011d2:	3230      	adds	r2, #48	; 0x30
    path[1] = ':';
 80011d4:	704b      	strb	r3, [r1, #1]
    path[2] = '/';
 80011d6:	3b0b      	subs	r3, #11
    path[0] = DiskNum + '0';
 80011d8:	700a      	strb	r2, [r1, #0]
    path[2] = '/';
 80011da:	708b      	strb	r3, [r1, #2]
    path[3] = 0;
 80011dc:	70cc      	strb	r4, [r1, #3]
    ret = 0;
  }
  
  return ret;
}
 80011de:	0020      	movs	r0, r4
 80011e0:	bd30      	pop	{r4, r5, pc}
 80011e2:	46c0      	nop			; (mov r8, r8)
 80011e4:	200000a0 	.word	0x200000a0

080011e8 <FATFS_LinkDriver>:
  * @param  drv: pointer to the disk IO Driver structure
  * @param  path: pointer to the logical drive path 
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(Diskio_drvTypeDef *drv, char *path)
{
 80011e8:	b510      	push	{r4, lr}
  return FATFS_LinkDriverEx(drv, path, 0);
 80011ea:	2200      	movs	r2, #0
 80011ec:	f7ff ffda 	bl	80011a4 <FATFS_LinkDriverEx>
}
 80011f0:	bd10      	pop	{r4, pc}

080011f2 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 80011f2:	b510      	push	{r4, lr}
  vTaskStartScheduler();
 80011f4:	f000 fe7c 	bl	8001ef0 <vTaskStartScheduler>
  
  return osOK;
}
 80011f8:	2000      	movs	r0, #0
 80011fa:	bd10      	pop	{r4, pc}

080011fc <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 80011fc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 80011fe:	000b      	movs	r3, r1

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8001200:	6846      	ldr	r6, [r0, #4]
 8001202:	6801      	ldr	r1, [r0, #0]
 8001204:	8a02      	ldrh	r2, [r0, #16]
 8001206:	2508      	movs	r5, #8
 8001208:	5f45      	ldrsh	r5, [r0, r5]
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 800120a:	2400      	movs	r4, #0
  if (priority != osPriorityError) {
 800120c:	2d84      	cmp	r5, #132	; 0x84
 800120e:	d000      	beq.n	8001212 <osThreadCreate+0x16>
    fpriority += (priority - osPriorityIdle);
 8001210:	1cec      	adds	r4, r5, #3
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8001212:	a803      	add	r0, sp, #12
 8001214:	9001      	str	r0, [sp, #4]
 8001216:	9400      	str	r4, [sp, #0]
 8001218:	0030      	movs	r0, r6
 800121a:	f000 fda5 	bl	8001d68 <xTaskCreate>
                   thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
                   &handle) != pdPASS)  {
    return NULL;
 800121e:	2300      	movs	r3, #0
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8001220:	2801      	cmp	r0, #1
 8001222:	d100      	bne.n	8001226 <osThreadCreate+0x2a>
  }     
#endif
  
  return handle;
 8001224:	9b03      	ldr	r3, [sp, #12]
}
 8001226:	0018      	movs	r0, r3
 8001228:	b004      	add	sp, #16
 800122a:	bd70      	pop	{r4, r5, r6, pc}

0800122c <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 800122c:	b510      	push	{r4, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 800122e:	2800      	cmp	r0, #0
 8001230:	d100      	bne.n	8001234 <osDelay+0x8>
 8001232:	3001      	adds	r0, #1
 8001234:	f000 ff7e 	bl	8002134 <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 8001238:	2000      	movs	r0, #0
 800123a:	bd10      	pop	{r4, pc}

0800123c <osTimerCreate>:
* @param  argument      argument to the timer call back function.
* @retval  timer ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osTimerCreate shall be consistent in every CMSIS-RTOS.
*/
osTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument)
{
 800123c:	b507      	push	{r0, r1, r2, lr}
                      (type == osTimerPeriodic) ? pdTRUE : pdFALSE,
                      (void *) argument,
                      (TaskFunction_t)timer_def->ptimer,
                      (StaticTimer_t *)timer_def->controlblock);  
#else
  return xTimerCreate((const char *)"",
 800123e:	3901      	subs	r1, #1
{
 8001240:	0013      	movs	r3, r2
  return xTimerCreate((const char *)"",
 8001242:	424a      	negs	r2, r1
 8001244:	4151      	adcs	r1, r2
 8001246:	6802      	ldr	r2, [r0, #0]
 8001248:	4803      	ldr	r0, [pc, #12]	; (8001258 <osTimerCreate+0x1c>)
 800124a:	9200      	str	r2, [sp, #0]
 800124c:	000a      	movs	r2, r1
 800124e:	2101      	movs	r1, #1
 8001250:	f001 f992 	bl	8002578 <xTimerCreate>
#endif

#else 
	return NULL;
#endif
}
 8001254:	bd0e      	pop	{r1, r2, r3, pc}
 8001256:	46c0      	nop			; (mov r8, r8)
 8001258:	08004351 	.word	0x08004351

0800125c <osSemaphoreCreate>:
* @param count         number of available resources.
* @retval  semaphore ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreCreate shall be consistent in every CMSIS-RTOS.
*/
osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)
{ 
 800125c:	b510      	push	{r4, lr}
 800125e:	0008      	movs	r0, r1
  }
  else {
#if (configUSE_COUNTING_SEMAPHORES == 1 )	
    return xSemaphoreCreateCounting(count, count);
#else
    return NULL;
 8001260:	2400      	movs	r4, #0
  if (count == 1) {
 8001262:	2901      	cmp	r1, #1
 8001264:	d10a      	bne.n	800127c <osSemaphoreCreate+0x20>
    vSemaphoreCreateBinary(sema);
 8001266:	0021      	movs	r1, r4
 8001268:	2203      	movs	r2, #3
 800126a:	f000 fae0 	bl	800182e <xQueueGenericCreate>
 800126e:	1e04      	subs	r4, r0, #0
 8001270:	d004      	beq.n	800127c <osSemaphoreCreate+0x20>
 8001272:	2300      	movs	r3, #0
 8001274:	001a      	movs	r2, r3
 8001276:	0019      	movs	r1, r3
 8001278:	f000 faf6 	bl	8001868 <xQueueGenericSend>
#endif
  }
#endif
}
 800127c:	0020      	movs	r0, r4
 800127e:	bd10      	pop	{r4, pc}

08001280 <osSemaphoreWait>:
* @param  millisec      timeout value or 0 in case of no time-out.
* @retval  number of available tokens, or -1 in case of incorrect parameters.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS.
*/
int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
{
 8001280:	b513      	push	{r0, r1, r4, lr}
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
 8001282:	2400      	movs	r4, #0
{
 8001284:	000a      	movs	r2, r1
  portBASE_TYPE taskWoken = pdFALSE;  
 8001286:	9401      	str	r4, [sp, #4]
  
  
  if (semaphore_id == NULL) {
    return osErrorParameter;
 8001288:	2380      	movs	r3, #128	; 0x80
  if (semaphore_id == NULL) {
 800128a:	42a0      	cmp	r0, r4
 800128c:	d00a      	beq.n	80012a4 <osSemaphoreWait+0x24>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800128e:	f3ef 8105 	mrs	r1, IPSR
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 8001292:	42a1      	cmp	r1, r4
 8001294:	d011      	beq.n	80012ba <osSemaphoreWait+0x3a>
    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 8001296:	aa01      	add	r2, sp, #4
 8001298:	0021      	movs	r1, r4
 800129a:	f000 fca0 	bl	8001bde <xQueueReceiveFromISR>
 800129e:	2801      	cmp	r0, #1
 80012a0:	d002      	beq.n	80012a8 <osSemaphoreWait+0x28>
      return osErrorOS;
 80012a2:	23ff      	movs	r3, #255	; 0xff
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
    return osErrorOS;
  }
  
  return osOK;
}
 80012a4:	0018      	movs	r0, r3
 80012a6:	bd16      	pop	{r1, r2, r4, pc}
	portEND_SWITCHING_ISR(taskWoken);
 80012a8:	9b01      	ldr	r3, [sp, #4]
 80012aa:	2b00      	cmp	r3, #0
 80012ac:	d003      	beq.n	80012b6 <osSemaphoreWait+0x36>
 80012ae:	2280      	movs	r2, #128	; 0x80
 80012b0:	4b05      	ldr	r3, [pc, #20]	; (80012c8 <osSemaphoreWait+0x48>)
 80012b2:	0552      	lsls	r2, r2, #21
 80012b4:	601a      	str	r2, [r3, #0]
  return osOK;
 80012b6:	2300      	movs	r3, #0
 80012b8:	e7f4      	b.n	80012a4 <osSemaphoreWait+0x24>
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
 80012ba:	000b      	movs	r3, r1
 80012bc:	f000 fbe9 	bl	8001a92 <xQueueGenericReceive>
 80012c0:	2801      	cmp	r0, #1
 80012c2:	d1ee      	bne.n	80012a2 <osSemaphoreWait+0x22>
 80012c4:	e7f7      	b.n	80012b6 <osSemaphoreWait+0x36>
 80012c6:	46c0      	nop			; (mov r8, r8)
 80012c8:	e000ed04 	.word	0xe000ed04

080012cc <osSemaphoreRelease>:
* @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreRelease shall be consistent in every CMSIS-RTOS.
*/
osStatus osSemaphoreRelease (osSemaphoreId semaphore_id)
{
 80012cc:	b513      	push	{r0, r1, r4, lr}
  osStatus result = osOK;
  portBASE_TYPE taskWoken = pdFALSE;
 80012ce:	2400      	movs	r4, #0
 80012d0:	9401      	str	r4, [sp, #4]
 80012d2:	f3ef 8105 	mrs	r1, IPSR
  
  
  if (inHandlerMode()) {
 80012d6:	42a1      	cmp	r1, r4
 80012d8:	d00e      	beq.n	80012f8 <osSemaphoreRelease+0x2c>
    if (xSemaphoreGiveFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 80012da:	a901      	add	r1, sp, #4
 80012dc:	f000 fb9c 	bl	8001a18 <xQueueGiveFromISR>
 80012e0:	2801      	cmp	r0, #1
 80012e2:	d10f      	bne.n	8001304 <osSemaphoreRelease+0x38>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 80012e4:	9b01      	ldr	r3, [sp, #4]
 80012e6:	42a3      	cmp	r3, r4
 80012e8:	d101      	bne.n	80012ee <osSemaphoreRelease+0x22>
  osStatus result = osOK;
 80012ea:	2000      	movs	r0, #0
      result = osErrorOS;
    }
  }
  
  return result;
}
 80012ec:	bd16      	pop	{r1, r2, r4, pc}
    portEND_SWITCHING_ISR(taskWoken);
 80012ee:	2280      	movs	r2, #128	; 0x80
 80012f0:	4b05      	ldr	r3, [pc, #20]	; (8001308 <osSemaphoreRelease+0x3c>)
 80012f2:	0552      	lsls	r2, r2, #21
 80012f4:	601a      	str	r2, [r3, #0]
 80012f6:	e7f8      	b.n	80012ea <osSemaphoreRelease+0x1e>
    if (xSemaphoreGive(semaphore_id) != pdTRUE) {
 80012f8:	000b      	movs	r3, r1
 80012fa:	000a      	movs	r2, r1
 80012fc:	f000 fab4 	bl	8001868 <xQueueGenericSend>
 8001300:	2801      	cmp	r0, #1
 8001302:	d0f2      	beq.n	80012ea <osSemaphoreRelease+0x1e>
      result = osErrorOS;
 8001304:	20ff      	movs	r0, #255	; 0xff
 8001306:	e7f1      	b.n	80012ec <osSemaphoreRelease+0x20>
 8001308:	e000ed04 	.word	0xe000ed04

0800130c <osMessageCreate>:
* @param  thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
* @retval  message queue ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMessageCreate shall be consistent in every CMSIS-RTOS.
*/
osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id)
{
 800130c:	b510      	push	{r4, lr}
    return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
  }
#elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
  return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
#else  
  return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
 800130e:	6841      	ldr	r1, [r0, #4]
 8001310:	2200      	movs	r2, #0
 8001312:	6800      	ldr	r0, [r0, #0]
 8001314:	f000 fa8b 	bl	800182e <xQueueGenericCreate>
#endif
}
 8001318:	bd10      	pop	{r4, pc}

0800131a <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800131a:	0003      	movs	r3, r0

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800131c:	2201      	movs	r2, #1
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800131e:	3308      	adds	r3, #8
 8001320:	6043      	str	r3, [r0, #4]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001322:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001324:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8001326:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8001328:	4252      	negs	r2, r2
 800132a:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800132c:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 800132e:	4770      	bx	lr

08001330 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8001330:	2300      	movs	r3, #0
 8001332:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8001334:	4770      	bx	lr

08001336 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8001336:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8001338:	689a      	ldr	r2, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
 800133a:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800133c:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800133e:	689a      	ldr	r2, [r3, #8]
 8001340:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8001342:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8001344:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8001346:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8001348:	3301      	adds	r3, #1
 800134a:	6003      	str	r3, [r0, #0]
}
 800134c:	4770      	bx	lr

0800134e <vListInsert>:
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800134e:	0003      	movs	r3, r0
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8001350:	680a      	ldr	r2, [r1, #0]
{
 8001352:	b530      	push	{r4, r5, lr}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001354:	3308      	adds	r3, #8
	if( xValueOfInsertion == portMAX_DELAY )
 8001356:	1c54      	adds	r4, r2, #1
 8001358:	d10b      	bne.n	8001372 <vListInsert+0x24>
		pxIterator = pxList->xListEnd.pxPrevious;
 800135a:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 800135c:	685a      	ldr	r2, [r3, #4]
 800135e:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8001360:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8001362:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8001364:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8001366:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8001368:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800136a:	3301      	adds	r3, #1
 800136c:	6003      	str	r3, [r0, #0]
}
 800136e:	bd30      	pop	{r4, r5, pc}
 8001370:	0023      	movs	r3, r4
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001372:	685c      	ldr	r4, [r3, #4]
 8001374:	6825      	ldr	r5, [r4, #0]
 8001376:	42aa      	cmp	r2, r5
 8001378:	d2fa      	bcs.n	8001370 <vListInsert+0x22>
 800137a:	e7ef      	b.n	800135c <vListInsert+0xe>

0800137c <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800137c:	6841      	ldr	r1, [r0, #4]
 800137e:	6882      	ldr	r2, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8001380:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8001382:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8001384:	6882      	ldr	r2, [r0, #8]
 8001386:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8001388:	6859      	ldr	r1, [r3, #4]
 800138a:	4288      	cmp	r0, r1
 800138c:	d100      	bne.n	8001390 <uxListRemove+0x14>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 800138e:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8001390:	2200      	movs	r2, #0
 8001392:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8001394:	681a      	ldr	r2, [r3, #0]
 8001396:	1e50      	subs	r0, r2, #1
 8001398:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 800139a:	4770      	bx	lr

0800139c <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 800139c:	4b03      	ldr	r3, [pc, #12]	; (80013ac <prvTaskExitError+0x10>)
 800139e:	681b      	ldr	r3, [r3, #0]
 80013a0:	3301      	adds	r3, #1
 80013a2:	d001      	beq.n	80013a8 <prvTaskExitError+0xc>
 80013a4:	b672      	cpsid	i
 80013a6:	e7fe      	b.n	80013a6 <prvTaskExitError+0xa>
	portDISABLE_INTERRUPTS();
 80013a8:	b672      	cpsid	i
 80013aa:	e7fe      	b.n	80013aa <prvTaskExitError+0xe>
 80013ac:	20000000 	.word	0x20000000

080013b0 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
 80013b0:	4a0b      	ldr	r2, [pc, #44]	; (80013e0 <pxCurrentTCBConst2>)
 80013b2:	6813      	ldr	r3, [r2, #0]
 80013b4:	6818      	ldr	r0, [r3, #0]
 80013b6:	3020      	adds	r0, #32
 80013b8:	f380 8809 	msr	PSP, r0
 80013bc:	2002      	movs	r0, #2
 80013be:	f380 8814 	msr	CONTROL, r0
 80013c2:	f3bf 8f6f 	isb	sy
 80013c6:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
 80013c8:	46ae      	mov	lr, r5
 80013ca:	bc08      	pop	{r3}
 80013cc:	bc04      	pop	{r2}
 80013ce:	b662      	cpsie	i
 80013d0:	4718      	bx	r3
 80013d2:	46c0      	nop			; (mov r8, r8)
 80013d4:	46c0      	nop			; (mov r8, r8)
 80013d6:	46c0      	nop			; (mov r8, r8)
 80013d8:	46c0      	nop			; (mov r8, r8)
 80013da:	46c0      	nop			; (mov r8, r8)
 80013dc:	46c0      	nop			; (mov r8, r8)
 80013de:	46c0      	nop			; (mov r8, r8)

080013e0 <pxCurrentTCBConst2>:
 80013e0:	2000112c 	.word	0x2000112c

080013e4 <pxPortInitialiseStack>:
{
 80013e4:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80013e6:	2480      	movs	r4, #128	; 0x80
 80013e8:	1f03      	subs	r3, r0, #4
 80013ea:	0464      	lsls	r4, r4, #17
 80013ec:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
 80013ee:	3b04      	subs	r3, #4
 80013f0:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 80013f2:	4903      	ldr	r1, [pc, #12]	; (8001400 <pxPortInitialiseStack+0x1c>)
 80013f4:	3b04      	subs	r3, #4
 80013f6:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 80013f8:	3b14      	subs	r3, #20
	pxTopOfStack -= 8; /* R11..R4. */
 80013fa:	3840      	subs	r0, #64	; 0x40
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 80013fc:	601a      	str	r2, [r3, #0]
}
 80013fe:	bd10      	pop	{r4, pc}
 8001400:	0800139d 	.word	0x0800139d

08001404 <SVC_Handler>:
}
 8001404:	4770      	bx	lr
	...

08001408 <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
	/* Set a PendSV to request a context switch. */
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
 8001408:	2280      	movs	r2, #128	; 0x80
 800140a:	4b04      	ldr	r3, [pc, #16]	; (800141c <vPortYield+0x14>)
 800140c:	0552      	lsls	r2, r2, #21
 800140e:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
 8001410:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 8001414:	f3bf 8f6f 	isb	sy
}
 8001418:	4770      	bx	lr
 800141a:	46c0      	nop			; (mov r8, r8)
 800141c:	e000ed04 	.word	0xe000ed04

08001420 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    portDISABLE_INTERRUPTS();
 8001420:	b672      	cpsid	i
    uxCriticalNesting++;
 8001422:	4a04      	ldr	r2, [pc, #16]	; (8001434 <vPortEnterCritical+0x14>)
 8001424:	6813      	ldr	r3, [r2, #0]
 8001426:	3301      	adds	r3, #1
 8001428:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" );
 800142a:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 800142e:	f3bf 8f6f 	isb	sy
}
 8001432:	4770      	bx	lr
 8001434:	20000000 	.word	0x20000000

08001438 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
 8001438:	4a05      	ldr	r2, [pc, #20]	; (8001450 <vPortExitCritical+0x18>)
 800143a:	6813      	ldr	r3, [r2, #0]
 800143c:	2b00      	cmp	r3, #0
 800143e:	d101      	bne.n	8001444 <vPortExitCritical+0xc>
 8001440:	b672      	cpsid	i
 8001442:	e7fe      	b.n	8001442 <vPortExitCritical+0xa>
    uxCriticalNesting--;
 8001444:	3b01      	subs	r3, #1
 8001446:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
 8001448:	2b00      	cmp	r3, #0
 800144a:	d100      	bne.n	800144e <vPortExitCritical+0x16>
    {
        portENABLE_INTERRUPTS();
 800144c:	b662      	cpsie	i
    }
}
 800144e:	4770      	bx	lr
 8001450:	20000000 	.word	0x20000000

08001454 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
	__asm volatile(
 8001454:	f3ef 8010 	mrs	r0, PRIMASK
 8001458:	b672      	cpsid	i
 800145a:	4770      	bx	lr
					" bx lr				  "
				  );

	/* To avoid compiler warnings.  This line will never be reached. */
	return 0;
}
 800145c:	2000      	movs	r0, #0

0800145e <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( uint32_t ulMask )
{
	__asm volatile(
 800145e:	f380 8810 	msr	PRIMASK, r0
 8001462:	4770      	bx	lr
	...

08001470 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8001470:	f3ef 8009 	mrs	r0, PSP
 8001474:	4b0e      	ldr	r3, [pc, #56]	; (80014b0 <pxCurrentTCBConst>)
 8001476:	681a      	ldr	r2, [r3, #0]
 8001478:	3820      	subs	r0, #32
 800147a:	6010      	str	r0, [r2, #0]
 800147c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 800147e:	4644      	mov	r4, r8
 8001480:	464d      	mov	r5, r9
 8001482:	4656      	mov	r6, sl
 8001484:	465f      	mov	r7, fp
 8001486:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 8001488:	b508      	push	{r3, lr}
 800148a:	b672      	cpsid	i
 800148c:	f000 fea0 	bl	80021d0 <vTaskSwitchContext>
 8001490:	b662      	cpsie	i
 8001492:	bc0c      	pop	{r2, r3}
 8001494:	6811      	ldr	r1, [r2, #0]
 8001496:	6808      	ldr	r0, [r1, #0]
 8001498:	3010      	adds	r0, #16
 800149a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800149c:	46a0      	mov	r8, r4
 800149e:	46a9      	mov	r9, r5
 80014a0:	46b2      	mov	sl, r6
 80014a2:	46bb      	mov	fp, r7
 80014a4:	f380 8809 	msr	PSP, r0
 80014a8:	3820      	subs	r0, #32
 80014aa:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 80014ac:	4718      	bx	r3
 80014ae:	46c0      	nop			; (mov r8, r8)

080014b0 <pxCurrentTCBConst>:
 80014b0:	2000112c 	.word	0x2000112c

080014b4 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 80014b4:	b510      	push	{r4, lr}
uint32_t ulPreviousMask;

	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
 80014b6:	f7ff ffcd 	bl	8001454 <ulSetInterruptMaskFromISR>
 80014ba:	0004      	movs	r4, r0
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 80014bc:	f000 fd54 	bl	8001f68 <xTaskIncrementTick>
 80014c0:	2800      	cmp	r0, #0
 80014c2:	d003      	beq.n	80014cc <SysTick_Handler+0x18>
		{
			/* Pend a context switch. */
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 80014c4:	2280      	movs	r2, #128	; 0x80
 80014c6:	4b03      	ldr	r3, [pc, #12]	; (80014d4 <SysTick_Handler+0x20>)
 80014c8:	0552      	lsls	r2, r2, #21
 80014ca:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
 80014cc:	0020      	movs	r0, r4
 80014ce:	f7ff ffc6 	bl	800145e <vClearInterruptMaskFromISR>
}
 80014d2:	bd10      	pop	{r4, pc}
 80014d4:	e000ed04 	.word	0xe000ed04

080014d8 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */
	/* Configure SysTick to interrupt at the requested rate. */

	portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 80014d8:	21fa      	movs	r1, #250	; 0xfa
 80014da:	4b06      	ldr	r3, [pc, #24]	; (80014f4 <vPortSetupTimerInterrupt+0x1c>)
{
 80014dc:	b510      	push	{r4, lr}
	portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 80014de:	6818      	ldr	r0, [r3, #0]
 80014e0:	0089      	lsls	r1, r1, #2
 80014e2:	f7fe fe11 	bl	8000108 <__udivsi3>
	portNVIC_SYSTICK_CTRL = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 80014e6:	2207      	movs	r2, #7
	portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 80014e8:	4b03      	ldr	r3, [pc, #12]	; (80014f8 <vPortSetupTimerInterrupt+0x20>)
 80014ea:	3801      	subs	r0, #1
 80014ec:	6018      	str	r0, [r3, #0]
	portNVIC_SYSTICK_CTRL = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 80014ee:	4b03      	ldr	r3, [pc, #12]	; (80014fc <vPortSetupTimerInterrupt+0x24>)
 80014f0:	601a      	str	r2, [r3, #0]
}
 80014f2:	bd10      	pop	{r4, pc}
 80014f4:	20000004 	.word	0x20000004
 80014f8:	e000e014 	.word	0xe000e014
 80014fc:	e000e010 	.word	0xe000e010

08001500 <xPortStartScheduler>:
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8001500:	22ff      	movs	r2, #255	; 0xff
 8001502:	4b0a      	ldr	r3, [pc, #40]	; (800152c <xPortStartScheduler+0x2c>)
 8001504:	0412      	lsls	r2, r2, #16
 8001506:	6819      	ldr	r1, [r3, #0]
{
 8001508:	b510      	push	{r4, lr}
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 800150a:	430a      	orrs	r2, r1
 800150c:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 800150e:	22ff      	movs	r2, #255	; 0xff
 8001510:	6819      	ldr	r1, [r3, #0]
 8001512:	0612      	lsls	r2, r2, #24
 8001514:	430a      	orrs	r2, r1
 8001516:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 8001518:	f7ff ffde 	bl	80014d8 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 800151c:	2200      	movs	r2, #0
 800151e:	4b04      	ldr	r3, [pc, #16]	; (8001530 <xPortStartScheduler+0x30>)
 8001520:	601a      	str	r2, [r3, #0]
	vPortStartFirstTask();
 8001522:	f7ff ff45 	bl	80013b0 <vPortStartFirstTask>
	prvTaskExitError();
 8001526:	f7ff ff39 	bl	800139c <prvTaskExitError>
 800152a:	46c0      	nop			; (mov r8, r8)
 800152c:	e000ed20 	.word	0xe000ed20
 8001530:	20000000 	.word	0x20000000

08001534 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8001534:	b510      	push	{r4, lr}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8001536:	4b0f      	ldr	r3, [pc, #60]	; (8001574 <prvInsertBlockIntoFreeList+0x40>)
 8001538:	681a      	ldr	r2, [r3, #0]
 800153a:	4282      	cmp	r2, r0
 800153c:	d318      	bcc.n	8001570 <prvInsertBlockIntoFreeList+0x3c>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800153e:	685c      	ldr	r4, [r3, #4]
 8001540:	1919      	adds	r1, r3, r4
 8001542:	4288      	cmp	r0, r1
 8001544:	d103      	bne.n	800154e <prvInsertBlockIntoFreeList+0x1a>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8001546:	6841      	ldr	r1, [r0, #4]
 8001548:	0018      	movs	r0, r3
 800154a:	1909      	adds	r1, r1, r4
 800154c:	6059      	str	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 800154e:	6841      	ldr	r1, [r0, #4]
 8001550:	1844      	adds	r4, r0, r1
 8001552:	42a2      	cmp	r2, r4
 8001554:	d107      	bne.n	8001566 <prvInsertBlockIntoFreeList+0x32>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8001556:	4c08      	ldr	r4, [pc, #32]	; (8001578 <prvInsertBlockIntoFreeList+0x44>)
 8001558:	6824      	ldr	r4, [r4, #0]
 800155a:	42a2      	cmp	r2, r4
 800155c:	d003      	beq.n	8001566 <prvInsertBlockIntoFreeList+0x32>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800155e:	6854      	ldr	r4, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8001560:	6812      	ldr	r2, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8001562:	1861      	adds	r1, r4, r1
 8001564:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8001566:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 8001568:	4298      	cmp	r0, r3
 800156a:	d000      	beq.n	800156e <prvInsertBlockIntoFreeList+0x3a>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 800156c:	6018      	str	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 800156e:	bd10      	pop	{r4, pc}
 8001570:	0013      	movs	r3, r2
 8001572:	e7e1      	b.n	8001538 <prvInsertBlockIntoFreeList+0x4>
 8001574:	20001124 	.word	0x20001124
 8001578:	200000ac 	.word	0x200000ac

0800157c <pvPortMalloc>:
{
 800157c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800157e:	0004      	movs	r4, r0
	vTaskSuspendAll();
 8001580:	f000 fce4 	bl	8001f4c <vTaskSuspendAll>
		if( pxEnd == NULL )
 8001584:	4a37      	ldr	r2, [pc, #220]	; (8001664 <pvPortMalloc+0xe8>)
 8001586:	4838      	ldr	r0, [pc, #224]	; (8001668 <pvPortMalloc+0xec>)
 8001588:	6813      	ldr	r3, [r2, #0]
 800158a:	2b00      	cmp	r3, #0
 800158c:	d11d      	bne.n	80015ca <pvPortMalloc+0x4e>
	uxAddress = ( size_t ) ucHeap;
 800158e:	4937      	ldr	r1, [pc, #220]	; (800166c <pvPortMalloc+0xf0>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8001590:	3307      	adds	r3, #7
 8001592:	4219      	tst	r1, r3
 8001594:	d035      	beq.n	8001602 <pvPortMalloc+0x86>
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8001596:	18cd      	adds	r5, r1, r3
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8001598:	439d      	bics	r5, r3
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 800159a:	4b35      	ldr	r3, [pc, #212]	; (8001670 <pvPortMalloc+0xf4>)
 800159c:	18c9      	adds	r1, r1, r3
 800159e:	1b4b      	subs	r3, r1, r5
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80015a0:	0029      	movs	r1, r5
	xStart.xBlockSize = ( size_t ) 0;
 80015a2:	2500      	movs	r5, #0
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 80015a4:	4e33      	ldr	r6, [pc, #204]	; (8001674 <pvPortMalloc+0xf8>)
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 80015a6:	18cb      	adds	r3, r1, r3
	xStart.xBlockSize = ( size_t ) 0;
 80015a8:	6075      	str	r5, [r6, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 80015aa:	6031      	str	r1, [r6, #0]
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80015ac:	2607      	movs	r6, #7
	uxAddress -= xHeapStructSize;
 80015ae:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80015b0:	43b3      	bics	r3, r6
	pxEnd->pxNextFreeBlock = NULL;
 80015b2:	601d      	str	r5, [r3, #0]
	pxEnd->xBlockSize = 0;
 80015b4:	605d      	str	r5, [r3, #4]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 80015b6:	1a5d      	subs	r5, r3, r1
	pxEnd = ( void * ) uxAddress;
 80015b8:	6013      	str	r3, [r2, #0]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 80015ba:	c128      	stmia	r1!, {r3, r5}
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80015bc:	4b2e      	ldr	r3, [pc, #184]	; (8001678 <pvPortMalloc+0xfc>)
 80015be:	601d      	str	r5, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80015c0:	4b2e      	ldr	r3, [pc, #184]	; (800167c <pvPortMalloc+0x100>)
 80015c2:	601d      	str	r5, [r3, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 80015c4:	2380      	movs	r3, #128	; 0x80
 80015c6:	061b      	lsls	r3, r3, #24
 80015c8:	6003      	str	r3, [r0, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 80015ca:	6806      	ldr	r6, [r0, #0]
 80015cc:	4234      	tst	r4, r6
 80015ce:	d116      	bne.n	80015fe <pvPortMalloc+0x82>
			if( xWantedSize > 0 )
 80015d0:	2c00      	cmp	r4, #0
 80015d2:	d014      	beq.n	80015fe <pvPortMalloc+0x82>
				xWantedSize += xHeapStructSize;
 80015d4:	0023      	movs	r3, r4
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 80015d6:	2107      	movs	r1, #7
				xWantedSize += xHeapStructSize;
 80015d8:	3308      	adds	r3, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 80015da:	420b      	tst	r3, r1
 80015dc:	d001      	beq.n	80015e2 <pvPortMalloc+0x66>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 80015de:	438b      	bics	r3, r1
 80015e0:	3308      	adds	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 80015e2:	2b00      	cmp	r3, #0
 80015e4:	d00b      	beq.n	80015fe <pvPortMalloc+0x82>
 80015e6:	4925      	ldr	r1, [pc, #148]	; (800167c <pvPortMalloc+0x100>)
 80015e8:	680d      	ldr	r5, [r1, #0]
 80015ea:	42ab      	cmp	r3, r5
 80015ec:	d807      	bhi.n	80015fe <pvPortMalloc+0x82>
				pxBlock = xStart.pxNextFreeBlock;
 80015ee:	4921      	ldr	r1, [pc, #132]	; (8001674 <pvPortMalloc+0xf8>)
 80015f0:	680c      	ldr	r4, [r1, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 80015f2:	6860      	ldr	r0, [r4, #4]
 80015f4:	4283      	cmp	r3, r0
 80015f6:	d806      	bhi.n	8001606 <pvPortMalloc+0x8a>
				if( pxBlock != pxEnd )
 80015f8:	6812      	ldr	r2, [r2, #0]
 80015fa:	4294      	cmp	r4, r2
 80015fc:	d10a      	bne.n	8001614 <pvPortMalloc+0x98>
void *pvReturn = NULL;
 80015fe:	2500      	movs	r5, #0
 8001600:	e027      	b.n	8001652 <pvPortMalloc+0xd6>
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 8001602:	4b1b      	ldr	r3, [pc, #108]	; (8001670 <pvPortMalloc+0xf4>)
 8001604:	e7cd      	b.n	80015a2 <pvPortMalloc+0x26>
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8001606:	6827      	ldr	r7, [r4, #0]
 8001608:	46bc      	mov	ip, r7
 800160a:	2f00      	cmp	r7, #0
 800160c:	d0f4      	beq.n	80015f8 <pvPortMalloc+0x7c>
 800160e:	0021      	movs	r1, r4
 8001610:	4664      	mov	r4, ip
 8001612:	e7ee      	b.n	80015f2 <pvPortMalloc+0x76>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8001614:	680a      	ldr	r2, [r1, #0]
 8001616:	0017      	movs	r7, r2
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8001618:	6822      	ldr	r2, [r4, #0]
 800161a:	600a      	str	r2, [r1, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800161c:	1ac2      	subs	r2, r0, r3
 800161e:	2a10      	cmp	r2, #16
 8001620:	d908      	bls.n	8001634 <pvPortMalloc+0xb8>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8001622:	18e0      	adds	r0, r4, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8001624:	0741      	lsls	r1, r0, #29
 8001626:	d001      	beq.n	800162c <pvPortMalloc+0xb0>
 8001628:	b672      	cpsid	i
 800162a:	e7fe      	b.n	800162a <pvPortMalloc+0xae>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 800162c:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 800162e:	6063      	str	r3, [r4, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 8001630:	f7ff ff80 	bl	8001534 <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8001634:	6863      	ldr	r3, [r4, #4]
 8001636:	4a11      	ldr	r2, [pc, #68]	; (800167c <pvPortMalloc+0x100>)
 8001638:	1aed      	subs	r5, r5, r3
 800163a:	6015      	str	r5, [r2, #0]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800163c:	4a0e      	ldr	r2, [pc, #56]	; (8001678 <pvPortMalloc+0xfc>)
 800163e:	6811      	ldr	r1, [r2, #0]
 8001640:	428d      	cmp	r5, r1
 8001642:	d200      	bcs.n	8001646 <pvPortMalloc+0xca>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8001644:	6015      	str	r5, [r2, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8001646:	431e      	orrs	r6, r3
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8001648:	003d      	movs	r5, r7
					pxBlock->pxNextFreeBlock = NULL;
 800164a:	2300      	movs	r3, #0
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800164c:	3508      	adds	r5, #8
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800164e:	6066      	str	r6, [r4, #4]
					pxBlock->pxNextFreeBlock = NULL;
 8001650:	6023      	str	r3, [r4, #0]
	( void ) xTaskResumeAll();
 8001652:	f000 fd07 	bl	8002064 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8001656:	076b      	lsls	r3, r5, #29
 8001658:	d001      	beq.n	800165e <pvPortMalloc+0xe2>
 800165a:	b672      	cpsid	i
 800165c:	e7fe      	b.n	800165c <pvPortMalloc+0xe0>
}
 800165e:	0028      	movs	r0, r5
 8001660:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001662:	46c0      	nop			; (mov r8, r8)
 8001664:	200000ac 	.word	0x200000ac
 8001668:	20001118 	.word	0x20001118
 800166c:	200000b0 	.word	0x200000b0
 8001670:	00001068 	.word	0x00001068
 8001674:	20001124 	.word	0x20001124
 8001678:	20001120 	.word	0x20001120
 800167c:	2000111c 	.word	0x2000111c

08001680 <vPortFree>:
{
 8001680:	b510      	push	{r4, lr}
	if( pv != NULL )
 8001682:	2800      	cmp	r0, #0
 8001684:	d01b      	beq.n	80016be <vPortFree+0x3e>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8001686:	4a0e      	ldr	r2, [pc, #56]	; (80016c0 <vPortFree+0x40>)
 8001688:	3808      	subs	r0, #8
 800168a:	6843      	ldr	r3, [r0, #4]
 800168c:	6812      	ldr	r2, [r2, #0]
 800168e:	0004      	movs	r4, r0
 8001690:	421a      	tst	r2, r3
 8001692:	d101      	bne.n	8001698 <vPortFree+0x18>
 8001694:	b672      	cpsid	i
 8001696:	e7fe      	b.n	8001696 <vPortFree+0x16>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8001698:	6801      	ldr	r1, [r0, #0]
 800169a:	2900      	cmp	r1, #0
 800169c:	d001      	beq.n	80016a2 <vPortFree+0x22>
 800169e:	b672      	cpsid	i
 80016a0:	e7fe      	b.n	80016a0 <vPortFree+0x20>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 80016a2:	4393      	bics	r3, r2
 80016a4:	6043      	str	r3, [r0, #4]
				vTaskSuspendAll();
 80016a6:	f000 fc51 	bl	8001f4c <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 80016aa:	4a06      	ldr	r2, [pc, #24]	; (80016c4 <vPortFree+0x44>)
 80016ac:	6863      	ldr	r3, [r4, #4]
 80016ae:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 80016b0:	0020      	movs	r0, r4
					xFreeBytesRemaining += pxLink->xBlockSize;
 80016b2:	185b      	adds	r3, r3, r1
 80016b4:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 80016b6:	f7ff ff3d 	bl	8001534 <prvInsertBlockIntoFreeList>
				( void ) xTaskResumeAll();
 80016ba:	f000 fcd3 	bl	8002064 <xTaskResumeAll>
}
 80016be:	bd10      	pop	{r4, pc}
 80016c0:	20001118 	.word	0x20001118
 80016c4:	2000111c 	.word	0x2000111c

080016c8 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 80016c8:	b570      	push	{r4, r5, r6, lr}
 80016ca:	0016      	movs	r6, r2

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 80016cc:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
 80016ce:	0004      	movs	r4, r0
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80016d0:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 80016d2:	2a00      	cmp	r2, #0
 80016d4:	d10a      	bne.n	80016ec <prvCopyDataToQueue+0x24>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80016d6:	6806      	ldr	r6, [r0, #0]
BaseType_t xReturn = pdFALSE;
 80016d8:	0010      	movs	r0, r2
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80016da:	2e00      	cmp	r6, #0
 80016dc:	d103      	bne.n	80016e6 <prvCopyDataToQueue+0x1e>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 80016de:	6860      	ldr	r0, [r4, #4]
 80016e0:	f000 fe9e 	bl	8002420 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 80016e4:	6066      	str	r6, [r4, #4]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 80016e6:	3501      	adds	r5, #1
 80016e8:	63a5      	str	r5, [r4, #56]	; 0x38

	return xReturn;
}
 80016ea:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
 80016ec:	2e00      	cmp	r6, #0
 80016ee:	d10d      	bne.n	800170c <prvCopyDataToQueue+0x44>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 80016f0:	6880      	ldr	r0, [r0, #8]
 80016f2:	f001 fe55 	bl	80033a0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 80016f6:	68a3      	ldr	r3, [r4, #8]
 80016f8:	6c22      	ldr	r2, [r4, #64]	; 0x40
BaseType_t xReturn = pdFALSE;
 80016fa:	0030      	movs	r0, r6
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 80016fc:	189b      	adds	r3, r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80016fe:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8001700:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8001702:	4293      	cmp	r3, r2
 8001704:	d3ef      	bcc.n	80016e6 <prvCopyDataToQueue+0x1e>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8001706:	6823      	ldr	r3, [r4, #0]
 8001708:	60a3      	str	r3, [r4, #8]
 800170a:	e7ec      	b.n	80016e6 <prvCopyDataToQueue+0x1e>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800170c:	68c0      	ldr	r0, [r0, #12]
 800170e:	f001 fe47 	bl	80033a0 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8001712:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8001714:	68e2      	ldr	r2, [r4, #12]
 8001716:	425b      	negs	r3, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8001718:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 800171a:	18d2      	adds	r2, r2, r3
 800171c:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800171e:	428a      	cmp	r2, r1
 8001720:	d202      	bcs.n	8001728 <prvCopyDataToQueue+0x60>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8001722:	6862      	ldr	r2, [r4, #4]
 8001724:	18d3      	adds	r3, r2, r3
 8001726:	60e3      	str	r3, [r4, #12]
BaseType_t xReturn = pdFALSE;
 8001728:	2000      	movs	r0, #0
		if( xPosition == queueOVERWRITE )
 800172a:	2e02      	cmp	r6, #2
 800172c:	d1db      	bne.n	80016e6 <prvCopyDataToQueue+0x1e>
				--uxMessagesWaiting;
 800172e:	002b      	movs	r3, r5
 8001730:	1e5a      	subs	r2, r3, #1
 8001732:	4193      	sbcs	r3, r2
 8001734:	1aed      	subs	r5, r5, r3
 8001736:	e7d6      	b.n	80016e6 <prvCopyDataToQueue+0x1e>

08001738 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 8001738:	0003      	movs	r3, r0
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800173a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
 800173c:	b510      	push	{r4, lr}
 800173e:	0008      	movs	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8001740:	2a00      	cmp	r2, #0
 8001742:	d00a      	beq.n	800175a <prvCopyDataFromQueue+0x22>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8001744:	68d9      	ldr	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8001746:	685c      	ldr	r4, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8001748:	1889      	adds	r1, r1, r2
 800174a:	60d9      	str	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800174c:	42a1      	cmp	r1, r4
 800174e:	d301      	bcc.n	8001754 <prvCopyDataFromQueue+0x1c>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8001750:	6819      	ldr	r1, [r3, #0]
 8001752:	60d9      	str	r1, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8001754:	68d9      	ldr	r1, [r3, #12]
 8001756:	f001 fe23 	bl	80033a0 <memcpy>
	}
}
 800175a:	bd10      	pop	{r4, pc}

0800175c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 800175c:	b570      	push	{r4, r5, r6, lr}
 800175e:	0005      	movs	r5, r0
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;
 8001760:	002e      	movs	r6, r5
 8001762:	3645      	adds	r6, #69	; 0x45
	taskENTER_CRITICAL();
 8001764:	f7ff fe5c 	bl	8001420 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8001768:	7834      	ldrb	r4, [r6, #0]
 800176a:	b264      	sxtb	r4, r4

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800176c:	2c00      	cmp	r4, #0
 800176e:	dc10      	bgt.n	8001792 <prvUnlockQueue+0x36>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 8001770:	23ff      	movs	r3, #255	; 0xff
 8001772:	7033      	strb	r3, [r6, #0]
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;
 8001774:	002e      	movs	r6, r5
 8001776:	3644      	adds	r6, #68	; 0x44
	taskEXIT_CRITICAL();
 8001778:	f7ff fe5e 	bl	8001438 <vPortExitCritical>
	taskENTER_CRITICAL();
 800177c:	f7ff fe50 	bl	8001420 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8001780:	7834      	ldrb	r4, [r6, #0]
 8001782:	b264      	sxtb	r4, r4

		while( cRxLock > queueLOCKED_UNMODIFIED )
 8001784:	2c00      	cmp	r4, #0
 8001786:	dc11      	bgt.n	80017ac <prvUnlockQueue+0x50>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 8001788:	23ff      	movs	r3, #255	; 0xff
 800178a:	7033      	strb	r3, [r6, #0]
	}
	taskEXIT_CRITICAL();
 800178c:	f7ff fe54 	bl	8001438 <vPortExitCritical>
}
 8001790:	bd70      	pop	{r4, r5, r6, pc}
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001792:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8001794:	2b00      	cmp	r3, #0
 8001796:	d0eb      	beq.n	8001770 <prvUnlockQueue+0x14>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001798:	0028      	movs	r0, r5
 800179a:	3024      	adds	r0, #36	; 0x24
 800179c:	f000 fd78 	bl	8002290 <xTaskRemoveFromEventList>
 80017a0:	2800      	cmp	r0, #0
 80017a2:	d001      	beq.n	80017a8 <prvUnlockQueue+0x4c>
						vTaskMissedYield();
 80017a4:	f000 fdf0 	bl	8002388 <vTaskMissedYield>
 80017a8:	3c01      	subs	r4, #1
 80017aa:	e7de      	b.n	800176a <prvUnlockQueue+0xe>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80017ac:	692b      	ldr	r3, [r5, #16]
 80017ae:	2b00      	cmp	r3, #0
 80017b0:	d0ea      	beq.n	8001788 <prvUnlockQueue+0x2c>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80017b2:	0028      	movs	r0, r5
 80017b4:	3010      	adds	r0, #16
 80017b6:	f000 fd6b 	bl	8002290 <xTaskRemoveFromEventList>
 80017ba:	2800      	cmp	r0, #0
 80017bc:	d001      	beq.n	80017c2 <prvUnlockQueue+0x66>
					vTaskMissedYield();
 80017be:	f000 fde3 	bl	8002388 <vTaskMissedYield>
 80017c2:	3c01      	subs	r4, #1
 80017c4:	e7dd      	b.n	8001782 <prvUnlockQueue+0x26>

080017c6 <xQueueGenericReset>:
{
 80017c6:	b570      	push	{r4, r5, r6, lr}
 80017c8:	0004      	movs	r4, r0
 80017ca:	000d      	movs	r5, r1
	configASSERT( pxQueue );
 80017cc:	2800      	cmp	r0, #0
 80017ce:	d101      	bne.n	80017d4 <xQueueGenericReset+0xe>
 80017d0:	b672      	cpsid	i
 80017d2:	e7fe      	b.n	80017d2 <xQueueGenericReset+0xc>
	taskENTER_CRITICAL();
 80017d4:	f7ff fe24 	bl	8001420 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 80017d8:	6c21      	ldr	r1, [r4, #64]	; 0x40
 80017da:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80017dc:	6822      	ldr	r2, [r4, #0]
 80017de:	434b      	muls	r3, r1
 80017e0:	18d0      	adds	r0, r2, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 80017e2:	1a5b      	subs	r3, r3, r1
 80017e4:	18d3      	adds	r3, r2, r3
 80017e6:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 80017e8:	0023      	movs	r3, r4
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 80017ea:	6060      	str	r0, [r4, #4]
		pxQueue->pcWriteTo = pxQueue->pcHead;
 80017ec:	60a2      	str	r2, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80017ee:	2000      	movs	r0, #0
		pxQueue->cRxLock = queueUNLOCKED;
 80017f0:	22ff      	movs	r2, #255	; 0xff
 80017f2:	3344      	adds	r3, #68	; 0x44
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80017f4:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
 80017f6:	701a      	strb	r2, [r3, #0]
		pxQueue->cTxLock = queueUNLOCKED;
 80017f8:	705a      	strb	r2, [r3, #1]
		if( xNewQueue == pdFALSE )
 80017fa:	4285      	cmp	r5, r0
 80017fc:	d10e      	bne.n	800181c <xQueueGenericReset+0x56>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80017fe:	6923      	ldr	r3, [r4, #16]
 8001800:	4283      	cmp	r3, r0
 8001802:	d007      	beq.n	8001814 <xQueueGenericReset+0x4e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001804:	0020      	movs	r0, r4
 8001806:	3010      	adds	r0, #16
 8001808:	f000 fd42 	bl	8002290 <xTaskRemoveFromEventList>
 800180c:	2800      	cmp	r0, #0
 800180e:	d001      	beq.n	8001814 <xQueueGenericReset+0x4e>
					queueYIELD_IF_USING_PREEMPTION();
 8001810:	f7ff fdfa 	bl	8001408 <vPortYield>
	taskEXIT_CRITICAL();
 8001814:	f7ff fe10 	bl	8001438 <vPortExitCritical>
}
 8001818:	2001      	movs	r0, #1
 800181a:	bd70      	pop	{r4, r5, r6, pc}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800181c:	0020      	movs	r0, r4
 800181e:	3010      	adds	r0, #16
 8001820:	f7ff fd7b 	bl	800131a <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8001824:	0020      	movs	r0, r4
 8001826:	3024      	adds	r0, #36	; 0x24
 8001828:	f7ff fd77 	bl	800131a <vListInitialise>
 800182c:	e7f2      	b.n	8001814 <xQueueGenericReset+0x4e>

0800182e <xQueueGenericCreate>:
	{
 800182e:	b570      	push	{r4, r5, r6, lr}
 8001830:	0006      	movs	r6, r0
 8001832:	000d      	movs	r5, r1
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8001834:	2800      	cmp	r0, #0
 8001836:	d101      	bne.n	800183c <xQueueGenericCreate+0xe>
 8001838:	b672      	cpsid	i
 800183a:	e7fe      	b.n	800183a <xQueueGenericCreate+0xc>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800183c:	0008      	movs	r0, r1
 800183e:	4370      	muls	r0, r6
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 8001840:	3048      	adds	r0, #72	; 0x48
 8001842:	f7ff fe9b 	bl	800157c <pvPortMalloc>
 8001846:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
 8001848:	d008      	beq.n	800185c <xQueueGenericCreate+0x2e>
	if( uxItemSize == ( UBaseType_t ) 0 )
 800184a:	2d00      	cmp	r5, #0
 800184c:	d108      	bne.n	8001860 <xQueueGenericCreate+0x32>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800184e:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
 8001850:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 8001852:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8001854:	2101      	movs	r1, #1
 8001856:	0020      	movs	r0, r4
 8001858:	f7ff ffb5 	bl	80017c6 <xQueueGenericReset>
	}
 800185c:	0020      	movs	r0, r4
 800185e:	bd70      	pop	{r4, r5, r6, pc}
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 8001860:	0003      	movs	r3, r0
 8001862:	3348      	adds	r3, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 8001864:	6003      	str	r3, [r0, #0]
 8001866:	e7f3      	b.n	8001850 <xQueueGenericCreate+0x22>

08001868 <xQueueGenericSend>:
{
 8001868:	b5f0      	push	{r4, r5, r6, r7, lr}
 800186a:	b085      	sub	sp, #20
 800186c:	0004      	movs	r4, r0
 800186e:	9100      	str	r1, [sp, #0]
 8001870:	9201      	str	r2, [sp, #4]
 8001872:	001d      	movs	r5, r3
	configASSERT( pxQueue );
 8001874:	2800      	cmp	r0, #0
 8001876:	d101      	bne.n	800187c <xQueueGenericSend+0x14>
 8001878:	b672      	cpsid	i
 800187a:	e7fe      	b.n	800187a <xQueueGenericSend+0x12>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800187c:	9b00      	ldr	r3, [sp, #0]
 800187e:	2b00      	cmp	r3, #0
 8001880:	d000      	beq.n	8001884 <xQueueGenericSend+0x1c>
 8001882:	e06f      	b.n	8001964 <xQueueGenericSend+0xfc>
 8001884:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001886:	2b00      	cmp	r3, #0
 8001888:	d100      	bne.n	800188c <xQueueGenericSend+0x24>
 800188a:	e06b      	b.n	8001964 <xQueueGenericSend+0xfc>
 800188c:	b672      	cpsid	i
 800188e:	e7fe      	b.n	800188e <xQueueGenericSend+0x26>
				if( xTicksToWait == ( TickType_t ) 0 )
 8001890:	9e01      	ldr	r6, [sp, #4]
 8001892:	2e00      	cmp	r6, #0
 8001894:	d103      	bne.n	800189e <xQueueGenericSend+0x36>
					taskEXIT_CRITICAL();
 8001896:	f7ff fdcf 	bl	8001438 <vPortExitCritical>
			return errQUEUE_FULL;
 800189a:	2000      	movs	r0, #0
 800189c:	e054      	b.n	8001948 <xQueueGenericSend+0xe0>
				else if( xEntryTimeSet == pdFALSE )
 800189e:	2f00      	cmp	r7, #0
 80018a0:	d102      	bne.n	80018a8 <xQueueGenericSend+0x40>
					vTaskSetTimeOutState( &xTimeOut );
 80018a2:	a802      	add	r0, sp, #8
 80018a4:	f000 fd30 	bl	8002308 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 80018a8:	f7ff fdc6 	bl	8001438 <vPortExitCritical>
		vTaskSuspendAll();
 80018ac:	f000 fb4e 	bl	8001f4c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80018b0:	f7ff fdb6 	bl	8001420 <vPortEnterCritical>
 80018b4:	0022      	movs	r2, r4
 80018b6:	3244      	adds	r2, #68	; 0x44
 80018b8:	7813      	ldrb	r3, [r2, #0]
 80018ba:	b25b      	sxtb	r3, r3
 80018bc:	3301      	adds	r3, #1
 80018be:	d101      	bne.n	80018c4 <xQueueGenericSend+0x5c>
 80018c0:	2300      	movs	r3, #0
 80018c2:	7013      	strb	r3, [r2, #0]
 80018c4:	0022      	movs	r2, r4
 80018c6:	3245      	adds	r2, #69	; 0x45
 80018c8:	7813      	ldrb	r3, [r2, #0]
 80018ca:	b25b      	sxtb	r3, r3
 80018cc:	3301      	adds	r3, #1
 80018ce:	d101      	bne.n	80018d4 <xQueueGenericSend+0x6c>
 80018d0:	2300      	movs	r3, #0
 80018d2:	7013      	strb	r3, [r2, #0]
 80018d4:	f7ff fdb0 	bl	8001438 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80018d8:	a901      	add	r1, sp, #4
 80018da:	a802      	add	r0, sp, #8
 80018dc:	f000 fd24 	bl	8002328 <xTaskCheckForTimeOut>
 80018e0:	2800      	cmp	r0, #0
 80018e2:	d139      	bne.n	8001958 <xQueueGenericSend+0xf0>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 80018e4:	f7ff fd9c 	bl	8001420 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 80018e8:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 80018ea:	6be6      	ldr	r6, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 80018ec:	f7ff fda4 	bl	8001438 <vPortExitCritical>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 80018f0:	42b7      	cmp	r7, r6
 80018f2:	d12b      	bne.n	800194c <xQueueGenericSend+0xe4>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 80018f4:	0020      	movs	r0, r4
 80018f6:	9901      	ldr	r1, [sp, #4]
 80018f8:	3010      	adds	r0, #16
 80018fa:	f000 fc9f 	bl	800223c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 80018fe:	0020      	movs	r0, r4
 8001900:	f7ff ff2c 	bl	800175c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8001904:	f000 fbae 	bl	8002064 <xTaskResumeAll>
 8001908:	2800      	cmp	r0, #0
 800190a:	d101      	bne.n	8001910 <xQueueGenericSend+0xa8>
					portYIELD_WITHIN_API();
 800190c:	f7ff fd7c 	bl	8001408 <vPortYield>
 8001910:	2701      	movs	r7, #1
		taskENTER_CRITICAL();
 8001912:	f7ff fd85 	bl	8001420 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8001916:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001918:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800191a:	4293      	cmp	r3, r2
 800191c:	d301      	bcc.n	8001922 <xQueueGenericSend+0xba>
 800191e:	2d02      	cmp	r5, #2
 8001920:	d1b6      	bne.n	8001890 <xQueueGenericSend+0x28>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8001922:	002a      	movs	r2, r5
 8001924:	9900      	ldr	r1, [sp, #0]
 8001926:	0020      	movs	r0, r4
 8001928:	f7ff fece 	bl	80016c8 <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800192c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800192e:	2b00      	cmp	r3, #0
 8001930:	d003      	beq.n	800193a <xQueueGenericSend+0xd2>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001932:	0020      	movs	r0, r4
 8001934:	3024      	adds	r0, #36	; 0x24
 8001936:	f000 fcab 	bl	8002290 <xTaskRemoveFromEventList>
 800193a:	2800      	cmp	r0, #0
 800193c:	d001      	beq.n	8001942 <xQueueGenericSend+0xda>
							queueYIELD_IF_USING_PREEMPTION();
 800193e:	f7ff fd63 	bl	8001408 <vPortYield>
				taskEXIT_CRITICAL();
 8001942:	f7ff fd79 	bl	8001438 <vPortExitCritical>
				return pdPASS;
 8001946:	2001      	movs	r0, #1
}
 8001948:	b005      	add	sp, #20
 800194a:	bdf0      	pop	{r4, r5, r6, r7, pc}
				prvUnlockQueue( pxQueue );
 800194c:	0020      	movs	r0, r4
 800194e:	f7ff ff05 	bl	800175c <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8001952:	f000 fb87 	bl	8002064 <xTaskResumeAll>
 8001956:	e7db      	b.n	8001910 <xQueueGenericSend+0xa8>
			prvUnlockQueue( pxQueue );
 8001958:	0020      	movs	r0, r4
 800195a:	f7ff feff 	bl	800175c <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800195e:	f000 fb81 	bl	8002064 <xTaskResumeAll>
 8001962:	e79a      	b.n	800189a <xQueueGenericSend+0x32>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8001964:	2d02      	cmp	r5, #2
 8001966:	d102      	bne.n	800196e <xQueueGenericSend+0x106>
 8001968:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800196a:	2b01      	cmp	r3, #1
 800196c:	d109      	bne.n	8001982 <xQueueGenericSend+0x11a>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800196e:	f000 fd11 	bl	8002394 <xTaskGetSchedulerState>
 8001972:	2700      	movs	r7, #0
 8001974:	2800      	cmp	r0, #0
 8001976:	d1cc      	bne.n	8001912 <xQueueGenericSend+0xaa>
 8001978:	9f01      	ldr	r7, [sp, #4]
 800197a:	2f00      	cmp	r7, #0
 800197c:	d0c9      	beq.n	8001912 <xQueueGenericSend+0xaa>
 800197e:	b672      	cpsid	i
 8001980:	e7fe      	b.n	8001980 <xQueueGenericSend+0x118>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8001982:	b672      	cpsid	i
 8001984:	e7fe      	b.n	8001984 <xQueueGenericSend+0x11c>

08001986 <xQueueGenericSendFromISR>:
{
 8001986:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001988:	b085      	sub	sp, #20
 800198a:	0004      	movs	r4, r0
 800198c:	9101      	str	r1, [sp, #4]
 800198e:	0017      	movs	r7, r2
 8001990:	001e      	movs	r6, r3
	configASSERT( pxQueue );
 8001992:	2800      	cmp	r0, #0
 8001994:	d101      	bne.n	800199a <xQueueGenericSendFromISR+0x14>
 8001996:	b672      	cpsid	i
 8001998:	e7fe      	b.n	8001998 <xQueueGenericSendFromISR+0x12>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800199a:	9b01      	ldr	r3, [sp, #4]
 800199c:	2b00      	cmp	r3, #0
 800199e:	d119      	bne.n	80019d4 <xQueueGenericSendFromISR+0x4e>
 80019a0:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80019a2:	2b00      	cmp	r3, #0
 80019a4:	d016      	beq.n	80019d4 <xQueueGenericSendFromISR+0x4e>
 80019a6:	b672      	cpsid	i
 80019a8:	e7fe      	b.n	80019a8 <xQueueGenericSendFromISR+0x22>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80019aa:	0020      	movs	r0, r4
 80019ac:	3024      	adds	r0, #36	; 0x24
 80019ae:	f000 fc6f 	bl	8002290 <xTaskRemoveFromEventList>
 80019b2:	2800      	cmp	r0, #0
 80019b4:	d02c      	beq.n	8001a10 <xQueueGenericSendFromISR+0x8a>
							if( pxHigherPriorityTaskWoken != NULL )
 80019b6:	2f00      	cmp	r7, #0
 80019b8:	d02a      	beq.n	8001a10 <xQueueGenericSendFromISR+0x8a>
								*pxHigherPriorityTaskWoken = pdTRUE;
 80019ba:	2501      	movs	r5, #1
 80019bc:	603d      	str	r5, [r7, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80019be:	9803      	ldr	r0, [sp, #12]
 80019c0:	f7ff fd4d 	bl	800145e <vClearInterruptMaskFromISR>
}
 80019c4:	0028      	movs	r0, r5
 80019c6:	b005      	add	sp, #20
 80019c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 80019ca:	3501      	adds	r5, #1
 80019cc:	9b02      	ldr	r3, [sp, #8]
 80019ce:	b26d      	sxtb	r5, r5
 80019d0:	701d      	strb	r5, [r3, #0]
 80019d2:	e01d      	b.n	8001a10 <xQueueGenericSendFromISR+0x8a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80019d4:	2e02      	cmp	r6, #2
 80019d6:	d102      	bne.n	80019de <xQueueGenericSendFromISR+0x58>
 80019d8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80019da:	2b01      	cmp	r3, #1
 80019dc:	d11a      	bne.n	8001a14 <xQueueGenericSendFromISR+0x8e>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80019de:	f7ff fd39 	bl	8001454 <ulSetInterruptMaskFromISR>
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80019e2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80019e4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80019e6:	9003      	str	r0, [sp, #12]
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80019e8:	4293      	cmp	r3, r2
 80019ea:	d302      	bcc.n	80019f2 <xQueueGenericSendFromISR+0x6c>
			xReturn = errQUEUE_FULL;
 80019ec:	2500      	movs	r5, #0
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80019ee:	2e02      	cmp	r6, #2
 80019f0:	d1e5      	bne.n	80019be <xQueueGenericSendFromISR+0x38>
			const int8_t cTxLock = pxQueue->cTxLock;
 80019f2:	0023      	movs	r3, r4
 80019f4:	3345      	adds	r3, #69	; 0x45
 80019f6:	9302      	str	r3, [sp, #8]
 80019f8:	781d      	ldrb	r5, [r3, #0]
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80019fa:	0032      	movs	r2, r6
			const int8_t cTxLock = pxQueue->cTxLock;
 80019fc:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80019fe:	9901      	ldr	r1, [sp, #4]
 8001a00:	0020      	movs	r0, r4
 8001a02:	f7ff fe61 	bl	80016c8 <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 8001a06:	1c6b      	adds	r3, r5, #1
 8001a08:	d1df      	bne.n	80019ca <xQueueGenericSendFromISR+0x44>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001a0a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001a0c:	2b00      	cmp	r3, #0
 8001a0e:	d1cc      	bne.n	80019aa <xQueueGenericSendFromISR+0x24>
			xReturn = pdPASS;
 8001a10:	2501      	movs	r5, #1
 8001a12:	e7d4      	b.n	80019be <xQueueGenericSendFromISR+0x38>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8001a14:	b672      	cpsid	i
 8001a16:	e7fe      	b.n	8001a16 <xQueueGenericSendFromISR+0x90>

08001a18 <xQueueGiveFromISR>:
{
 8001a18:	b570      	push	{r4, r5, r6, lr}
 8001a1a:	0004      	movs	r4, r0
 8001a1c:	000e      	movs	r6, r1
	configASSERT( pxQueue );
 8001a1e:	2800      	cmp	r0, #0
 8001a20:	d101      	bne.n	8001a26 <xQueueGiveFromISR+0xe>
 8001a22:	b672      	cpsid	i
 8001a24:	e7fe      	b.n	8001a24 <xQueueGiveFromISR+0xc>
	configASSERT( pxQueue->uxItemSize == 0 );
 8001a26:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001a28:	2b00      	cmp	r3, #0
 8001a2a:	d001      	beq.n	8001a30 <xQueueGiveFromISR+0x18>
 8001a2c:	b672      	cpsid	i
 8001a2e:	e7fe      	b.n	8001a2e <xQueueGiveFromISR+0x16>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 8001a30:	6803      	ldr	r3, [r0, #0]
 8001a32:	2b00      	cmp	r3, #0
 8001a34:	d102      	bne.n	8001a3c <xQueueGiveFromISR+0x24>
 8001a36:	6843      	ldr	r3, [r0, #4]
 8001a38:	2b00      	cmp	r3, #0
 8001a3a:	d128      	bne.n	8001a8e <xQueueGiveFromISR+0x76>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8001a3c:	f7ff fd0a 	bl	8001454 <ulSetInterruptMaskFromISR>
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8001a40:	6ba2      	ldr	r2, [r4, #56]	; 0x38
		if( uxMessagesWaiting < pxQueue->uxLength )
 8001a42:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8001a44:	0005      	movs	r5, r0
		if( uxMessagesWaiting < pxQueue->uxLength )
 8001a46:	429a      	cmp	r2, r3
 8001a48:	d301      	bcc.n	8001a4e <xQueueGiveFromISR+0x36>
			xReturn = errQUEUE_FULL;
 8001a4a:	2400      	movs	r4, #0
 8001a4c:	e016      	b.n	8001a7c <xQueueGiveFromISR+0x64>
			const int8_t cTxLock = pxQueue->cTxLock;
 8001a4e:	0021      	movs	r1, r4
 8001a50:	3145      	adds	r1, #69	; 0x45
 8001a52:	780b      	ldrb	r3, [r1, #0]
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 8001a54:	3201      	adds	r2, #1
			const int8_t cTxLock = pxQueue->cTxLock;
 8001a56:	b25b      	sxtb	r3, r3
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 8001a58:	63a2      	str	r2, [r4, #56]	; 0x38
			if( cTxLock == queueUNLOCKED )
 8001a5a:	1c5a      	adds	r2, r3, #1
 8001a5c:	d113      	bne.n	8001a86 <xQueueGiveFromISR+0x6e>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001a5e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001a60:	2b00      	cmp	r3, #0
 8001a62:	d101      	bne.n	8001a68 <xQueueGiveFromISR+0x50>
			xReturn = pdPASS;
 8001a64:	2401      	movs	r4, #1
 8001a66:	e009      	b.n	8001a7c <xQueueGiveFromISR+0x64>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001a68:	0020      	movs	r0, r4
 8001a6a:	3024      	adds	r0, #36	; 0x24
 8001a6c:	f000 fc10 	bl	8002290 <xTaskRemoveFromEventList>
 8001a70:	2800      	cmp	r0, #0
 8001a72:	d0f7      	beq.n	8001a64 <xQueueGiveFromISR+0x4c>
							if( pxHigherPriorityTaskWoken != NULL )
 8001a74:	2e00      	cmp	r6, #0
 8001a76:	d0f5      	beq.n	8001a64 <xQueueGiveFromISR+0x4c>
								*pxHigherPriorityTaskWoken = pdTRUE;
 8001a78:	2401      	movs	r4, #1
 8001a7a:	6034      	str	r4, [r6, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8001a7c:	0028      	movs	r0, r5
 8001a7e:	f7ff fcee 	bl	800145e <vClearInterruptMaskFromISR>
}
 8001a82:	0020      	movs	r0, r4
 8001a84:	bd70      	pop	{r4, r5, r6, pc}
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8001a86:	3301      	adds	r3, #1
 8001a88:	b25b      	sxtb	r3, r3
 8001a8a:	700b      	strb	r3, [r1, #0]
 8001a8c:	e7ea      	b.n	8001a64 <xQueueGiveFromISR+0x4c>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 8001a8e:	b672      	cpsid	i
 8001a90:	e7fe      	b.n	8001a90 <xQueueGiveFromISR+0x78>

08001a92 <xQueueGenericReceive>:
{
 8001a92:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001a94:	b085      	sub	sp, #20
 8001a96:	0004      	movs	r4, r0
 8001a98:	000f      	movs	r7, r1
 8001a9a:	9201      	str	r2, [sp, #4]
 8001a9c:	9300      	str	r3, [sp, #0]
	configASSERT( pxQueue );
 8001a9e:	2800      	cmp	r0, #0
 8001aa0:	d101      	bne.n	8001aa6 <xQueueGenericReceive+0x14>
 8001aa2:	b672      	cpsid	i
 8001aa4:	e7fe      	b.n	8001aa4 <xQueueGenericReceive+0x12>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8001aa6:	2900      	cmp	r1, #0
 8001aa8:	d000      	beq.n	8001aac <xQueueGenericReceive+0x1a>
 8001aaa:	e08e      	b.n	8001bca <xQueueGenericReceive+0x138>
 8001aac:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001aae:	2b00      	cmp	r3, #0
 8001ab0:	d100      	bne.n	8001ab4 <xQueueGenericReceive+0x22>
 8001ab2:	e08a      	b.n	8001bca <xQueueGenericReceive+0x138>
 8001ab4:	b672      	cpsid	i
 8001ab6:	e7fe      	b.n	8001ab6 <xQueueGenericReceive+0x24>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001ab8:	6a63      	ldr	r3, [r4, #36]	; 0x24
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 8001aba:	60e6      	str	r6, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001abc:	2b00      	cmp	r3, #0
 8001abe:	d06c      	beq.n	8001b9a <xQueueGenericReceive+0x108>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001ac0:	0020      	movs	r0, r4
 8001ac2:	3024      	adds	r0, #36	; 0x24
 8001ac4:	e063      	b.n	8001b8e <xQueueGenericReceive+0xfc>
				if( xTicksToWait == ( TickType_t ) 0 )
 8001ac6:	9d01      	ldr	r5, [sp, #4]
 8001ac8:	2d00      	cmp	r5, #0
 8001aca:	d103      	bne.n	8001ad4 <xQueueGenericReceive+0x42>
					taskEXIT_CRITICAL();
 8001acc:	f7ff fcb4 	bl	8001438 <vPortExitCritical>
				return errQUEUE_EMPTY;
 8001ad0:	0028      	movs	r0, r5
 8001ad2:	e065      	b.n	8001ba0 <xQueueGenericReceive+0x10e>
				else if( xEntryTimeSet == pdFALSE )
 8001ad4:	2e00      	cmp	r6, #0
 8001ad6:	d102      	bne.n	8001ade <xQueueGenericReceive+0x4c>
					vTaskSetTimeOutState( &xTimeOut );
 8001ad8:	a802      	add	r0, sp, #8
 8001ada:	f000 fc15 	bl	8002308 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 8001ade:	f7ff fcab 	bl	8001438 <vPortExitCritical>
		vTaskSuspendAll();
 8001ae2:	f000 fa33 	bl	8001f4c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8001ae6:	f7ff fc9b 	bl	8001420 <vPortEnterCritical>
 8001aea:	0022      	movs	r2, r4
 8001aec:	3244      	adds	r2, #68	; 0x44
 8001aee:	7813      	ldrb	r3, [r2, #0]
 8001af0:	b25b      	sxtb	r3, r3
 8001af2:	3301      	adds	r3, #1
 8001af4:	d101      	bne.n	8001afa <xQueueGenericReceive+0x68>
 8001af6:	2300      	movs	r3, #0
 8001af8:	7013      	strb	r3, [r2, #0]
 8001afa:	0022      	movs	r2, r4
 8001afc:	3245      	adds	r2, #69	; 0x45
 8001afe:	7813      	ldrb	r3, [r2, #0]
 8001b00:	b25b      	sxtb	r3, r3
 8001b02:	3301      	adds	r3, #1
 8001b04:	d101      	bne.n	8001b0a <xQueueGenericReceive+0x78>
 8001b06:	2300      	movs	r3, #0
 8001b08:	7013      	strb	r3, [r2, #0]
 8001b0a:	f7ff fc95 	bl	8001438 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8001b0e:	a901      	add	r1, sp, #4
 8001b10:	a802      	add	r0, sp, #8
 8001b12:	f000 fc09 	bl	8002328 <xTaskCheckForTimeOut>
 8001b16:	2800      	cmp	r0, #0
 8001b18:	d14a      	bne.n	8001bb0 <xQueueGenericReceive+0x11e>
	taskENTER_CRITICAL();
 8001b1a:	f7ff fc81 	bl	8001420 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8001b1e:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 8001b20:	f7ff fc8a 	bl	8001438 <vPortExitCritical>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8001b24:	2d00      	cmp	r5, #0
 8001b26:	d13d      	bne.n	8001ba4 <xQueueGenericReceive+0x112>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8001b28:	6823      	ldr	r3, [r4, #0]
 8001b2a:	2b00      	cmp	r3, #0
 8001b2c:	d106      	bne.n	8001b3c <xQueueGenericReceive+0xaa>
						taskENTER_CRITICAL();
 8001b2e:	f7ff fc77 	bl	8001420 <vPortEnterCritical>
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 8001b32:	6860      	ldr	r0, [r4, #4]
 8001b34:	f000 fc3e 	bl	80023b4 <vTaskPriorityInherit>
						taskEXIT_CRITICAL();
 8001b38:	f7ff fc7e 	bl	8001438 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8001b3c:	0020      	movs	r0, r4
 8001b3e:	9901      	ldr	r1, [sp, #4]
 8001b40:	3024      	adds	r0, #36	; 0x24
 8001b42:	f000 fb7b 	bl	800223c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8001b46:	0020      	movs	r0, r4
 8001b48:	f7ff fe08 	bl	800175c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8001b4c:	f000 fa8a 	bl	8002064 <xTaskResumeAll>
 8001b50:	2800      	cmp	r0, #0
 8001b52:	d101      	bne.n	8001b58 <xQueueGenericReceive+0xc6>
					portYIELD_WITHIN_API();
 8001b54:	f7ff fc58 	bl	8001408 <vPortYield>
 8001b58:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
 8001b5a:	f7ff fc61 	bl	8001420 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8001b5e:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8001b60:	2d00      	cmp	r5, #0
 8001b62:	d0b0      	beq.n	8001ac6 <xQueueGenericReceive+0x34>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8001b64:	0039      	movs	r1, r7
 8001b66:	0020      	movs	r0, r4
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 8001b68:	68e6      	ldr	r6, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8001b6a:	f7ff fde5 	bl	8001738 <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
 8001b6e:	9b00      	ldr	r3, [sp, #0]
 8001b70:	2b00      	cmp	r3, #0
 8001b72:	d1a1      	bne.n	8001ab8 <xQueueGenericReceive+0x26>
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8001b74:	6823      	ldr	r3, [r4, #0]
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 8001b76:	3d01      	subs	r5, #1
 8001b78:	63a5      	str	r5, [r4, #56]	; 0x38
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8001b7a:	2b00      	cmp	r3, #0
 8001b7c:	d102      	bne.n	8001b84 <xQueueGenericReceive+0xf2>
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 8001b7e:	f000 fc85 	bl	800248c <pvTaskIncrementMutexHeldCount>
 8001b82:	6060      	str	r0, [r4, #4]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001b84:	6923      	ldr	r3, [r4, #16]
 8001b86:	2b00      	cmp	r3, #0
 8001b88:	d007      	beq.n	8001b9a <xQueueGenericReceive+0x108>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001b8a:	0020      	movs	r0, r4
 8001b8c:	3010      	adds	r0, #16
 8001b8e:	f000 fb7f 	bl	8002290 <xTaskRemoveFromEventList>
 8001b92:	2800      	cmp	r0, #0
 8001b94:	d001      	beq.n	8001b9a <xQueueGenericReceive+0x108>
							queueYIELD_IF_USING_PREEMPTION();
 8001b96:	f7ff fc37 	bl	8001408 <vPortYield>
				taskEXIT_CRITICAL();
 8001b9a:	f7ff fc4d 	bl	8001438 <vPortExitCritical>
				return pdPASS;
 8001b9e:	2001      	movs	r0, #1
}
 8001ba0:	b005      	add	sp, #20
 8001ba2:	bdf0      	pop	{r4, r5, r6, r7, pc}
				prvUnlockQueue( pxQueue );
 8001ba4:	0020      	movs	r0, r4
 8001ba6:	f7ff fdd9 	bl	800175c <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8001baa:	f000 fa5b 	bl	8002064 <xTaskResumeAll>
 8001bae:	e7d3      	b.n	8001b58 <xQueueGenericReceive+0xc6>
			prvUnlockQueue( pxQueue );
 8001bb0:	0020      	movs	r0, r4
 8001bb2:	f7ff fdd3 	bl	800175c <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8001bb6:	f000 fa55 	bl	8002064 <xTaskResumeAll>
	taskENTER_CRITICAL();
 8001bba:	f7ff fc31 	bl	8001420 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8001bbe:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 8001bc0:	f7ff fc3a 	bl	8001438 <vPortExitCritical>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8001bc4:	2d00      	cmp	r5, #0
 8001bc6:	d1c7      	bne.n	8001b58 <xQueueGenericReceive+0xc6>
 8001bc8:	e782      	b.n	8001ad0 <xQueueGenericReceive+0x3e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8001bca:	f000 fbe3 	bl	8002394 <xTaskGetSchedulerState>
 8001bce:	2600      	movs	r6, #0
 8001bd0:	2800      	cmp	r0, #0
 8001bd2:	d1c2      	bne.n	8001b5a <xQueueGenericReceive+0xc8>
 8001bd4:	9e01      	ldr	r6, [sp, #4]
 8001bd6:	2e00      	cmp	r6, #0
 8001bd8:	d0bf      	beq.n	8001b5a <xQueueGenericReceive+0xc8>
 8001bda:	b672      	cpsid	i
 8001bdc:	e7fe      	b.n	8001bdc <xQueueGenericReceive+0x14a>

08001bde <xQueueReceiveFromISR>:
{
 8001bde:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001be0:	0005      	movs	r5, r0
 8001be2:	b085      	sub	sp, #20
 8001be4:	000f      	movs	r7, r1
 8001be6:	0016      	movs	r6, r2
	configASSERT( pxQueue );
 8001be8:	2800      	cmp	r0, #0
 8001bea:	d101      	bne.n	8001bf0 <xQueueReceiveFromISR+0x12>
 8001bec:	b672      	cpsid	i
 8001bee:	e7fe      	b.n	8001bee <xQueueReceiveFromISR+0x10>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8001bf0:	2900      	cmp	r1, #0
 8001bf2:	d11a      	bne.n	8001c2a <xQueueReceiveFromISR+0x4c>
 8001bf4:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001bf6:	2b00      	cmp	r3, #0
 8001bf8:	d017      	beq.n	8001c2a <xQueueReceiveFromISR+0x4c>
 8001bfa:	b672      	cpsid	i
 8001bfc:	e7fe      	b.n	8001bfc <xQueueReceiveFromISR+0x1e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001bfe:	0028      	movs	r0, r5
 8001c00:	3010      	adds	r0, #16
 8001c02:	f000 fb45 	bl	8002290 <xTaskRemoveFromEventList>
 8001c06:	2800      	cmp	r0, #0
 8001c08:	d027      	beq.n	8001c5a <xQueueReceiveFromISR+0x7c>
						if( pxHigherPriorityTaskWoken != NULL )
 8001c0a:	2e00      	cmp	r6, #0
 8001c0c:	d025      	beq.n	8001c5a <xQueueReceiveFromISR+0x7c>
							*pxHigherPriorityTaskWoken = pdTRUE;
 8001c0e:	2401      	movs	r4, #1
 8001c10:	6034      	str	r4, [r6, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8001c12:	9803      	ldr	r0, [sp, #12]
 8001c14:	f7ff fc23 	bl	800145e <vClearInterruptMaskFromISR>
}
 8001c18:	0020      	movs	r0, r4
 8001c1a:	b005      	add	sp, #20
 8001c1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 8001c1e:	9b01      	ldr	r3, [sp, #4]
 8001c20:	9a02      	ldr	r2, [sp, #8]
 8001c22:	3301      	adds	r3, #1
 8001c24:	b25b      	sxtb	r3, r3
 8001c26:	7013      	strb	r3, [r2, #0]
 8001c28:	e017      	b.n	8001c5a <xQueueReceiveFromISR+0x7c>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8001c2a:	f7ff fc13 	bl	8001454 <ulSetInterruptMaskFromISR>
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8001c2e:	6bac      	ldr	r4, [r5, #56]	; 0x38
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8001c30:	9003      	str	r0, [sp, #12]
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8001c32:	2c00      	cmp	r4, #0
 8001c34:	d0ed      	beq.n	8001c12 <xQueueReceiveFromISR+0x34>
			const int8_t cRxLock = pxQueue->cRxLock;
 8001c36:	002b      	movs	r3, r5
 8001c38:	3344      	adds	r3, #68	; 0x44
 8001c3a:	9302      	str	r3, [sp, #8]
 8001c3c:	781b      	ldrb	r3, [r3, #0]
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 8001c3e:	0039      	movs	r1, r7
			const int8_t cRxLock = pxQueue->cRxLock;
 8001c40:	b25b      	sxtb	r3, r3
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 8001c42:	0028      	movs	r0, r5
			const int8_t cRxLock = pxQueue->cRxLock;
 8001c44:	9301      	str	r3, [sp, #4]
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 8001c46:	f7ff fd77 	bl	8001738 <prvCopyDataFromQueue>
			if( cRxLock == queueUNLOCKED )
 8001c4a:	9b01      	ldr	r3, [sp, #4]
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 8001c4c:	3c01      	subs	r4, #1
 8001c4e:	63ac      	str	r4, [r5, #56]	; 0x38
			if( cRxLock == queueUNLOCKED )
 8001c50:	3301      	adds	r3, #1
 8001c52:	d1e4      	bne.n	8001c1e <xQueueReceiveFromISR+0x40>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001c54:	692b      	ldr	r3, [r5, #16]
 8001c56:	2b00      	cmp	r3, #0
 8001c58:	d1d1      	bne.n	8001bfe <xQueueReceiveFromISR+0x20>
			xReturn = pdPASS;
 8001c5a:	2401      	movs	r4, #1
 8001c5c:	e7d9      	b.n	8001c12 <xQueueReceiveFromISR+0x34>
	...

08001c60 <vQueueAddToRegistry>:
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001c60:	2300      	movs	r3, #0
	{
 8001c62:	b570      	push	{r4, r5, r6, lr}
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 8001c64:	4a06      	ldr	r2, [pc, #24]	; (8001c80 <vQueueAddToRegistry+0x20>)
 8001c66:	00dd      	lsls	r5, r3, #3
 8001c68:	18ac      	adds	r4, r5, r2
 8001c6a:	6826      	ldr	r6, [r4, #0]
 8001c6c:	2e00      	cmp	r6, #0
 8001c6e:	d102      	bne.n	8001c76 <vQueueAddToRegistry+0x16>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 8001c70:	50a9      	str	r1, [r5, r2]
				xQueueRegistry[ ux ].xHandle = xQueue;
 8001c72:	6060      	str	r0, [r4, #4]
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 8001c74:	bd70      	pop	{r4, r5, r6, pc}
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001c76:	3301      	adds	r3, #1
 8001c78:	2b08      	cmp	r3, #8
 8001c7a:	d1f4      	bne.n	8001c66 <vQueueAddToRegistry+0x6>
 8001c7c:	e7fa      	b.n	8001c74 <vQueueAddToRegistry+0x14>
 8001c7e:	46c0      	nop			; (mov r8, r8)
 8001c80:	200012a8 	.word	0x200012a8

08001c84 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 8001c84:	b570      	push	{r4, r5, r6, lr}
 8001c86:	0004      	movs	r4, r0
 8001c88:	0016      	movs	r6, r2
 8001c8a:	000d      	movs	r5, r1
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 8001c8c:	f7ff fbc8 	bl	8001420 <vPortEnterCritical>
 8001c90:	0022      	movs	r2, r4
 8001c92:	3244      	adds	r2, #68	; 0x44
 8001c94:	7813      	ldrb	r3, [r2, #0]
 8001c96:	b25b      	sxtb	r3, r3
 8001c98:	3301      	adds	r3, #1
 8001c9a:	d101      	bne.n	8001ca0 <vQueueWaitForMessageRestricted+0x1c>
 8001c9c:	2300      	movs	r3, #0
 8001c9e:	7013      	strb	r3, [r2, #0]
 8001ca0:	0022      	movs	r2, r4
 8001ca2:	3245      	adds	r2, #69	; 0x45
 8001ca4:	7813      	ldrb	r3, [r2, #0]
 8001ca6:	b25b      	sxtb	r3, r3
 8001ca8:	3301      	adds	r3, #1
 8001caa:	d101      	bne.n	8001cb0 <vQueueWaitForMessageRestricted+0x2c>
 8001cac:	2300      	movs	r3, #0
 8001cae:	7013      	strb	r3, [r2, #0]
 8001cb0:	f7ff fbc2 	bl	8001438 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 8001cb4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001cb6:	2b00      	cmp	r3, #0
 8001cb8:	d105      	bne.n	8001cc6 <vQueueWaitForMessageRestricted+0x42>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 8001cba:	0020      	movs	r0, r4
 8001cbc:	0032      	movs	r2, r6
 8001cbe:	0029      	movs	r1, r5
 8001cc0:	3024      	adds	r0, #36	; 0x24
 8001cc2:	f000 facd 	bl	8002260 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 8001cc6:	0020      	movs	r0, r4
 8001cc8:	f7ff fd48 	bl	800175c <prvUnlockQueue>
	}
 8001ccc:	bd70      	pop	{r4, r5, r6, pc}
	...

08001cd0 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001cd0:	4a07      	ldr	r2, [pc, #28]	; (8001cf0 <prvResetNextTaskUnblockTime+0x20>)
 8001cd2:	6813      	ldr	r3, [r2, #0]
 8001cd4:	6819      	ldr	r1, [r3, #0]
 8001cd6:	4b07      	ldr	r3, [pc, #28]	; (8001cf4 <prvResetNextTaskUnblockTime+0x24>)
 8001cd8:	2900      	cmp	r1, #0
 8001cda:	d103      	bne.n	8001ce4 <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8001cdc:	2201      	movs	r2, #1
 8001cde:	4252      	negs	r2, r2
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8001ce0:	601a      	str	r2, [r3, #0]
	}
}
 8001ce2:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8001ce4:	6812      	ldr	r2, [r2, #0]
 8001ce6:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8001ce8:	68d2      	ldr	r2, [r2, #12]
 8001cea:	6852      	ldr	r2, [r2, #4]
 8001cec:	e7f8      	b.n	8001ce0 <prvResetNextTaskUnblockTime+0x10>
 8001cee:	46c0      	nop			; (mov r8, r8)
 8001cf0:	20001130 	.word	0x20001130
 8001cf4:	20001208 	.word	0x20001208

08001cf8 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8001cf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001cfa:	0004      	movs	r4, r0
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8001cfc:	4b14      	ldr	r3, [pc, #80]	; (8001d50 <prvAddCurrentTaskToDelayedList+0x58>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8001cfe:	4d15      	ldr	r5, [pc, #84]	; (8001d54 <prvAddCurrentTaskToDelayedList+0x5c>)
const TickType_t xConstTickCount = xTickCount;
 8001d00:	681e      	ldr	r6, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8001d02:	6828      	ldr	r0, [r5, #0]
{
 8001d04:	000f      	movs	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8001d06:	3004      	adds	r0, #4
 8001d08:	f7ff fb38 	bl	800137c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8001d0c:	1c63      	adds	r3, r4, #1
 8001d0e:	d107      	bne.n	8001d20 <prvAddCurrentTaskToDelayedList+0x28>
 8001d10:	2f00      	cmp	r7, #0
 8001d12:	d005      	beq.n	8001d20 <prvAddCurrentTaskToDelayedList+0x28>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001d14:	6829      	ldr	r1, [r5, #0]
 8001d16:	4810      	ldr	r0, [pc, #64]	; (8001d58 <prvAddCurrentTaskToDelayedList+0x60>)
 8001d18:	3104      	adds	r1, #4
 8001d1a:	f7ff fb0c 	bl	8001336 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8001d1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8001d20:	682b      	ldr	r3, [r5, #0]
			xTimeToWake = xConstTickCount + xTicksToWait;
 8001d22:	1934      	adds	r4, r6, r4
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8001d24:	605c      	str	r4, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 8001d26:	42a6      	cmp	r6, r4
 8001d28:	d906      	bls.n	8001d38 <prvAddCurrentTaskToDelayedList+0x40>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001d2a:	4b0c      	ldr	r3, [pc, #48]	; (8001d5c <prvAddCurrentTaskToDelayedList+0x64>)
 8001d2c:	6818      	ldr	r0, [r3, #0]
 8001d2e:	6829      	ldr	r1, [r5, #0]
 8001d30:	3104      	adds	r1, #4
 8001d32:	f7ff fb0c 	bl	800134e <vListInsert>
 8001d36:	e7f2      	b.n	8001d1e <prvAddCurrentTaskToDelayedList+0x26>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001d38:	4b09      	ldr	r3, [pc, #36]	; (8001d60 <prvAddCurrentTaskToDelayedList+0x68>)
 8001d3a:	6818      	ldr	r0, [r3, #0]
 8001d3c:	6829      	ldr	r1, [r5, #0]
 8001d3e:	3104      	adds	r1, #4
 8001d40:	f7ff fb05 	bl	800134e <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8001d44:	4b07      	ldr	r3, [pc, #28]	; (8001d64 <prvAddCurrentTaskToDelayedList+0x6c>)
 8001d46:	681a      	ldr	r2, [r3, #0]
 8001d48:	4294      	cmp	r4, r2
 8001d4a:	d2e8      	bcs.n	8001d1e <prvAddCurrentTaskToDelayedList+0x26>
					xNextTaskUnblockTime = xTimeToWake;
 8001d4c:	601c      	str	r4, [r3, #0]
}
 8001d4e:	e7e6      	b.n	8001d1e <prvAddCurrentTaskToDelayedList+0x26>
 8001d50:	20001250 	.word	0x20001250
 8001d54:	2000112c 	.word	0x2000112c
 8001d58:	20001228 	.word	0x20001228
 8001d5c:	20001134 	.word	0x20001134
 8001d60:	20001130 	.word	0x20001130
 8001d64:	20001208 	.word	0x20001208

08001d68 <xTaskCreate>:
	{
 8001d68:	b5f0      	push	{r4, r5, r6, r7, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001d6a:	0095      	lsls	r5, r2, #2
	{
 8001d6c:	b085      	sub	sp, #20
 8001d6e:	9002      	str	r0, [sp, #8]
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001d70:	0028      	movs	r0, r5
	{
 8001d72:	000f      	movs	r7, r1
 8001d74:	9303      	str	r3, [sp, #12]
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001d76:	f7ff fc01 	bl	800157c <pvPortMalloc>
 8001d7a:	1e06      	subs	r6, r0, #0
			if( pxStack != NULL )
 8001d7c:	d100      	bne.n	8001d80 <xTaskCreate+0x18>
 8001d7e:	e08e      	b.n	8001e9e <xTaskCreate+0x136>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 8001d80:	2054      	movs	r0, #84	; 0x54
 8001d82:	f7ff fbfb 	bl	800157c <pvPortMalloc>
 8001d86:	1e04      	subs	r4, r0, #0
				if( pxNewTCB != NULL )
 8001d88:	d100      	bne.n	8001d8c <xTaskCreate+0x24>
 8001d8a:	e085      	b.n	8001e98 <xTaskCreate+0x130>
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8001d8c:	2307      	movs	r3, #7
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8001d8e:	3d04      	subs	r5, #4
					pxNewTCB->pxStack = pxStack;
 8001d90:	6306      	str	r6, [r0, #48]	; 0x30
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8001d92:	1976      	adds	r6, r6, r5
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8001d94:	439e      	bics	r6, r3
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8001d96:	2300      	movs	r3, #0
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8001d98:	9600      	str	r6, [sp, #0]
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8001d9a:	001a      	movs	r2, r3
 8001d9c:	5cf9      	ldrb	r1, [r7, r3]
 8001d9e:	3234      	adds	r2, #52	; 0x34
 8001da0:	54a1      	strb	r1, [r4, r2]
		if( pcName[ x ] == 0x00 )
 8001da2:	5cfa      	ldrb	r2, [r7, r3]
 8001da4:	2a00      	cmp	r2, #0
 8001da6:	d002      	beq.n	8001dae <xTaskCreate+0x46>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8001da8:	3301      	adds	r3, #1
 8001daa:	2b10      	cmp	r3, #16
 8001dac:	d1f5      	bne.n	8001d9a <xTaskCreate+0x32>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8001dae:	0023      	movs	r3, r4
 8001db0:	2500      	movs	r5, #0
 8001db2:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 8001db4:	3343      	adds	r3, #67	; 0x43
 8001db6:	701d      	strb	r5, [r3, #0]
 8001db8:	2e06      	cmp	r6, #6
 8001dba:	d900      	bls.n	8001dbe <xTaskCreate+0x56>
 8001dbc:	2606      	movs	r6, #6
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8001dbe:	1d23      	adds	r3, r4, #4
 8001dc0:	0018      	movs	r0, r3
	pxNewTCB->uxPriority = uxPriority;
 8001dc2:	62e6      	str	r6, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 8001dc4:	6466      	str	r6, [r4, #68]	; 0x44
		pxNewTCB->uxMutexesHeld = 0;
 8001dc6:	64a5      	str	r5, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8001dc8:	9301      	str	r3, [sp, #4]
 8001dca:	f7ff fab1 	bl	8001330 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8001dce:	0020      	movs	r0, r4
 8001dd0:	3018      	adds	r0, #24
 8001dd2:	f7ff faad 	bl	8001330 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001dd6:	2307      	movs	r3, #7
 8001dd8:	1b9e      	subs	r6, r3, r6
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8001dda:	0023      	movs	r3, r4
 8001ddc:	3350      	adds	r3, #80	; 0x50
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8001dde:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001de0:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8001de2:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
 8001de4:	64e5      	str	r5, [r4, #76]	; 0x4c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8001de6:	9a03      	ldr	r2, [sp, #12]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8001de8:	701d      	strb	r5, [r3, #0]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8001dea:	9902      	ldr	r1, [sp, #8]
 8001dec:	9800      	ldr	r0, [sp, #0]
 8001dee:	f7ff faf9 	bl	80013e4 <pxPortInitialiseStack>
	if( ( void * ) pxCreatedTask != NULL )
 8001df2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8001df4:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 8001df6:	2b00      	cmp	r3, #0
 8001df8:	d000      	beq.n	8001dfc <xTaskCreate+0x94>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8001dfa:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
 8001dfc:	f7ff fb10 	bl	8001420 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8001e00:	4b2e      	ldr	r3, [pc, #184]	; (8001ebc <xTaskCreate+0x154>)
		if( pxCurrentTCB == NULL )
 8001e02:	4d2f      	ldr	r5, [pc, #188]	; (8001ec0 <xTaskCreate+0x158>)
		uxCurrentNumberOfTasks++;
 8001e04:	681a      	ldr	r2, [r3, #0]
 8001e06:	3201      	adds	r2, #1
 8001e08:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
 8001e0a:	682a      	ldr	r2, [r5, #0]
 8001e0c:	2a00      	cmp	r2, #0
 8001e0e:	d149      	bne.n	8001ea4 <xTaskCreate+0x13c>
			pxCurrentTCB = pxNewTCB;
 8001e10:	602c      	str	r4, [r5, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8001e12:	681b      	ldr	r3, [r3, #0]
 8001e14:	2b01      	cmp	r3, #1
 8001e16:	d11d      	bne.n	8001e54 <xTaskCreate+0xec>
 8001e18:	4e2a      	ldr	r6, [pc, #168]	; (8001ec4 <xTaskCreate+0x15c>)
 8001e1a:	0037      	movs	r7, r6
 8001e1c:	378c      	adds	r7, #140	; 0x8c
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8001e1e:	0030      	movs	r0, r6
 8001e20:	3614      	adds	r6, #20
 8001e22:	f7ff fa7a 	bl	800131a <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8001e26:	42b7      	cmp	r7, r6
 8001e28:	d1f9      	bne.n	8001e1e <xTaskCreate+0xb6>
	vListInitialise( &xDelayedTaskList1 );
 8001e2a:	4e27      	ldr	r6, [pc, #156]	; (8001ec8 <xTaskCreate+0x160>)
 8001e2c:	0030      	movs	r0, r6
 8001e2e:	f7ff fa74 	bl	800131a <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8001e32:	4f26      	ldr	r7, [pc, #152]	; (8001ecc <xTaskCreate+0x164>)
 8001e34:	0038      	movs	r0, r7
 8001e36:	f7ff fa70 	bl	800131a <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8001e3a:	4825      	ldr	r0, [pc, #148]	; (8001ed0 <xTaskCreate+0x168>)
 8001e3c:	f7ff fa6d 	bl	800131a <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8001e40:	4824      	ldr	r0, [pc, #144]	; (8001ed4 <xTaskCreate+0x16c>)
 8001e42:	f7ff fa6a 	bl	800131a <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 8001e46:	4824      	ldr	r0, [pc, #144]	; (8001ed8 <xTaskCreate+0x170>)
 8001e48:	f7ff fa67 	bl	800131a <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8001e4c:	4b23      	ldr	r3, [pc, #140]	; (8001edc <xTaskCreate+0x174>)
 8001e4e:	601e      	str	r6, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8001e50:	4b23      	ldr	r3, [pc, #140]	; (8001ee0 <xTaskCreate+0x178>)
 8001e52:	601f      	str	r7, [r3, #0]
		uxTaskNumber++;
 8001e54:	4a23      	ldr	r2, [pc, #140]	; (8001ee4 <xTaskCreate+0x17c>)
 8001e56:	6813      	ldr	r3, [r2, #0]
 8001e58:	3301      	adds	r3, #1
 8001e5a:	6013      	str	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8001e5c:	4a22      	ldr	r2, [pc, #136]	; (8001ee8 <xTaskCreate+0x180>)
 8001e5e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001e60:	6811      	ldr	r1, [r2, #0]
 8001e62:	428b      	cmp	r3, r1
 8001e64:	d900      	bls.n	8001e68 <xTaskCreate+0x100>
 8001e66:	6013      	str	r3, [r2, #0]
 8001e68:	2014      	movs	r0, #20
 8001e6a:	4358      	muls	r0, r3
 8001e6c:	4b15      	ldr	r3, [pc, #84]	; (8001ec4 <xTaskCreate+0x15c>)
 8001e6e:	9901      	ldr	r1, [sp, #4]
 8001e70:	1818      	adds	r0, r3, r0
 8001e72:	f7ff fa60 	bl	8001336 <vListInsertEnd>
	taskEXIT_CRITICAL();
 8001e76:	f7ff fadf 	bl	8001438 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8001e7a:	4b1c      	ldr	r3, [pc, #112]	; (8001eec <xTaskCreate+0x184>)
			xReturn = pdPASS;
 8001e7c:	2601      	movs	r6, #1
	if( xSchedulerRunning != pdFALSE )
 8001e7e:	681b      	ldr	r3, [r3, #0]
 8001e80:	2b00      	cmp	r3, #0
 8001e82:	d006      	beq.n	8001e92 <xTaskCreate+0x12a>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8001e84:	682b      	ldr	r3, [r5, #0]
 8001e86:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001e88:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001e8a:	429a      	cmp	r2, r3
 8001e8c:	d201      	bcs.n	8001e92 <xTaskCreate+0x12a>
			taskYIELD_IF_USING_PREEMPTION();
 8001e8e:	f7ff fabb 	bl	8001408 <vPortYield>
	}
 8001e92:	0030      	movs	r0, r6
 8001e94:	b005      	add	sp, #20
 8001e96:	bdf0      	pop	{r4, r5, r6, r7, pc}
					vPortFree( pxStack );
 8001e98:	0030      	movs	r0, r6
 8001e9a:	f7ff fbf1 	bl	8001680 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8001e9e:	2601      	movs	r6, #1
 8001ea0:	4276      	negs	r6, r6
 8001ea2:	e7f6      	b.n	8001e92 <xTaskCreate+0x12a>
			if( xSchedulerRunning == pdFALSE )
 8001ea4:	4b11      	ldr	r3, [pc, #68]	; (8001eec <xTaskCreate+0x184>)
 8001ea6:	681b      	ldr	r3, [r3, #0]
 8001ea8:	2b00      	cmp	r3, #0
 8001eaa:	d1d3      	bne.n	8001e54 <xTaskCreate+0xec>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8001eac:	682b      	ldr	r3, [r5, #0]
 8001eae:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001eb0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001eb2:	4293      	cmp	r3, r2
 8001eb4:	d8ce      	bhi.n	8001e54 <xTaskCreate+0xec>
					pxCurrentTCB = pxNewTCB;
 8001eb6:	602c      	str	r4, [r5, #0]
 8001eb8:	e7cc      	b.n	8001e54 <xTaskCreate+0xec>
 8001eba:	46c0      	nop			; (mov r8, r8)
 8001ebc:	200011c4 	.word	0x200011c4
 8001ec0:	2000112c 	.word	0x2000112c
 8001ec4:	20001138 	.word	0x20001138
 8001ec8:	200011dc 	.word	0x200011dc
 8001ecc:	200011f0 	.word	0x200011f0
 8001ed0:	20001210 	.word	0x20001210
 8001ed4:	2000123c 	.word	0x2000123c
 8001ed8:	20001228 	.word	0x20001228
 8001edc:	20001130 	.word	0x20001130
 8001ee0:	20001134 	.word	0x20001134
 8001ee4:	200011d4 	.word	0x200011d4
 8001ee8:	200011d8 	.word	0x200011d8
 8001eec:	20001224 	.word	0x20001224

08001ef0 <vTaskStartScheduler>:
{
 8001ef0:	b513      	push	{r0, r1, r4, lr}
		xReturn = xTaskCreate(	prvIdleTask,
 8001ef2:	2400      	movs	r4, #0
 8001ef4:	4b0f      	ldr	r3, [pc, #60]	; (8001f34 <vTaskStartScheduler+0x44>)
 8001ef6:	9400      	str	r4, [sp, #0]
 8001ef8:	9301      	str	r3, [sp, #4]
 8001efa:	2240      	movs	r2, #64	; 0x40
 8001efc:	0023      	movs	r3, r4
 8001efe:	490e      	ldr	r1, [pc, #56]	; (8001f38 <vTaskStartScheduler+0x48>)
 8001f00:	480e      	ldr	r0, [pc, #56]	; (8001f3c <vTaskStartScheduler+0x4c>)
 8001f02:	f7ff ff31 	bl	8001d68 <xTaskCreate>
		if( xReturn == pdPASS )
 8001f06:	2801      	cmp	r0, #1
 8001f08:	d10f      	bne.n	8001f2a <vTaskStartScheduler+0x3a>
			xReturn = xTimerCreateTimerTask();
 8001f0a:	f000 fb17 	bl	800253c <xTimerCreateTimerTask>
	if( xReturn == pdPASS )
 8001f0e:	2801      	cmp	r0, #1
 8001f10:	d10b      	bne.n	8001f2a <vTaskStartScheduler+0x3a>
		portDISABLE_INTERRUPTS();
 8001f12:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
 8001f14:	2201      	movs	r2, #1
 8001f16:	4b0a      	ldr	r3, [pc, #40]	; (8001f40 <vTaskStartScheduler+0x50>)
 8001f18:	4252      	negs	r2, r2
 8001f1a:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 8001f1c:	4b09      	ldr	r3, [pc, #36]	; (8001f44 <vTaskStartScheduler+0x54>)
 8001f1e:	6018      	str	r0, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 8001f20:	4b09      	ldr	r3, [pc, #36]	; (8001f48 <vTaskStartScheduler+0x58>)
 8001f22:	601c      	str	r4, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
 8001f24:	f7ff faec 	bl	8001500 <xPortStartScheduler>
}
 8001f28:	bd13      	pop	{r0, r1, r4, pc}
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8001f2a:	1c43      	adds	r3, r0, #1
 8001f2c:	d1fc      	bne.n	8001f28 <vTaskStartScheduler+0x38>
 8001f2e:	b672      	cpsid	i
 8001f30:	e7fe      	b.n	8001f30 <vTaskStartScheduler+0x40>
 8001f32:	46c0      	nop			; (mov r8, r8)
 8001f34:	20001204 	.word	0x20001204
 8001f38:	08004298 	.word	0x08004298
 8001f3c:	08002169 	.word	0x08002169
 8001f40:	20001208 	.word	0x20001208
 8001f44:	20001224 	.word	0x20001224
 8001f48:	20001250 	.word	0x20001250

08001f4c <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8001f4c:	4a02      	ldr	r2, [pc, #8]	; (8001f58 <vTaskSuspendAll+0xc>)
 8001f4e:	6813      	ldr	r3, [r2, #0]
 8001f50:	3301      	adds	r3, #1
 8001f52:	6013      	str	r3, [r2, #0]
}
 8001f54:	4770      	bx	lr
 8001f56:	46c0      	nop			; (mov r8, r8)
 8001f58:	200011d0 	.word	0x200011d0

08001f5c <xTaskGetTickCount>:
 8001f5c:	4b01      	ldr	r3, [pc, #4]	; (8001f64 <xTaskGetTickCount+0x8>)
 8001f5e:	6818      	ldr	r0, [r3, #0]
 8001f60:	4770      	bx	lr
 8001f62:	46c0      	nop			; (mov r8, r8)
 8001f64:	20001250 	.word	0x20001250

08001f68 <xTaskIncrementTick>:
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001f68:	4b33      	ldr	r3, [pc, #204]	; (8002038 <xTaskIncrementTick+0xd0>)
{
 8001f6a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001f6c:	681b      	ldr	r3, [r3, #0]
 8001f6e:	2b00      	cmp	r3, #0
 8001f70:	d135      	bne.n	8001fde <xTaskIncrementTick+0x76>
		const TickType_t xConstTickCount = xTickCount + 1;
 8001f72:	4b32      	ldr	r3, [pc, #200]	; (800203c <xTaskIncrementTick+0xd4>)
 8001f74:	681c      	ldr	r4, [r3, #0]
 8001f76:	3401      	adds	r4, #1
		xTickCount = xConstTickCount;
 8001f78:	601c      	str	r4, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U )
 8001f7a:	2c00      	cmp	r4, #0
 8001f7c:	d111      	bne.n	8001fa2 <xTaskIncrementTick+0x3a>
			taskSWITCH_DELAYED_LISTS();
 8001f7e:	4b30      	ldr	r3, [pc, #192]	; (8002040 <xTaskIncrementTick+0xd8>)
 8001f80:	681a      	ldr	r2, [r3, #0]
 8001f82:	6812      	ldr	r2, [r2, #0]
 8001f84:	2a00      	cmp	r2, #0
 8001f86:	d001      	beq.n	8001f8c <xTaskIncrementTick+0x24>
 8001f88:	b672      	cpsid	i
 8001f8a:	e7fe      	b.n	8001f8a <xTaskIncrementTick+0x22>
 8001f8c:	4a2d      	ldr	r2, [pc, #180]	; (8002044 <xTaskIncrementTick+0xdc>)
 8001f8e:	6819      	ldr	r1, [r3, #0]
 8001f90:	6810      	ldr	r0, [r2, #0]
 8001f92:	6018      	str	r0, [r3, #0]
 8001f94:	6011      	str	r1, [r2, #0]
 8001f96:	4a2c      	ldr	r2, [pc, #176]	; (8002048 <xTaskIncrementTick+0xe0>)
 8001f98:	6813      	ldr	r3, [r2, #0]
 8001f9a:	3301      	adds	r3, #1
 8001f9c:	6013      	str	r3, [r2, #0]
 8001f9e:	f7ff fe97 	bl	8001cd0 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 8001fa2:	4f2a      	ldr	r7, [pc, #168]	; (800204c <xTaskIncrementTick+0xe4>)
BaseType_t xSwitchRequired = pdFALSE;
 8001fa4:	2600      	movs	r6, #0
		if( xConstTickCount >= xNextTaskUnblockTime )
 8001fa6:	683b      	ldr	r3, [r7, #0]
 8001fa8:	429c      	cmp	r4, r3
 8001faa:	d307      	bcc.n	8001fbc <xTaskIncrementTick+0x54>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001fac:	4b24      	ldr	r3, [pc, #144]	; (8002040 <xTaskIncrementTick+0xd8>)
 8001fae:	681a      	ldr	r2, [r3, #0]
 8001fb0:	6812      	ldr	r2, [r2, #0]
 8001fb2:	2a00      	cmp	r2, #0
 8001fb4:	d119      	bne.n	8001fea <xTaskIncrementTick+0x82>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001fb6:	2301      	movs	r3, #1
 8001fb8:	425b      	negs	r3, r3
 8001fba:	603b      	str	r3, [r7, #0]
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8001fbc:	4b24      	ldr	r3, [pc, #144]	; (8002050 <xTaskIncrementTick+0xe8>)
 8001fbe:	681b      	ldr	r3, [r3, #0]
 8001fc0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001fc2:	2314      	movs	r3, #20
 8001fc4:	4353      	muls	r3, r2
 8001fc6:	4a23      	ldr	r2, [pc, #140]	; (8002054 <xTaskIncrementTick+0xec>)
 8001fc8:	58d3      	ldr	r3, [r2, r3]
 8001fca:	2b01      	cmp	r3, #1
 8001fcc:	d900      	bls.n	8001fd0 <xTaskIncrementTick+0x68>
				xSwitchRequired = pdTRUE;
 8001fce:	2601      	movs	r6, #1
		if( xYieldPending != pdFALSE )
 8001fd0:	4b21      	ldr	r3, [pc, #132]	; (8002058 <xTaskIncrementTick+0xf0>)
 8001fd2:	681b      	ldr	r3, [r3, #0]
 8001fd4:	2b00      	cmp	r3, #0
 8001fd6:	d000      	beq.n	8001fda <xTaskIncrementTick+0x72>
			xSwitchRequired = pdTRUE;
 8001fd8:	2601      	movs	r6, #1
}
 8001fda:	0030      	movs	r0, r6
 8001fdc:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		++uxPendedTicks;
 8001fde:	4a1f      	ldr	r2, [pc, #124]	; (800205c <xTaskIncrementTick+0xf4>)
BaseType_t xSwitchRequired = pdFALSE;
 8001fe0:	2600      	movs	r6, #0
		++uxPendedTicks;
 8001fe2:	6813      	ldr	r3, [r2, #0]
 8001fe4:	3301      	adds	r3, #1
 8001fe6:	6013      	str	r3, [r2, #0]
 8001fe8:	e7f2      	b.n	8001fd0 <xTaskIncrementTick+0x68>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8001fea:	681b      	ldr	r3, [r3, #0]
 8001fec:	68db      	ldr	r3, [r3, #12]
 8001fee:	68dd      	ldr	r5, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8001ff0:	686b      	ldr	r3, [r5, #4]
					if( xConstTickCount < xItemValue )
 8001ff2:	429c      	cmp	r4, r3
 8001ff4:	d3e1      	bcc.n	8001fba <xTaskIncrementTick+0x52>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001ff6:	1d2b      	adds	r3, r5, #4
 8001ff8:	0018      	movs	r0, r3
 8001ffa:	9301      	str	r3, [sp, #4]
 8001ffc:	f7ff f9be 	bl	800137c <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8002000:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8002002:	2b00      	cmp	r3, #0
 8002004:	d003      	beq.n	800200e <xTaskIncrementTick+0xa6>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8002006:	0028      	movs	r0, r5
 8002008:	3018      	adds	r0, #24
 800200a:	f7ff f9b7 	bl	800137c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800200e:	4b14      	ldr	r3, [pc, #80]	; (8002060 <xTaskIncrementTick+0xf8>)
 8002010:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8002012:	681a      	ldr	r2, [r3, #0]
 8002014:	4290      	cmp	r0, r2
 8002016:	d900      	bls.n	800201a <xTaskIncrementTick+0xb2>
 8002018:	6018      	str	r0, [r3, #0]
 800201a:	2314      	movs	r3, #20
 800201c:	4358      	muls	r0, r3
 800201e:	4b0d      	ldr	r3, [pc, #52]	; (8002054 <xTaskIncrementTick+0xec>)
 8002020:	1d29      	adds	r1, r5, #4
 8002022:	1818      	adds	r0, r3, r0
 8002024:	f7ff f987 	bl	8001336 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8002028:	4b09      	ldr	r3, [pc, #36]	; (8002050 <xTaskIncrementTick+0xe8>)
 800202a:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800202c:	681b      	ldr	r3, [r3, #0]
 800202e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002030:	429a      	cmp	r2, r3
 8002032:	d3bb      	bcc.n	8001fac <xTaskIncrementTick+0x44>
							xSwitchRequired = pdTRUE;
 8002034:	2601      	movs	r6, #1
 8002036:	e7b9      	b.n	8001fac <xTaskIncrementTick+0x44>
 8002038:	200011d0 	.word	0x200011d0
 800203c:	20001250 	.word	0x20001250
 8002040:	20001130 	.word	0x20001130
 8002044:	20001134 	.word	0x20001134
 8002048:	2000120c 	.word	0x2000120c
 800204c:	20001208 	.word	0x20001208
 8002050:	2000112c 	.word	0x2000112c
 8002054:	20001138 	.word	0x20001138
 8002058:	20001254 	.word	0x20001254
 800205c:	200011cc 	.word	0x200011cc
 8002060:	200011d8 	.word	0x200011d8

08002064 <xTaskResumeAll>:
{
 8002064:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( uxSchedulerSuspended );
 8002066:	4c2b      	ldr	r4, [pc, #172]	; (8002114 <xTaskResumeAll+0xb0>)
 8002068:	6823      	ldr	r3, [r4, #0]
 800206a:	2b00      	cmp	r3, #0
 800206c:	d101      	bne.n	8002072 <xTaskResumeAll+0xe>
 800206e:	b672      	cpsid	i
 8002070:	e7fe      	b.n	8002070 <xTaskResumeAll+0xc>
	taskENTER_CRITICAL();
 8002072:	f7ff f9d5 	bl	8001420 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8002076:	6823      	ldr	r3, [r4, #0]
 8002078:	3b01      	subs	r3, #1
 800207a:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800207c:	6824      	ldr	r4, [r4, #0]
 800207e:	2c00      	cmp	r4, #0
 8002080:	d004      	beq.n	800208c <xTaskResumeAll+0x28>
BaseType_t xAlreadyYielded = pdFALSE;
 8002082:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8002084:	f7ff f9d8 	bl	8001438 <vPortExitCritical>
}
 8002088:	0020      	movs	r0, r4
 800208a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800208c:	4b22      	ldr	r3, [pc, #136]	; (8002118 <xTaskResumeAll+0xb4>)
 800208e:	681b      	ldr	r3, [r3, #0]
 8002090:	2b00      	cmp	r3, #0
 8002092:	d0f6      	beq.n	8002082 <xTaskResumeAll+0x1e>
					prvAddTaskToReadyList( pxTCB );
 8002094:	2614      	movs	r6, #20
						xYieldPending = pdTRUE;
 8002096:	2701      	movs	r7, #1
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8002098:	4b20      	ldr	r3, [pc, #128]	; (800211c <xTaskResumeAll+0xb8>)
 800209a:	681a      	ldr	r2, [r3, #0]
 800209c:	2a00      	cmp	r2, #0
 800209e:	d11a      	bne.n	80020d6 <xTaskResumeAll+0x72>
				if( pxTCB != NULL )
 80020a0:	2c00      	cmp	r4, #0
 80020a2:	d001      	beq.n	80020a8 <xTaskResumeAll+0x44>
					prvResetNextTaskUnblockTime();
 80020a4:	f7ff fe14 	bl	8001cd0 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 80020a8:	4d1d      	ldr	r5, [pc, #116]	; (8002120 <xTaskResumeAll+0xbc>)
 80020aa:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 80020ac:	2c00      	cmp	r4, #0
 80020ae:	d00a      	beq.n	80020c6 <xTaskResumeAll+0x62>
								xYieldPending = pdTRUE;
 80020b0:	2601      	movs	r6, #1
							if( xTaskIncrementTick() != pdFALSE )
 80020b2:	f7ff ff59 	bl	8001f68 <xTaskIncrementTick>
 80020b6:	2800      	cmp	r0, #0
 80020b8:	d001      	beq.n	80020be <xTaskResumeAll+0x5a>
								xYieldPending = pdTRUE;
 80020ba:	4b1a      	ldr	r3, [pc, #104]	; (8002124 <xTaskResumeAll+0xc0>)
 80020bc:	601e      	str	r6, [r3, #0]
							--uxPendedCounts;
 80020be:	3c01      	subs	r4, #1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 80020c0:	2c00      	cmp	r4, #0
 80020c2:	d1f6      	bne.n	80020b2 <xTaskResumeAll+0x4e>
						uxPendedTicks = 0;
 80020c4:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
 80020c6:	4b17      	ldr	r3, [pc, #92]	; (8002124 <xTaskResumeAll+0xc0>)
 80020c8:	681b      	ldr	r3, [r3, #0]
 80020ca:	2b00      	cmp	r3, #0
 80020cc:	d0d9      	beq.n	8002082 <xTaskResumeAll+0x1e>
					taskYIELD_IF_USING_PREEMPTION();
 80020ce:	f7ff f99b 	bl	8001408 <vPortYield>
						xAlreadyYielded = pdTRUE;
 80020d2:	2401      	movs	r4, #1
 80020d4:	e7d6      	b.n	8002084 <xTaskResumeAll+0x20>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 80020d6:	68db      	ldr	r3, [r3, #12]
 80020d8:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80020da:	0020      	movs	r0, r4
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80020dc:	1d25      	adds	r5, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80020de:	3018      	adds	r0, #24
 80020e0:	f7ff f94c 	bl	800137c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80020e4:	0028      	movs	r0, r5
 80020e6:	f7ff f949 	bl	800137c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80020ea:	4b0f      	ldr	r3, [pc, #60]	; (8002128 <xTaskResumeAll+0xc4>)
 80020ec:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80020ee:	681a      	ldr	r2, [r3, #0]
 80020f0:	4290      	cmp	r0, r2
 80020f2:	d900      	bls.n	80020f6 <xTaskResumeAll+0x92>
 80020f4:	6018      	str	r0, [r3, #0]
 80020f6:	4370      	muls	r0, r6
 80020f8:	4b0c      	ldr	r3, [pc, #48]	; (800212c <xTaskResumeAll+0xc8>)
 80020fa:	0029      	movs	r1, r5
 80020fc:	1818      	adds	r0, r3, r0
 80020fe:	f7ff f91a 	bl	8001336 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8002102:	4b0b      	ldr	r3, [pc, #44]	; (8002130 <xTaskResumeAll+0xcc>)
 8002104:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002106:	681b      	ldr	r3, [r3, #0]
 8002108:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800210a:	429a      	cmp	r2, r3
 800210c:	d3c4      	bcc.n	8002098 <xTaskResumeAll+0x34>
						xYieldPending = pdTRUE;
 800210e:	4b05      	ldr	r3, [pc, #20]	; (8002124 <xTaskResumeAll+0xc0>)
 8002110:	601f      	str	r7, [r3, #0]
 8002112:	e7c1      	b.n	8002098 <xTaskResumeAll+0x34>
 8002114:	200011d0 	.word	0x200011d0
 8002118:	200011c4 	.word	0x200011c4
 800211c:	20001210 	.word	0x20001210
 8002120:	200011cc 	.word	0x200011cc
 8002124:	20001254 	.word	0x20001254
 8002128:	200011d8 	.word	0x200011d8
 800212c:	20001138 	.word	0x20001138
 8002130:	2000112c 	.word	0x2000112c

08002134 <vTaskDelay>:
	{
 8002134:	b570      	push	{r4, r5, r6, lr}
 8002136:	1e04      	subs	r4, r0, #0
		if( xTicksToDelay > ( TickType_t ) 0U )
 8002138:	d102      	bne.n	8002140 <vTaskDelay+0xc>
			portYIELD_WITHIN_API();
 800213a:	f7ff f965 	bl	8001408 <vPortYield>
	}
 800213e:	bd70      	pop	{r4, r5, r6, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 8002140:	4b08      	ldr	r3, [pc, #32]	; (8002164 <vTaskDelay+0x30>)
 8002142:	681d      	ldr	r5, [r3, #0]
 8002144:	2d00      	cmp	r5, #0
 8002146:	d001      	beq.n	800214c <vTaskDelay+0x18>
 8002148:	b672      	cpsid	i
 800214a:	e7fe      	b.n	800214a <vTaskDelay+0x16>
			vTaskSuspendAll();
 800214c:	f7ff fefe 	bl	8001f4c <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8002150:	0029      	movs	r1, r5
 8002152:	0020      	movs	r0, r4
 8002154:	f7ff fdd0 	bl	8001cf8 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 8002158:	f7ff ff84 	bl	8002064 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 800215c:	2800      	cmp	r0, #0
 800215e:	d1ee      	bne.n	800213e <vTaskDelay+0xa>
 8002160:	e7eb      	b.n	800213a <vTaskDelay+0x6>
 8002162:	46c0      	nop			; (mov r8, r8)
 8002164:	200011d0 	.word	0x200011d0

08002168 <prvIdleTask>:
{
 8002168:	b570      	push	{r4, r5, r6, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800216a:	4c15      	ldr	r4, [pc, #84]	; (80021c0 <prvIdleTask+0x58>)
 800216c:	6823      	ldr	r3, [r4, #0]
 800216e:	2b00      	cmp	r3, #0
 8002170:	d106      	bne.n	8002180 <prvIdleTask+0x18>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8002172:	4b14      	ldr	r3, [pc, #80]	; (80021c4 <prvIdleTask+0x5c>)
 8002174:	681b      	ldr	r3, [r3, #0]
 8002176:	2b01      	cmp	r3, #1
 8002178:	d9f7      	bls.n	800216a <prvIdleTask+0x2>
				taskYIELD();
 800217a:	f7ff f945 	bl	8001408 <vPortYield>
 800217e:	e7f4      	b.n	800216a <prvIdleTask+0x2>
			vTaskSuspendAll();
 8002180:	f7ff fee4 	bl	8001f4c <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8002184:	4d10      	ldr	r5, [pc, #64]	; (80021c8 <prvIdleTask+0x60>)
 8002186:	682e      	ldr	r6, [r5, #0]
			( void ) xTaskResumeAll();
 8002188:	f7ff ff6c 	bl	8002064 <xTaskResumeAll>
			if( xListIsEmpty == pdFALSE )
 800218c:	2e00      	cmp	r6, #0
 800218e:	d0ec      	beq.n	800216a <prvIdleTask+0x2>
				taskENTER_CRITICAL();
 8002190:	f7ff f946 	bl	8001420 <vPortEnterCritical>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8002194:	68eb      	ldr	r3, [r5, #12]
 8002196:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8002198:	1d28      	adds	r0, r5, #4
 800219a:	f7ff f8ef 	bl	800137c <uxListRemove>
					--uxCurrentNumberOfTasks;
 800219e:	4a0b      	ldr	r2, [pc, #44]	; (80021cc <prvIdleTask+0x64>)
 80021a0:	6813      	ldr	r3, [r2, #0]
 80021a2:	3b01      	subs	r3, #1
 80021a4:	6013      	str	r3, [r2, #0]
					--uxDeletedTasksWaitingCleanUp;
 80021a6:	6823      	ldr	r3, [r4, #0]
 80021a8:	3b01      	subs	r3, #1
 80021aa:	6023      	str	r3, [r4, #0]
				taskEXIT_CRITICAL();
 80021ac:	f7ff f944 	bl	8001438 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
 80021b0:	6b28      	ldr	r0, [r5, #48]	; 0x30
 80021b2:	f7ff fa65 	bl	8001680 <vPortFree>
			vPortFree( pxTCB );
 80021b6:	0028      	movs	r0, r5
 80021b8:	f7ff fa62 	bl	8001680 <vPortFree>
 80021bc:	e7d5      	b.n	800216a <prvIdleTask+0x2>
 80021be:	46c0      	nop			; (mov r8, r8)
 80021c0:	200011c8 	.word	0x200011c8
 80021c4:	20001138 	.word	0x20001138
 80021c8:	2000123c 	.word	0x2000123c
 80021cc:	200011c4 	.word	0x200011c4

080021d0 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 80021d0:	4b15      	ldr	r3, [pc, #84]	; (8002228 <vTaskSwitchContext+0x58>)
{
 80021d2:	b530      	push	{r4, r5, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 80021d4:	681a      	ldr	r2, [r3, #0]
 80021d6:	4b15      	ldr	r3, [pc, #84]	; (800222c <vTaskSwitchContext+0x5c>)
 80021d8:	2a00      	cmp	r2, #0
 80021da:	d002      	beq.n	80021e2 <vTaskSwitchContext+0x12>
		xYieldPending = pdTRUE;
 80021dc:	2201      	movs	r2, #1
 80021de:	601a      	str	r2, [r3, #0]
}
 80021e0:	bd30      	pop	{r4, r5, pc}
 80021e2:	2414      	movs	r4, #20
		taskSELECT_HIGHEST_PRIORITY_TASK();
 80021e4:	4812      	ldr	r0, [pc, #72]	; (8002230 <vTaskSwitchContext+0x60>)
		xYieldPending = pdFALSE;
 80021e6:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 80021e8:	6802      	ldr	r2, [r0, #0]
 80021ea:	4912      	ldr	r1, [pc, #72]	; (8002234 <vTaskSwitchContext+0x64>)
 80021ec:	0023      	movs	r3, r4
 80021ee:	4353      	muls	r3, r2
 80021f0:	585d      	ldr	r5, [r3, r1]
 80021f2:	2d00      	cmp	r5, #0
 80021f4:	d012      	beq.n	800221c <vTaskSwitchContext+0x4c>
 80021f6:	18cc      	adds	r4, r1, r3
 80021f8:	6865      	ldr	r5, [r4, #4]
 80021fa:	3308      	adds	r3, #8
 80021fc:	686d      	ldr	r5, [r5, #4]
 80021fe:	18cb      	adds	r3, r1, r3
 8002200:	6065      	str	r5, [r4, #4]
 8002202:	429d      	cmp	r5, r3
 8002204:	d101      	bne.n	800220a <vTaskSwitchContext+0x3a>
 8002206:	686b      	ldr	r3, [r5, #4]
 8002208:	6063      	str	r3, [r4, #4]
 800220a:	2314      	movs	r3, #20
 800220c:	4353      	muls	r3, r2
 800220e:	18c9      	adds	r1, r1, r3
 8002210:	684b      	ldr	r3, [r1, #4]
 8002212:	68d9      	ldr	r1, [r3, #12]
 8002214:	4b08      	ldr	r3, [pc, #32]	; (8002238 <vTaskSwitchContext+0x68>)
 8002216:	6019      	str	r1, [r3, #0]
 8002218:	6002      	str	r2, [r0, #0]
}
 800221a:	e7e1      	b.n	80021e0 <vTaskSwitchContext+0x10>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800221c:	2a00      	cmp	r2, #0
 800221e:	d101      	bne.n	8002224 <vTaskSwitchContext+0x54>
 8002220:	b672      	cpsid	i
 8002222:	e7fe      	b.n	8002222 <vTaskSwitchContext+0x52>
 8002224:	3a01      	subs	r2, #1
 8002226:	e7e1      	b.n	80021ec <vTaskSwitchContext+0x1c>
 8002228:	200011d0 	.word	0x200011d0
 800222c:	20001254 	.word	0x20001254
 8002230:	200011d8 	.word	0x200011d8
 8002234:	20001138 	.word	0x20001138
 8002238:	2000112c 	.word	0x2000112c

0800223c <vTaskPlaceOnEventList>:
{
 800223c:	b510      	push	{r4, lr}
 800223e:	000c      	movs	r4, r1
	configASSERT( pxEventList );
 8002240:	2800      	cmp	r0, #0
 8002242:	d101      	bne.n	8002248 <vTaskPlaceOnEventList+0xc>
 8002244:	b672      	cpsid	i
 8002246:	e7fe      	b.n	8002246 <vTaskPlaceOnEventList+0xa>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8002248:	4b04      	ldr	r3, [pc, #16]	; (800225c <vTaskPlaceOnEventList+0x20>)
 800224a:	6819      	ldr	r1, [r3, #0]
 800224c:	3118      	adds	r1, #24
 800224e:	f7ff f87e 	bl	800134e <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8002252:	2101      	movs	r1, #1
 8002254:	0020      	movs	r0, r4
 8002256:	f7ff fd4f 	bl	8001cf8 <prvAddCurrentTaskToDelayedList>
}
 800225a:	bd10      	pop	{r4, pc}
 800225c:	2000112c 	.word	0x2000112c

08002260 <vTaskPlaceOnEventListRestricted>:
	{
 8002260:	b570      	push	{r4, r5, r6, lr}
 8002262:	000c      	movs	r4, r1
 8002264:	0015      	movs	r5, r2
		configASSERT( pxEventList );
 8002266:	2800      	cmp	r0, #0
 8002268:	d101      	bne.n	800226e <vTaskPlaceOnEventListRestricted+0xe>
 800226a:	b672      	cpsid	i
 800226c:	e7fe      	b.n	800226c <vTaskPlaceOnEventListRestricted+0xc>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800226e:	4b07      	ldr	r3, [pc, #28]	; (800228c <vTaskPlaceOnEventListRestricted+0x2c>)
 8002270:	6819      	ldr	r1, [r3, #0]
 8002272:	3118      	adds	r1, #24
 8002274:	f7ff f85f 	bl	8001336 <vListInsertEnd>
		if( xWaitIndefinitely != pdFALSE )
 8002278:	2d00      	cmp	r5, #0
 800227a:	d001      	beq.n	8002280 <vTaskPlaceOnEventListRestricted+0x20>
			xTicksToWait = portMAX_DELAY;
 800227c:	2401      	movs	r4, #1
 800227e:	4264      	negs	r4, r4
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 8002280:	0029      	movs	r1, r5
 8002282:	0020      	movs	r0, r4
 8002284:	f7ff fd38 	bl	8001cf8 <prvAddCurrentTaskToDelayedList>
	}
 8002288:	bd70      	pop	{r4, r5, r6, pc}
 800228a:	46c0      	nop			; (mov r8, r8)
 800228c:	2000112c 	.word	0x2000112c

08002290 <xTaskRemoveFromEventList>:
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8002290:	68c3      	ldr	r3, [r0, #12]
{
 8002292:	b570      	push	{r4, r5, r6, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8002294:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 8002296:	2c00      	cmp	r4, #0
 8002298:	d101      	bne.n	800229e <xTaskRemoveFromEventList+0xe>
 800229a:	b672      	cpsid	i
 800229c:	e7fe      	b.n	800229c <xTaskRemoveFromEventList+0xc>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800229e:	0025      	movs	r5, r4
 80022a0:	3518      	adds	r5, #24
 80022a2:	0028      	movs	r0, r5
 80022a4:	f7ff f86a 	bl	800137c <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80022a8:	4b11      	ldr	r3, [pc, #68]	; (80022f0 <xTaskRemoveFromEventList+0x60>)
 80022aa:	681b      	ldr	r3, [r3, #0]
 80022ac:	2b00      	cmp	r3, #0
 80022ae:	d11b      	bne.n	80022e8 <xTaskRemoveFromEventList+0x58>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 80022b0:	1d25      	adds	r5, r4, #4
 80022b2:	0028      	movs	r0, r5
 80022b4:	f7ff f862 	bl	800137c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 80022b8:	4a0e      	ldr	r2, [pc, #56]	; (80022f4 <xTaskRemoveFromEventList+0x64>)
 80022ba:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80022bc:	6811      	ldr	r1, [r2, #0]
 80022be:	428b      	cmp	r3, r1
 80022c0:	d900      	bls.n	80022c4 <xTaskRemoveFromEventList+0x34>
 80022c2:	6013      	str	r3, [r2, #0]
 80022c4:	2014      	movs	r0, #20
 80022c6:	0029      	movs	r1, r5
 80022c8:	4343      	muls	r3, r0
 80022ca:	480b      	ldr	r0, [pc, #44]	; (80022f8 <xTaskRemoveFromEventList+0x68>)
 80022cc:	18c0      	adds	r0, r0, r3
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 80022ce:	f7ff f832 	bl	8001336 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 80022d2:	4b0a      	ldr	r3, [pc, #40]	; (80022fc <xTaskRemoveFromEventList+0x6c>)
 80022d4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80022d6:	681b      	ldr	r3, [r3, #0]
		xReturn = pdFALSE;
 80022d8:	2000      	movs	r0, #0
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 80022da:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80022dc:	429a      	cmp	r2, r3
 80022de:	d902      	bls.n	80022e6 <xTaskRemoveFromEventList+0x56>
		xYieldPending = pdTRUE;
 80022e0:	4b07      	ldr	r3, [pc, #28]	; (8002300 <xTaskRemoveFromEventList+0x70>)
 80022e2:	3001      	adds	r0, #1
 80022e4:	6018      	str	r0, [r3, #0]
}
 80022e6:	bd70      	pop	{r4, r5, r6, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 80022e8:	0029      	movs	r1, r5
 80022ea:	4806      	ldr	r0, [pc, #24]	; (8002304 <xTaskRemoveFromEventList+0x74>)
 80022ec:	e7ef      	b.n	80022ce <xTaskRemoveFromEventList+0x3e>
 80022ee:	46c0      	nop			; (mov r8, r8)
 80022f0:	200011d0 	.word	0x200011d0
 80022f4:	200011d8 	.word	0x200011d8
 80022f8:	20001138 	.word	0x20001138
 80022fc:	2000112c 	.word	0x2000112c
 8002300:	20001254 	.word	0x20001254
 8002304:	20001210 	.word	0x20001210

08002308 <vTaskSetTimeOutState>:
	configASSERT( pxTimeOut );
 8002308:	2800      	cmp	r0, #0
 800230a:	d101      	bne.n	8002310 <vTaskSetTimeOutState+0x8>
 800230c:	b672      	cpsid	i
 800230e:	e7fe      	b.n	800230e <vTaskSetTimeOutState+0x6>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8002310:	4b03      	ldr	r3, [pc, #12]	; (8002320 <vTaskSetTimeOutState+0x18>)
 8002312:	681b      	ldr	r3, [r3, #0]
 8002314:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8002316:	4b03      	ldr	r3, [pc, #12]	; (8002324 <vTaskSetTimeOutState+0x1c>)
 8002318:	681b      	ldr	r3, [r3, #0]
 800231a:	6043      	str	r3, [r0, #4]
}
 800231c:	4770      	bx	lr
 800231e:	46c0      	nop			; (mov r8, r8)
 8002320:	2000120c 	.word	0x2000120c
 8002324:	20001250 	.word	0x20001250

08002328 <xTaskCheckForTimeOut>:
{
 8002328:	b570      	push	{r4, r5, r6, lr}
 800232a:	0004      	movs	r4, r0
 800232c:	000d      	movs	r5, r1
	configASSERT( pxTimeOut );
 800232e:	2800      	cmp	r0, #0
 8002330:	d101      	bne.n	8002336 <xTaskCheckForTimeOut+0xe>
 8002332:	b672      	cpsid	i
 8002334:	e7fe      	b.n	8002334 <xTaskCheckForTimeOut+0xc>
	configASSERT( pxTicksToWait );
 8002336:	2900      	cmp	r1, #0
 8002338:	d101      	bne.n	800233e <xTaskCheckForTimeOut+0x16>
 800233a:	b672      	cpsid	i
 800233c:	e7fe      	b.n	800233c <xTaskCheckForTimeOut+0x14>
	taskENTER_CRITICAL();
 800233e:	f7ff f86f 	bl	8001420 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 8002342:	4b0f      	ldr	r3, [pc, #60]	; (8002380 <xTaskCheckForTimeOut+0x58>)
				xReturn = pdFALSE;
 8002344:	2600      	movs	r6, #0
		const TickType_t xConstTickCount = xTickCount;
 8002346:	6819      	ldr	r1, [r3, #0]
			if( *pxTicksToWait == portMAX_DELAY )
 8002348:	682b      	ldr	r3, [r5, #0]
 800234a:	1c5a      	adds	r2, r3, #1
 800234c:	d013      	beq.n	8002376 <xTaskCheckForTimeOut+0x4e>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800234e:	4a0d      	ldr	r2, [pc, #52]	; (8002384 <xTaskCheckForTimeOut+0x5c>)
 8002350:	6826      	ldr	r6, [r4, #0]
 8002352:	6810      	ldr	r0, [r2, #0]
 8002354:	6862      	ldr	r2, [r4, #4]
 8002356:	4286      	cmp	r6, r0
 8002358:	d002      	beq.n	8002360 <xTaskCheckForTimeOut+0x38>
			xReturn = pdTRUE;
 800235a:	2601      	movs	r6, #1
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800235c:	4291      	cmp	r1, r2
 800235e:	d20a      	bcs.n	8002376 <xTaskCheckForTimeOut+0x4e>
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8002360:	1a88      	subs	r0, r1, r2
			xReturn = pdTRUE;
 8002362:	2601      	movs	r6, #1
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8002364:	4283      	cmp	r3, r0
 8002366:	d906      	bls.n	8002376 <xTaskCheckForTimeOut+0x4e>
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 8002368:	1a5b      	subs	r3, r3, r1
 800236a:	189b      	adds	r3, r3, r2
 800236c:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
 800236e:	0020      	movs	r0, r4
 8002370:	f7ff ffca 	bl	8002308 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
 8002374:	2600      	movs	r6, #0
	taskEXIT_CRITICAL();
 8002376:	f7ff f85f 	bl	8001438 <vPortExitCritical>
}
 800237a:	0030      	movs	r0, r6
 800237c:	bd70      	pop	{r4, r5, r6, pc}
 800237e:	46c0      	nop			; (mov r8, r8)
 8002380:	20001250 	.word	0x20001250
 8002384:	2000120c 	.word	0x2000120c

08002388 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 8002388:	2201      	movs	r2, #1
 800238a:	4b01      	ldr	r3, [pc, #4]	; (8002390 <vTaskMissedYield+0x8>)
 800238c:	601a      	str	r2, [r3, #0]
}
 800238e:	4770      	bx	lr
 8002390:	20001254 	.word	0x20001254

08002394 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 8002394:	4b05      	ldr	r3, [pc, #20]	; (80023ac <xTaskGetSchedulerState+0x18>)
			xReturn = taskSCHEDULER_NOT_STARTED;
 8002396:	2001      	movs	r0, #1
		if( xSchedulerRunning == pdFALSE )
 8002398:	681b      	ldr	r3, [r3, #0]
 800239a:	2b00      	cmp	r3, #0
 800239c:	d004      	beq.n	80023a8 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800239e:	4b04      	ldr	r3, [pc, #16]	; (80023b0 <xTaskGetSchedulerState+0x1c>)
 80023a0:	6818      	ldr	r0, [r3, #0]
				xReturn = taskSCHEDULER_SUSPENDED;
 80023a2:	4243      	negs	r3, r0
 80023a4:	4158      	adcs	r0, r3
 80023a6:	0040      	lsls	r0, r0, #1
	}
 80023a8:	4770      	bx	lr
 80023aa:	46c0      	nop			; (mov r8, r8)
 80023ac:	20001224 	.word	0x20001224
 80023b0:	200011d0 	.word	0x200011d0

080023b4 <vTaskPriorityInherit>:
	{
 80023b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80023b6:	1e04      	subs	r4, r0, #0
		if( pxMutexHolder != NULL )
 80023b8:	d026      	beq.n	8002408 <vTaskPriorityInherit+0x54>
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 80023ba:	4f16      	ldr	r7, [pc, #88]	; (8002414 <vTaskPriorityInherit+0x60>)
 80023bc:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 80023be:	683b      	ldr	r3, [r7, #0]
 80023c0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80023c2:	4299      	cmp	r1, r3
 80023c4:	d220      	bcs.n	8002408 <vTaskPriorityInherit+0x54>
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80023c6:	6983      	ldr	r3, [r0, #24]
 80023c8:	2b00      	cmp	r3, #0
 80023ca:	db04      	blt.n	80023d6 <vTaskPriorityInherit+0x22>
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80023cc:	2207      	movs	r2, #7
 80023ce:	683b      	ldr	r3, [r7, #0]
 80023d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80023d2:	1ad2      	subs	r2, r2, r3
 80023d4:	6182      	str	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 80023d6:	2314      	movs	r3, #20
 80023d8:	434b      	muls	r3, r1
 80023da:	4e0f      	ldr	r6, [pc, #60]	; (8002418 <vTaskPriorityInherit+0x64>)
 80023dc:	6962      	ldr	r2, [r4, #20]
 80023de:	18f3      	adds	r3, r6, r3
 80023e0:	429a      	cmp	r2, r3
 80023e2:	d112      	bne.n	800240a <vTaskPriorityInherit+0x56>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80023e4:	1d25      	adds	r5, r4, #4
 80023e6:	0028      	movs	r0, r5
 80023e8:	f7fe ffc8 	bl	800137c <uxListRemove>
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80023ec:	683b      	ldr	r3, [r7, #0]
					prvAddTaskToReadyList( pxTCB );
 80023ee:	4a0b      	ldr	r2, [pc, #44]	; (800241c <vTaskPriorityInherit+0x68>)
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80023f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 80023f2:	6811      	ldr	r1, [r2, #0]
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80023f4:	62e3      	str	r3, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 80023f6:	428b      	cmp	r3, r1
 80023f8:	d900      	bls.n	80023fc <vTaskPriorityInherit+0x48>
 80023fa:	6013      	str	r3, [r2, #0]
 80023fc:	2014      	movs	r0, #20
 80023fe:	4358      	muls	r0, r3
 8002400:	0029      	movs	r1, r5
 8002402:	1830      	adds	r0, r6, r0
 8002404:	f7fe ff97 	bl	8001336 <vListInsertEnd>
	}
 8002408:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 800240a:	683b      	ldr	r3, [r7, #0]
 800240c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800240e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8002410:	e7fa      	b.n	8002408 <vTaskPriorityInherit+0x54>
 8002412:	46c0      	nop			; (mov r8, r8)
 8002414:	2000112c 	.word	0x2000112c
 8002418:	20001138 	.word	0x20001138
 800241c:	200011d8 	.word	0x200011d8

08002420 <xTaskPriorityDisinherit>:
	{
 8002420:	b570      	push	{r4, r5, r6, lr}
 8002422:	1e04      	subs	r4, r0, #0
		if( pxMutexHolder != NULL )
 8002424:	d101      	bne.n	800242a <xTaskPriorityDisinherit+0xa>
	BaseType_t xReturn = pdFALSE;
 8002426:	2000      	movs	r0, #0
	}
 8002428:	bd70      	pop	{r4, r5, r6, pc}
			configASSERT( pxTCB == pxCurrentTCB );
 800242a:	4b15      	ldr	r3, [pc, #84]	; (8002480 <xTaskPriorityDisinherit+0x60>)
 800242c:	681b      	ldr	r3, [r3, #0]
 800242e:	4298      	cmp	r0, r3
 8002430:	d001      	beq.n	8002436 <xTaskPriorityDisinherit+0x16>
 8002432:	b672      	cpsid	i
 8002434:	e7fe      	b.n	8002434 <xTaskPriorityDisinherit+0x14>
			configASSERT( pxTCB->uxMutexesHeld );
 8002436:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8002438:	2b00      	cmp	r3, #0
 800243a:	d101      	bne.n	8002440 <xTaskPriorityDisinherit+0x20>
 800243c:	b672      	cpsid	i
 800243e:	e7fe      	b.n	800243e <xTaskPriorityDisinherit+0x1e>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8002440:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8002442:	6c41      	ldr	r1, [r0, #68]	; 0x44
			( pxTCB->uxMutexesHeld )--;
 8002444:	3b01      	subs	r3, #1
 8002446:	6483      	str	r3, [r0, #72]	; 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8002448:	428a      	cmp	r2, r1
 800244a:	d0ec      	beq.n	8002426 <xTaskPriorityDisinherit+0x6>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 800244c:	2b00      	cmp	r3, #0
 800244e:	d1ea      	bne.n	8002426 <xTaskPriorityDisinherit+0x6>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8002450:	1d05      	adds	r5, r0, #4
 8002452:	0028      	movs	r0, r5
 8002454:	f7fe ff92 	bl	800137c <uxListRemove>
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002458:	2307      	movs	r3, #7
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 800245a:	6c60      	ldr	r0, [r4, #68]	; 0x44
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800245c:	1a1b      	subs	r3, r3, r0
 800245e:	61a3      	str	r3, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 8002460:	4b08      	ldr	r3, [pc, #32]	; (8002484 <xTaskPriorityDisinherit+0x64>)
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8002462:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 8002464:	681a      	ldr	r2, [r3, #0]
 8002466:	4290      	cmp	r0, r2
 8002468:	d900      	bls.n	800246c <xTaskPriorityDisinherit+0x4c>
 800246a:	6018      	str	r0, [r3, #0]
 800246c:	2314      	movs	r3, #20
 800246e:	4343      	muls	r3, r0
 8002470:	4805      	ldr	r0, [pc, #20]	; (8002488 <xTaskPriorityDisinherit+0x68>)
 8002472:	0029      	movs	r1, r5
 8002474:	18c0      	adds	r0, r0, r3
 8002476:	f7fe ff5e 	bl	8001336 <vListInsertEnd>
					xReturn = pdTRUE;
 800247a:	2001      	movs	r0, #1
		return xReturn;
 800247c:	e7d4      	b.n	8002428 <xTaskPriorityDisinherit+0x8>
 800247e:	46c0      	nop			; (mov r8, r8)
 8002480:	2000112c 	.word	0x2000112c
 8002484:	200011d8 	.word	0x200011d8
 8002488:	20001138 	.word	0x20001138

0800248c <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 800248c:	4b04      	ldr	r3, [pc, #16]	; (80024a0 <pvTaskIncrementMutexHeldCount+0x14>)
 800248e:	681a      	ldr	r2, [r3, #0]
 8002490:	2a00      	cmp	r2, #0
 8002492:	d003      	beq.n	800249c <pvTaskIncrementMutexHeldCount+0x10>
			( pxCurrentTCB->uxMutexesHeld )++;
 8002494:	6819      	ldr	r1, [r3, #0]
 8002496:	6c8a      	ldr	r2, [r1, #72]	; 0x48
 8002498:	3201      	adds	r2, #1
 800249a:	648a      	str	r2, [r1, #72]	; 0x48
		return pxCurrentTCB;
 800249c:	6818      	ldr	r0, [r3, #0]
	}
 800249e:	4770      	bx	lr
 80024a0:	2000112c 	.word	0x2000112c

080024a4 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 80024a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 80024a6:	f7fe ffbb 	bl	8001420 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 80024aa:	4c0f      	ldr	r4, [pc, #60]	; (80024e8 <prvCheckForValidListAndQueue+0x44>)
 80024ac:	6825      	ldr	r5, [r4, #0]
 80024ae:	2d00      	cmp	r5, #0
 80024b0:	d116      	bne.n	80024e0 <prvCheckForValidListAndQueue+0x3c>
		{
			vListInitialise( &xActiveTimerList1 );
 80024b2:	4f0e      	ldr	r7, [pc, #56]	; (80024ec <prvCheckForValidListAndQueue+0x48>)
 80024b4:	0038      	movs	r0, r7
 80024b6:	f7fe ff30 	bl	800131a <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 80024ba:	4e0d      	ldr	r6, [pc, #52]	; (80024f0 <prvCheckForValidListAndQueue+0x4c>)
 80024bc:	0030      	movs	r0, r6
 80024be:	f7fe ff2c 	bl	800131a <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 80024c2:	4b0c      	ldr	r3, [pc, #48]	; (80024f4 <prvCheckForValidListAndQueue+0x50>)

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 80024c4:	002a      	movs	r2, r5
			pxCurrentTimerList = &xActiveTimerList1;
 80024c6:	601f      	str	r7, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
 80024c8:	4b0b      	ldr	r3, [pc, #44]	; (80024f8 <prvCheckForValidListAndQueue+0x54>)
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 80024ca:	210c      	movs	r1, #12
 80024cc:	200a      	movs	r0, #10
			pxOverflowTimerList = &xActiveTimerList2;
 80024ce:	601e      	str	r6, [r3, #0]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 80024d0:	f7ff f9ad 	bl	800182e <xQueueGenericCreate>
 80024d4:	6020      	str	r0, [r4, #0]
			}
			#endif

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
 80024d6:	2800      	cmp	r0, #0
 80024d8:	d002      	beq.n	80024e0 <prvCheckForValidListAndQueue+0x3c>
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 80024da:	4908      	ldr	r1, [pc, #32]	; (80024fc <prvCheckForValidListAndQueue+0x58>)
 80024dc:	f7ff fbc0 	bl	8001c60 <vQueueAddToRegistry>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 80024e0:	f7fe ffaa 	bl	8001438 <vPortExitCritical>
}
 80024e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80024e6:	46c0      	nop			; (mov r8, r8)
 80024e8:	2000128c 	.word	0x2000128c
 80024ec:	20001260 	.word	0x20001260
 80024f0:	20001274 	.word	0x20001274
 80024f4:	20001258 	.word	0x20001258
 80024f8:	2000125c 	.word	0x2000125c
 80024fc:	0800429d 	.word	0x0800429d

08002500 <prvInsertTimerInActiveList>:
{
 8002500:	b510      	push	{r4, lr}
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8002502:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8002504:	6100      	str	r0, [r0, #16]
	if( xNextExpiryTime <= xTimeNow )
 8002506:	4291      	cmp	r1, r2
 8002508:	d80c      	bhi.n	8002524 <prvInsertTimerInActiveList+0x24>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800250a:	1ad2      	subs	r2, r2, r3
 800250c:	6983      	ldr	r3, [r0, #24]
			xProcessTimerNow = pdTRUE;
 800250e:	2401      	movs	r4, #1
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002510:	429a      	cmp	r2, r3
 8002512:	d205      	bcs.n	8002520 <prvInsertTimerInActiveList+0x20>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8002514:	4b07      	ldr	r3, [pc, #28]	; (8002534 <prvInsertTimerInActiveList+0x34>)
 8002516:	1d01      	adds	r1, r0, #4
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8002518:	6818      	ldr	r0, [r3, #0]
 800251a:	f7fe ff18 	bl	800134e <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
 800251e:	2400      	movs	r4, #0
}
 8002520:	0020      	movs	r0, r4
 8002522:	bd10      	pop	{r4, pc}
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8002524:	429a      	cmp	r2, r3
 8002526:	d202      	bcs.n	800252e <prvInsertTimerInActiveList+0x2e>
			xProcessTimerNow = pdTRUE;
 8002528:	2401      	movs	r4, #1
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 800252a:	4299      	cmp	r1, r3
 800252c:	d2f8      	bcs.n	8002520 <prvInsertTimerInActiveList+0x20>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800252e:	1d01      	adds	r1, r0, #4
 8002530:	4b01      	ldr	r3, [pc, #4]	; (8002538 <prvInsertTimerInActiveList+0x38>)
 8002532:	e7f1      	b.n	8002518 <prvInsertTimerInActiveList+0x18>
 8002534:	2000125c 	.word	0x2000125c
 8002538:	20001258 	.word	0x20001258

0800253c <xTimerCreateTimerTask>:
{
 800253c:	b507      	push	{r0, r1, r2, lr}
	prvCheckForValidListAndQueue();
 800253e:	f7ff ffb1 	bl	80024a4 <prvCheckForValidListAndQueue>
	if( xTimerQueue != NULL )
 8002542:	4b09      	ldr	r3, [pc, #36]	; (8002568 <xTimerCreateTimerTask+0x2c>)
 8002544:	681b      	ldr	r3, [r3, #0]
 8002546:	2b00      	cmp	r3, #0
 8002548:	d00b      	beq.n	8002562 <xTimerCreateTimerTask+0x26>
			xReturn = xTaskCreate(	prvTimerTask,
 800254a:	4b08      	ldr	r3, [pc, #32]	; (800256c <xTimerCreateTimerTask+0x30>)
 800254c:	2280      	movs	r2, #128	; 0x80
 800254e:	9301      	str	r3, [sp, #4]
 8002550:	2302      	movs	r3, #2
 8002552:	4907      	ldr	r1, [pc, #28]	; (8002570 <xTimerCreateTimerTask+0x34>)
 8002554:	9300      	str	r3, [sp, #0]
 8002556:	4807      	ldr	r0, [pc, #28]	; (8002574 <xTimerCreateTimerTask+0x38>)
 8002558:	2300      	movs	r3, #0
 800255a:	f7ff fc05 	bl	8001d68 <xTaskCreate>
	configASSERT( xReturn );
 800255e:	2800      	cmp	r0, #0
 8002560:	d101      	bne.n	8002566 <xTimerCreateTimerTask+0x2a>
 8002562:	b672      	cpsid	i
 8002564:	e7fe      	b.n	8002564 <xTimerCreateTimerTask+0x28>
}
 8002566:	bd0e      	pop	{r1, r2, r3, pc}
 8002568:	2000128c 	.word	0x2000128c
 800256c:	20001290 	.word	0x20001290
 8002570:	080042a2 	.word	0x080042a2
 8002574:	08002665 	.word	0x08002665

08002578 <xTimerCreate>:
	{
 8002578:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800257a:	0007      	movs	r7, r0
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
 800257c:	2028      	movs	r0, #40	; 0x28
	{
 800257e:	000d      	movs	r5, r1
 8002580:	0016      	movs	r6, r2
 8002582:	9301      	str	r3, [sp, #4]
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
 8002584:	f7fe fffa 	bl	800157c <pvPortMalloc>
 8002588:	1e04      	subs	r4, r0, #0
		if( pxNewTimer != NULL )
 800258a:	d00f      	beq.n	80025ac <xTimerCreate+0x34>
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
 800258c:	2d00      	cmp	r5, #0
 800258e:	d101      	bne.n	8002594 <xTimerCreate+0x1c>
 8002590:	b672      	cpsid	i
 8002592:	e7fe      	b.n	8002592 <xTimerCreate+0x1a>
		prvCheckForValidListAndQueue();
 8002594:	f7ff ff86 	bl	80024a4 <prvCheckForValidListAndQueue>
		pxNewTimer->pvTimerID = pvTimerID;
 8002598:	9b01      	ldr	r3, [sp, #4]
		pxNewTimer->pcTimerName = pcTimerName;
 800259a:	6027      	str	r7, [r4, #0]
		pxNewTimer->pvTimerID = pvTimerID;
 800259c:	6223      	str	r3, [r4, #32]
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 800259e:	9b08      	ldr	r3, [sp, #32]
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 80025a0:	61a5      	str	r5, [r4, #24]
		pxNewTimer->uxAutoReload = uxAutoReload;
 80025a2:	61e6      	str	r6, [r4, #28]
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 80025a4:	6263      	str	r3, [r4, #36]	; 0x24
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 80025a6:	1d20      	adds	r0, r4, #4
 80025a8:	f7fe fec2 	bl	8001330 <vListInitialiseItem>
	}
 80025ac:	0020      	movs	r0, r4
 80025ae:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

080025b0 <xTimerGenericCommand>:
{
 80025b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80025b2:	0017      	movs	r7, r2
 80025b4:	b085      	sub	sp, #20
 80025b6:	0006      	movs	r6, r0
 80025b8:	001a      	movs	r2, r3
	configASSERT( xTimer );
 80025ba:	2800      	cmp	r0, #0
 80025bc:	d101      	bne.n	80025c2 <xTimerGenericCommand+0x12>
 80025be:	b672      	cpsid	i
 80025c0:	e7fe      	b.n	80025c0 <xTimerGenericCommand+0x10>
	if( xTimerQueue != NULL )
 80025c2:	4d0e      	ldr	r5, [pc, #56]	; (80025fc <xTimerGenericCommand+0x4c>)
 80025c4:	682c      	ldr	r4, [r5, #0]
BaseType_t xReturn = pdFAIL;
 80025c6:	1e20      	subs	r0, r4, #0
	if( xTimerQueue != NULL )
 80025c8:	d00f      	beq.n	80025ea <xTimerGenericCommand+0x3a>
		xMessage.xMessageID = xCommandID;
 80025ca:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 80025cc:	9702      	str	r7, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
 80025ce:	9603      	str	r6, [sp, #12]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 80025d0:	2905      	cmp	r1, #5
 80025d2:	dc0c      	bgt.n	80025ee <xTimerGenericCommand+0x3e>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 80025d4:	f7ff fede 	bl	8002394 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 80025d8:	2300      	movs	r3, #0
 80025da:	9a0a      	ldr	r2, [sp, #40]	; 0x28
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 80025dc:	2802      	cmp	r0, #2
 80025de:	d000      	beq.n	80025e2 <xTimerGenericCommand+0x32>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 80025e0:	001a      	movs	r2, r3
 80025e2:	a901      	add	r1, sp, #4
 80025e4:	6828      	ldr	r0, [r5, #0]
 80025e6:	f7ff f93f 	bl	8001868 <xQueueGenericSend>
}
 80025ea:	b005      	add	sp, #20
 80025ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 80025ee:	2300      	movs	r3, #0
 80025f0:	a901      	add	r1, sp, #4
 80025f2:	0020      	movs	r0, r4
 80025f4:	f7ff f9c7 	bl	8001986 <xQueueGenericSendFromISR>
 80025f8:	e7f7      	b.n	80025ea <xTimerGenericCommand+0x3a>
 80025fa:	46c0      	nop			; (mov r8, r8)
 80025fc:	2000128c 	.word	0x2000128c

08002600 <prvSwitchTimerLists>:
{
 8002600:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8002602:	4d16      	ldr	r5, [pc, #88]	; (800265c <prvSwitchTimerLists+0x5c>)
 8002604:	682b      	ldr	r3, [r5, #0]
 8002606:	681a      	ldr	r2, [r3, #0]
 8002608:	2a00      	cmp	r2, #0
 800260a:	d104      	bne.n	8002616 <prvSwitchTimerLists+0x16>
	pxCurrentTimerList = pxOverflowTimerList;
 800260c:	4a14      	ldr	r2, [pc, #80]	; (8002660 <prvSwitchTimerLists+0x60>)
 800260e:	6811      	ldr	r1, [r2, #0]
	pxOverflowTimerList = pxTemp;
 8002610:	6013      	str	r3, [r2, #0]
	pxCurrentTimerList = pxOverflowTimerList;
 8002612:	6029      	str	r1, [r5, #0]
}
 8002614:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002616:	68db      	ldr	r3, [r3, #12]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002618:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800261a:	681e      	ldr	r6, [r3, #0]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800261c:	1d27      	adds	r7, r4, #4
 800261e:	0038      	movs	r0, r7
 8002620:	f7fe feac 	bl	800137c <uxListRemove>
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8002624:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002626:	0020      	movs	r0, r4
 8002628:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 800262a:	69e3      	ldr	r3, [r4, #28]
 800262c:	2b01      	cmp	r3, #1
 800262e:	d1e8      	bne.n	8002602 <prvSwitchTimerLists+0x2>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 8002630:	69a3      	ldr	r3, [r4, #24]
 8002632:	18f3      	adds	r3, r6, r3
			if( xReloadTime > xNextExpireTime )
 8002634:	429e      	cmp	r6, r3
 8002636:	d206      	bcs.n	8002646 <prvSwitchTimerLists+0x46>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 8002638:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 800263a:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800263c:	0039      	movs	r1, r7
 800263e:	6828      	ldr	r0, [r5, #0]
 8002640:	f7fe fe85 	bl	800134e <vListInsert>
 8002644:	e7dd      	b.n	8002602 <prvSwitchTimerLists+0x2>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8002646:	2100      	movs	r1, #0
 8002648:	0032      	movs	r2, r6
 800264a:	9100      	str	r1, [sp, #0]
 800264c:	000b      	movs	r3, r1
 800264e:	0020      	movs	r0, r4
 8002650:	f7ff ffae 	bl	80025b0 <xTimerGenericCommand>
				configASSERT( xResult );
 8002654:	2800      	cmp	r0, #0
 8002656:	d1d4      	bne.n	8002602 <prvSwitchTimerLists+0x2>
 8002658:	b672      	cpsid	i
 800265a:	e7fe      	b.n	800265a <prvSwitchTimerLists+0x5a>
 800265c:	20001258 	.word	0x20001258
 8002660:	2000125c 	.word	0x2000125c

08002664 <prvTimerTask>:
{
 8002664:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002666:	b089      	sub	sp, #36	; 0x24
		xNextExpireTime = ( TickType_t ) 0U;
 8002668:	2600      	movs	r6, #0
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 800266a:	4c58      	ldr	r4, [pc, #352]	; (80027cc <prvTimerTask+0x168>)
 800266c:	6823      	ldr	r3, [r4, #0]
 800266e:	681a      	ldr	r2, [r3, #0]
 8002670:	9203      	str	r2, [sp, #12]
	if( *pxListWasEmpty == pdFALSE )
 8002672:	42b2      	cmp	r2, r6
 8002674:	d001      	beq.n	800267a <prvTimerTask+0x16>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002676:	68db      	ldr	r3, [r3, #12]
 8002678:	681e      	ldr	r6, [r3, #0]
	vTaskSuspendAll();
 800267a:	f7ff fc67 	bl	8001f4c <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
 800267e:	f7ff fc6d 	bl	8001f5c <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 8002682:	4f53      	ldr	r7, [pc, #332]	; (80027d0 <prvTimerTask+0x16c>)
	xTimeNow = xTaskGetTickCount();
 8002684:	9002      	str	r0, [sp, #8]
	if( xTimeNow < xLastTime )
 8002686:	683a      	ldr	r2, [r7, #0]
		*pxTimerListsWereSwitched = pdFALSE;
 8002688:	2500      	movs	r5, #0
	if( xTimeNow < xLastTime )
 800268a:	4290      	cmp	r0, r2
 800268c:	d202      	bcs.n	8002694 <prvTimerTask+0x30>
		prvSwitchTimerLists();
 800268e:	f7ff ffb7 	bl	8002600 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 8002692:	3501      	adds	r5, #1
	xLastTime = xTimeNow;
 8002694:	9b02      	ldr	r3, [sp, #8]
 8002696:	603b      	str	r3, [r7, #0]
		if( xTimerListsWereSwitched == pdFALSE )
 8002698:	2d00      	cmp	r5, #0
 800269a:	d16a      	bne.n	8002772 <prvTimerTask+0x10e>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 800269c:	9b03      	ldr	r3, [sp, #12]
 800269e:	2b00      	cmp	r3, #0
 80026a0:	d054      	beq.n	800274c <prvTimerTask+0xe8>
 80026a2:	9b02      	ldr	r3, [sp, #8]
 80026a4:	0028      	movs	r0, r5
 80026a6:	429e      	cmp	r6, r3
 80026a8:	d855      	bhi.n	8002756 <prvTimerTask+0xf2>
				( void ) xTaskResumeAll();
 80026aa:	f7ff fcdb 	bl	8002064 <xTaskResumeAll>
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 80026ae:	6823      	ldr	r3, [r4, #0]
 80026b0:	68db      	ldr	r3, [r3, #12]
 80026b2:	68dc      	ldr	r4, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80026b4:	1d20      	adds	r0, r4, #4
 80026b6:	f7fe fe61 	bl	800137c <uxListRemove>
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 80026ba:	69e3      	ldr	r3, [r4, #28]
 80026bc:	2b01      	cmp	r3, #1
 80026be:	d113      	bne.n	80026e8 <prvTimerTask+0x84>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 80026c0:	69a3      	ldr	r3, [r4, #24]
 80026c2:	9a02      	ldr	r2, [sp, #8]
 80026c4:	18f1      	adds	r1, r6, r3
 80026c6:	0020      	movs	r0, r4
 80026c8:	0033      	movs	r3, r6
 80026ca:	f7ff ff19 	bl	8002500 <prvInsertTimerInActiveList>
 80026ce:	2800      	cmp	r0, #0
 80026d0:	d00a      	beq.n	80026e8 <prvTimerTask+0x84>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 80026d2:	9500      	str	r5, [sp, #0]
 80026d4:	002b      	movs	r3, r5
 80026d6:	0032      	movs	r2, r6
 80026d8:	0029      	movs	r1, r5
 80026da:	0020      	movs	r0, r4
 80026dc:	f7ff ff68 	bl	80025b0 <xTimerGenericCommand>
			configASSERT( xResult );
 80026e0:	2800      	cmp	r0, #0
 80026e2:	d101      	bne.n	80026e8 <prvTimerTask+0x84>
 80026e4:	b672      	cpsid	i
 80026e6:	e7fe      	b.n	80026e6 <prvTimerTask+0x82>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 80026e8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80026ea:	0020      	movs	r0, r4
 80026ec:	4798      	blx	r3
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 80026ee:	2300      	movs	r3, #0
 80026f0:	4838      	ldr	r0, [pc, #224]	; (80027d4 <prvTimerTask+0x170>)
 80026f2:	001a      	movs	r2, r3
 80026f4:	a905      	add	r1, sp, #20
 80026f6:	6800      	ldr	r0, [r0, #0]
 80026f8:	f7ff f9cb 	bl	8001a92 <xQueueGenericReceive>
 80026fc:	2800      	cmp	r0, #0
 80026fe:	d0b3      	beq.n	8002668 <prvTimerTask+0x4>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 8002700:	9b05      	ldr	r3, [sp, #20]
 8002702:	2b00      	cmp	r3, #0
 8002704:	dbf3      	blt.n	80026ee <prvTimerTask+0x8a>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 8002706:	9c07      	ldr	r4, [sp, #28]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 8002708:	6963      	ldr	r3, [r4, #20]
 800270a:	2b00      	cmp	r3, #0
 800270c:	d002      	beq.n	8002714 <prvTimerTask+0xb0>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800270e:	1d20      	adds	r0, r4, #4
 8002710:	f7fe fe34 	bl	800137c <uxListRemove>
	xTimeNow = xTaskGetTickCount();
 8002714:	f7ff fc22 	bl	8001f5c <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 8002718:	683b      	ldr	r3, [r7, #0]
	xTimeNow = xTaskGetTickCount();
 800271a:	0005      	movs	r5, r0
	if( xTimeNow < xLastTime )
 800271c:	4298      	cmp	r0, r3
 800271e:	d201      	bcs.n	8002724 <prvTimerTask+0xc0>
		prvSwitchTimerLists();
 8002720:	f7ff ff6e 	bl	8002600 <prvSwitchTimerLists>
 8002724:	9b05      	ldr	r3, [sp, #20]
	xLastTime = xTimeNow;
 8002726:	603d      	str	r5, [r7, #0]
 8002728:	2b09      	cmp	r3, #9
 800272a:	d8e0      	bhi.n	80026ee <prvTimerTask+0x8a>
 800272c:	2201      	movs	r2, #1
 800272e:	2684      	movs	r6, #132	; 0x84
 8002730:	409a      	lsls	r2, r3
 8002732:	00b6      	lsls	r6, r6, #2
 8002734:	0013      	movs	r3, r2
 8002736:	4016      	ands	r6, r2
 8002738:	d13b      	bne.n	80027b2 <prvTimerTask+0x14e>
 800273a:	22c7      	movs	r2, #199	; 0xc7
 800273c:	4213      	tst	r3, r2
 800273e:	d11b      	bne.n	8002778 <prvTimerTask+0x114>
 8002740:	069b      	lsls	r3, r3, #26
 8002742:	d5d4      	bpl.n	80026ee <prvTimerTask+0x8a>
						vPortFree( pxTimer );
 8002744:	0020      	movs	r0, r4
 8002746:	f7fe ff9b 	bl	8001680 <vPortFree>
 800274a:	e7d0      	b.n	80026ee <prvTimerTask+0x8a>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 800274c:	4b22      	ldr	r3, [pc, #136]	; (80027d8 <prvTimerTask+0x174>)
 800274e:	681b      	ldr	r3, [r3, #0]
 8002750:	681a      	ldr	r2, [r3, #0]
 8002752:	4250      	negs	r0, r2
 8002754:	4150      	adcs	r0, r2
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8002756:	9b02      	ldr	r3, [sp, #8]
 8002758:	0002      	movs	r2, r0
 800275a:	1af1      	subs	r1, r6, r3
 800275c:	4b1d      	ldr	r3, [pc, #116]	; (80027d4 <prvTimerTask+0x170>)
 800275e:	6818      	ldr	r0, [r3, #0]
 8002760:	f7ff fa90 	bl	8001c84 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 8002764:	f7ff fc7e 	bl	8002064 <xTaskResumeAll>
 8002768:	2800      	cmp	r0, #0
 800276a:	d1c0      	bne.n	80026ee <prvTimerTask+0x8a>
					portYIELD_WITHIN_API();
 800276c:	f7fe fe4c 	bl	8001408 <vPortYield>
 8002770:	e7bd      	b.n	80026ee <prvTimerTask+0x8a>
			( void ) xTaskResumeAll();
 8002772:	f7ff fc77 	bl	8002064 <xTaskResumeAll>
 8002776:	e7ba      	b.n	80026ee <prvTimerTask+0x8a>
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 8002778:	9b06      	ldr	r3, [sp, #24]
 800277a:	69a2      	ldr	r2, [r4, #24]
 800277c:	0020      	movs	r0, r4
 800277e:	1899      	adds	r1, r3, r2
 8002780:	002a      	movs	r2, r5
 8002782:	9302      	str	r3, [sp, #8]
 8002784:	f7ff febc 	bl	8002500 <prvInsertTimerInActiveList>
 8002788:	2800      	cmp	r0, #0
 800278a:	d0b0      	beq.n	80026ee <prvTimerTask+0x8a>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 800278c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800278e:	0020      	movs	r0, r4
 8002790:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8002792:	69e3      	ldr	r3, [r4, #28]
 8002794:	2b01      	cmp	r3, #1
 8002796:	d1aa      	bne.n	80026ee <prvTimerTask+0x8a>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 8002798:	69a3      	ldr	r3, [r4, #24]
 800279a:	9a06      	ldr	r2, [sp, #24]
 800279c:	9600      	str	r6, [sp, #0]
 800279e:	18d2      	adds	r2, r2, r3
 80027a0:	0031      	movs	r1, r6
 80027a2:	0033      	movs	r3, r6
 80027a4:	0020      	movs	r0, r4
 80027a6:	f7ff ff03 	bl	80025b0 <xTimerGenericCommand>
							configASSERT( xResult );
 80027aa:	2800      	cmp	r0, #0
 80027ac:	d19f      	bne.n	80026ee <prvTimerTask+0x8a>
 80027ae:	b672      	cpsid	i
 80027b0:	e7fe      	b.n	80027b0 <prvTimerTask+0x14c>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 80027b2:	9906      	ldr	r1, [sp, #24]
 80027b4:	61a1      	str	r1, [r4, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 80027b6:	2900      	cmp	r1, #0
 80027b8:	d101      	bne.n	80027be <prvTimerTask+0x15a>
 80027ba:	b672      	cpsid	i
 80027bc:	e7fe      	b.n	80027bc <prvTimerTask+0x158>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 80027be:	1949      	adds	r1, r1, r5
 80027c0:	002b      	movs	r3, r5
 80027c2:	002a      	movs	r2, r5
 80027c4:	0020      	movs	r0, r4
 80027c6:	f7ff fe9b 	bl	8002500 <prvInsertTimerInActiveList>
 80027ca:	e790      	b.n	80026ee <prvTimerTask+0x8a>
 80027cc:	20001258 	.word	0x20001258
 80027d0:	20001288 	.word	0x20001288
 80027d4:	2000128c 	.word	0x2000128c
 80027d8:	2000125c 	.word	0x2000125c

080027dc <MX_FATFS_Init>:
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */    

void MX_FATFS_Init(void) 
{
 80027dc:	b510      	push	{r4, lr}
  /*## FatFS: Link the USER driver ###########################*/
  retUSER = FATFS_LinkDriver(&USER_Driver, USERPath);
 80027de:	4903      	ldr	r1, [pc, #12]	; (80027ec <MX_FATFS_Init+0x10>)
 80027e0:	4803      	ldr	r0, [pc, #12]	; (80027f0 <MX_FATFS_Init+0x14>)
 80027e2:	f7fe fd01 	bl	80011e8 <FATFS_LinkDriver>
 80027e6:	4b03      	ldr	r3, [pc, #12]	; (80027f4 <MX_FATFS_Init+0x18>)
 80027e8:	7018      	strb	r0, [r3, #0]

  /* USER CODE BEGIN Init */
  /* additional user code for init */     
  /* USER CODE END Init */
}
 80027ea:	bd10      	pop	{r4, pc}
 80027ec:	200012e8 	.word	0x200012e8
 80027f0:	2000000c 	.word	0x2000000c
 80027f4:	200012ec 	.word	0x200012ec

080027f8 <LL_AHB1_GRP1_EnableClock>:
  * @retval None
*/
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHBENR, Periphs);
 80027f8:	4b05      	ldr	r3, [pc, #20]	; (8002810 <LL_AHB1_GRP1_EnableClock+0x18>)
{
 80027fa:	b082      	sub	sp, #8
  SET_BIT(RCC->AHBENR, Periphs);
 80027fc:	695a      	ldr	r2, [r3, #20]
 80027fe:	4302      	orrs	r2, r0
 8002800:	615a      	str	r2, [r3, #20]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHBENR, Periphs);
 8002802:	695b      	ldr	r3, [r3, #20]
 8002804:	4018      	ands	r0, r3
 8002806:	9001      	str	r0, [sp, #4]
  (void)tmpreg;
 8002808:	9b01      	ldr	r3, [sp, #4]
}
 800280a:	b002      	add	sp, #8
 800280c:	4770      	bx	lr
 800280e:	46c0      	nop			; (mov r8, r8)
 8002810:	40021000 	.word	0x40021000

08002814 <Callback01>:
void Callback01(void const * argument)
{
  /* USER CODE BEGIN Callback01 */
  
  /* USER CODE END Callback01 */
}
 8002814:	4770      	bx	lr

08002816 <StartLEDTask>:
{
 8002816:	b510      	push	{r4, lr}
  MX_FATFS_Init();
 8002818:	f7ff ffe0 	bl	80027dc <MX_FATFS_Init>
    osDelay(1);
 800281c:	2001      	movs	r0, #1
 800281e:	f7fe fd05 	bl	800122c <osDelay>
 8002822:	e7fb      	b.n	800281c <StartLEDTask+0x6>

08002824 <SystemClock_Config>:
{
 8002824:	b570      	push	{r4, r5, r6, lr}
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8002826:	2510      	movs	r5, #16
{
 8002828:	b094      	sub	sp, #80	; 0x50
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800282a:	2230      	movs	r2, #48	; 0x30
 800282c:	2100      	movs	r1, #0
 800282e:	a808      	add	r0, sp, #32
 8002830:	f000 fdbf 	bl	80033b2 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8002834:	002a      	movs	r2, r5
 8002836:	2100      	movs	r1, #0
 8002838:	4668      	mov	r0, sp
 800283a:	f000 fdba 	bl	80033b2 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 800283e:	2100      	movs	r1, #0
 8002840:	002a      	movs	r2, r5
 8002842:	a804      	add	r0, sp, #16
 8002844:	f000 fdb5 	bl	80033b2 <memset>
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
 8002848:	2380      	movs	r3, #128	; 0x80
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 800284a:	2402      	movs	r4, #2
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 800284c:	2601      	movs	r6, #1
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
 800284e:	035b      	lsls	r3, r3, #13
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8002850:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8002852:	9408      	str	r4, [sp, #32]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8002854:	960b      	str	r6, [sp, #44]	; 0x2c
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8002856:	950c      	str	r5, [sp, #48]	; 0x30
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8002858:	9410      	str	r4, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
 800285a:	9312      	str	r3, [sp, #72]	; 0x48
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800285c:	f7fd ff04 	bl	8000668 <HAL_RCC_OscConfig>
 8002860:	1e01      	subs	r1, r0, #0
 8002862:	d000      	beq.n	8002866 <SystemClock_Config+0x42>
 8002864:	e7fe      	b.n	8002864 <SystemClock_Config+0x40>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8002866:	2307      	movs	r3, #7
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8002868:	9002      	str	r0, [sp, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 800286a:	9003      	str	r0, [sp, #12]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 800286c:	4668      	mov	r0, sp
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800286e:	9300      	str	r3, [sp, #0]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8002870:	9401      	str	r4, [sp, #4]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 8002872:	f7fe f90d 	bl	8000a90 <HAL_RCC_ClockConfig>
 8002876:	2800      	cmp	r0, #0
 8002878:	d000      	beq.n	800287c <SystemClock_Config+0x58>
 800287a:	e7fe      	b.n	800287a <SystemClock_Config+0x56>
  PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1;
 800287c:	9006      	str	r0, [sp, #24]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 800287e:	a804      	add	r0, sp, #16
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;
 8002880:	9604      	str	r6, [sp, #16]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8002882:	f7fe f9c7 	bl	8000c14 <HAL_RCCEx_PeriphCLKConfig>
 8002886:	2800      	cmp	r0, #0
 8002888:	d000      	beq.n	800288c <SystemClock_Config+0x68>
 800288a:	e7fe      	b.n	800288a <SystemClock_Config+0x66>
}
 800288c:	b014      	add	sp, #80	; 0x50
 800288e:	bd70      	pop	{r4, r5, r6, pc}

08002890 <main>:
{
 8002890:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002892:	b099      	sub	sp, #100	; 0x64
  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 8002894:	ac11      	add	r4, sp, #68	; 0x44
  HAL_Init();
 8002896:	f7fd fcc3 	bl	8000220 <HAL_Init>
  SystemClock_Config();
 800289a:	f7ff ffc3 	bl	8002824 <SystemClock_Config>
  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 800289e:	2218      	movs	r2, #24
 80028a0:	2100      	movs	r1, #0
 80028a2:	0020      	movs	r0, r4
 80028a4:	f000 fd85 	bl	80033b2 <memset>
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOC);
 80028a8:	2080      	movs	r0, #128	; 0x80
 80028aa:	0300      	lsls	r0, r0, #12
 80028ac:	f7ff ffa4 	bl	80027f8 <LL_AHB1_GRP1_EnableClock>
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOF);
 80028b0:	2080      	movs	r0, #128	; 0x80
 80028b2:	03c0      	lsls	r0, r0, #15
 80028b4:	f7ff ffa0 	bl	80027f8 <LL_AHB1_GRP1_EnableClock>
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);
 80028b8:	2080      	movs	r0, #128	; 0x80
 80028ba:	0280      	lsls	r0, r0, #10
 80028bc:	f7ff ff9c 	bl	80027f8 <LL_AHB1_GRP1_EnableClock>
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOB);
 80028c0:	2080      	movs	r0, #128	; 0x80
 80028c2:	02c0      	lsls	r0, r0, #11
 80028c4:	f7ff ff98 	bl	80027f8 <LL_AHB1_GRP1_EnableClock>
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  WRITE_REG(GPIOx->BRR, PinMask);
 80028c8:	2390      	movs	r3, #144	; 0x90
 80028ca:	2210      	movs	r2, #16
 80028cc:	05db      	lsls	r3, r3, #23
 80028ce:	629a      	str	r2, [r3, #40]	; 0x28
 80028d0:	1892      	adds	r2, r2, r2
 80028d2:	629a      	str	r2, [r3, #40]	; 0x28
 80028d4:	3220      	adds	r2, #32
 80028d6:	629a      	str	r2, [r3, #40]	; 0x28
 80028d8:	2302      	movs	r3, #2
 80028da:	4efe      	ldr	r6, [pc, #1016]	; (8002cd4 <main+0x444>)
 80028dc:	32c0      	adds	r2, #192	; 0xc0
 80028de:	62b3      	str	r3, [r6, #40]	; 0x28
 80028e0:	18db      	adds	r3, r3, r3
 80028e2:	62b3      	str	r3, [r6, #40]	; 0x28
 80028e4:	2380      	movs	r3, #128	; 0x80
 80028e6:	00db      	lsls	r3, r3, #3
 80028e8:	62b3      	str	r3, [r6, #40]	; 0x28
 80028ea:	2380      	movs	r3, #128	; 0x80
 80028ec:	011b      	lsls	r3, r3, #4
 80028ee:	62b3      	str	r3, [r6, #40]	; 0x28
 80028f0:	2380      	movs	r3, #128	; 0x80
 80028f2:	015b      	lsls	r3, r3, #5
 80028f4:	62b3      	str	r3, [r6, #40]	; 0x28
 80028f6:	2380      	movs	r3, #128	; 0x80
 80028f8:	019b      	lsls	r3, r3, #6
 80028fa:	62b3      	str	r3, [r6, #40]	; 0x28
 80028fc:	2380      	movs	r3, #128	; 0x80
 80028fe:	01db      	lsls	r3, r3, #7
 8002900:	62b3      	str	r3, [r6, #40]	; 0x28
 8002902:	2380      	movs	r3, #128	; 0x80
 8002904:	021b      	lsls	r3, r3, #8
 8002906:	62b3      	str	r3, [r6, #40]	; 0x28
 8002908:	2390      	movs	r3, #144	; 0x90
 800290a:	05db      	lsls	r3, r3, #23
 800290c:	629a      	str	r2, [r3, #40]	; 0x28
 800290e:	2280      	movs	r2, #128	; 0x80
 8002910:	0112      	lsls	r2, r2, #4
 8002912:	629a      	str	r2, [r3, #40]	; 0x28
 8002914:	2280      	movs	r2, #128	; 0x80
 8002916:	0152      	lsls	r2, r2, #5
 8002918:	629a      	str	r2, [r3, #40]	; 0x28
 800291a:	2240      	movs	r2, #64	; 0x40
 800291c:	4bee      	ldr	r3, [pc, #952]	; (8002cd8 <main+0x448>)
  GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
 800291e:	2500      	movs	r5, #0
 8002920:	629a      	str	r2, [r3, #40]	; 0x28
 8002922:	1892      	adds	r2, r2, r2
 8002924:	629a      	str	r2, [r3, #40]	; 0x28
 8002926:	2390      	movs	r3, #144	; 0x90
 8002928:	2280      	movs	r2, #128	; 0x80
 800292a:	05db      	lsls	r3, r3, #23
 800292c:	0212      	lsls	r2, r2, #8
 800292e:	629a      	str	r2, [r3, #40]	; 0x28
 8002930:	2308      	movs	r3, #8
 8002932:	62b3      	str	r3, [r6, #40]	; 0x28
 8002934:	18db      	adds	r3, r3, r3
 8002936:	62b3      	str	r3, [r6, #40]	; 0x28
 8002938:	3310      	adds	r3, #16
 800293a:	62b3      	str	r3, [r6, #40]	; 0x28
 800293c:	3320      	adds	r3, #32
 800293e:	62b3      	str	r3, [r6, #40]	; 0x28
 8002940:	3340      	adds	r3, #64	; 0x40
 8002942:	62b3      	str	r3, [r6, #40]	; 0x28
 8002944:	3380      	adds	r3, #128	; 0x80
 8002946:	62b3      	str	r3, [r6, #40]	; 0x28
 8002948:	3301      	adds	r3, #1
 800294a:	33ff      	adds	r3, #255	; 0xff
 800294c:	62b3      	str	r3, [r6, #40]	; 0x28
  GPIO_InitStruct.Pin = AJ_1_Pin;
 800294e:	2380      	movs	r3, #128	; 0x80
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002950:	2701      	movs	r7, #1
  GPIO_InitStruct.Pin = AJ_1_Pin;
 8002952:	019b      	lsls	r3, r3, #6
  LL_GPIO_Init(AJ_1_GPIO_Port, &GPIO_InitStruct);
 8002954:	0021      	movs	r1, r4
 8002956:	48e1      	ldr	r0, [pc, #900]	; (8002cdc <main+0x44c>)
  GPIO_InitStruct.Pin = AJ_1_Pin;
 8002958:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
 800295a:	6065      	str	r5, [r4, #4]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 800295c:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(AJ_1_GPIO_Port, &GPIO_InitStruct);
 800295e:	f7fe faf6 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = AJ_2_Pin;
 8002962:	2380      	movs	r3, #128	; 0x80
  LL_GPIO_Init(AJ_2_GPIO_Port, &GPIO_InitStruct);
 8002964:	0021      	movs	r1, r4
  GPIO_InitStruct.Pin = AJ_2_Pin;
 8002966:	01db      	lsls	r3, r3, #7
  LL_GPIO_Init(AJ_2_GPIO_Port, &GPIO_InitStruct);
 8002968:	48dc      	ldr	r0, [pc, #880]	; (8002cdc <main+0x44c>)
  GPIO_InitStruct.Pin = AJ_2_Pin;
 800296a:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
 800296c:	6065      	str	r5, [r4, #4]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 800296e:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(AJ_2_GPIO_Port, &GPIO_InitStruct);
 8002970:	f7fe faed 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = AJ_3_Pin;
 8002974:	2380      	movs	r3, #128	; 0x80
  LL_GPIO_Init(AJ_3_GPIO_Port, &GPIO_InitStruct);
 8002976:	0021      	movs	r1, r4
  GPIO_InitStruct.Pin = AJ_3_Pin;
 8002978:	021b      	lsls	r3, r3, #8
  LL_GPIO_Init(AJ_3_GPIO_Port, &GPIO_InitStruct);
 800297a:	48d8      	ldr	r0, [pc, #864]	; (8002cdc <main+0x44c>)
  GPIO_InitStruct.Pin = AJ_3_Pin;
 800297c:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
 800297e:	6065      	str	r5, [r4, #4]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002980:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(AJ_3_GPIO_Port, &GPIO_InitStruct);
 8002982:	f7fe fae4 	bl	8000f4e <LL_GPIO_Init>
  LL_GPIO_Init(AJ_4_GPIO_Port, &GPIO_InitStruct);
 8002986:	0021      	movs	r1, r4
 8002988:	48d3      	ldr	r0, [pc, #844]	; (8002cd8 <main+0x448>)
  GPIO_InitStruct.Pin = AJ_4_Pin;
 800298a:	9711      	str	r7, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
 800298c:	6065      	str	r5, [r4, #4]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 800298e:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(AJ_4_GPIO_Port, &GPIO_InitStruct);
 8002990:	f7fe fadd 	bl	8000f4e <LL_GPIO_Init>
  LL_GPIO_Init(D1_GPIO_Port, &GPIO_InitStruct);
 8002994:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pin = D1_Pin;
 8002996:	2310      	movs	r3, #16
  LL_GPIO_Init(D1_GPIO_Port, &GPIO_InitStruct);
 8002998:	0021      	movs	r1, r4
 800299a:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = D1_Pin;
 800299c:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 800299e:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 80029a0:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 80029a2:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 80029a4:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(D1_GPIO_Port, &GPIO_InitStruct);
 80029a6:	f7fe fad2 	bl	8000f4e <LL_GPIO_Init>
  LL_GPIO_Init(D2_GPIO_Port, &GPIO_InitStruct);
 80029aa:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pin = D2_Pin;
 80029ac:	2320      	movs	r3, #32
  LL_GPIO_Init(D2_GPIO_Port, &GPIO_InitStruct);
 80029ae:	0021      	movs	r1, r4
 80029b0:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = D2_Pin;
 80029b2:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 80029b4:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 80029b6:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 80029b8:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 80029ba:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(D2_GPIO_Port, &GPIO_InitStruct);
 80029bc:	f7fe fac7 	bl	8000f4e <LL_GPIO_Init>
  LL_GPIO_Init(D3_GPIO_Port, &GPIO_InitStruct);
 80029c0:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pin = D3_Pin;
 80029c2:	2340      	movs	r3, #64	; 0x40
  LL_GPIO_Init(D3_GPIO_Port, &GPIO_InitStruct);
 80029c4:	0021      	movs	r1, r4
 80029c6:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = D3_Pin;
 80029c8:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 80029ca:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 80029cc:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 80029ce:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 80029d0:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(D3_GPIO_Port, &GPIO_InitStruct);
 80029d2:	f7fe fabc 	bl	8000f4e <LL_GPIO_Init>
  LL_GPIO_Init(RZCGQ_GPIO_Port, &GPIO_InitStruct);
 80029d6:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pin = RZCGQ_Pin;
 80029d8:	2380      	movs	r3, #128	; 0x80
  LL_GPIO_Init(RZCGQ_GPIO_Port, &GPIO_InitStruct);
 80029da:	0021      	movs	r1, r4
 80029dc:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = RZCGQ_Pin;
 80029de:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
 80029e0:	6065      	str	r5, [r4, #4]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 80029e2:	6125      	str	r5, [r4, #16]
  LL_GPIO_Init(RZCGQ_GPIO_Port, &GPIO_InitStruct);
 80029e4:	f7fe fab3 	bl	8000f4e <LL_GPIO_Init>
  LL_GPIO_Init(XBJT_GPIO_Port, &GPIO_InitStruct);
 80029e8:	0021      	movs	r1, r4
 80029ea:	0030      	movs	r0, r6
  GPIO_InitStruct.Pin = XBJT_Pin;
 80029ec:	9711      	str	r7, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
 80029ee:	6065      	str	r5, [r4, #4]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 80029f0:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(XBJT_GPIO_Port, &GPIO_InitStruct);
 80029f2:	f7fe faac 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = MCF_2_Pin;
 80029f6:	2302      	movs	r3, #2
  LL_GPIO_Init(MCF_2_GPIO_Port, &GPIO_InitStruct);
 80029f8:	0021      	movs	r1, r4
 80029fa:	0030      	movs	r0, r6
  GPIO_InitStruct.Pin = MCF_2_Pin;
 80029fc:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 80029fe:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002a00:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002a02:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002a04:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(MCF_2_GPIO_Port, &GPIO_InitStruct);
 8002a06:	f7fe faa2 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = MCF_1_Pin;
 8002a0a:	2304      	movs	r3, #4
  LL_GPIO_Init(MCF_1_GPIO_Port, &GPIO_InitStruct);
 8002a0c:	0021      	movs	r1, r4
 8002a0e:	0030      	movs	r0, r6
  GPIO_InitStruct.Pin = MCF_1_Pin;
 8002a10:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002a12:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002a14:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002a16:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002a18:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(MCF_1_GPIO_Port, &GPIO_InitStruct);
 8002a1a:	f7fe fa98 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = MCF_4_Pin;
 8002a1e:	2380      	movs	r3, #128	; 0x80
  LL_GPIO_Init(MCF_4_GPIO_Port, &GPIO_InitStruct);
 8002a20:	0021      	movs	r1, r4
  GPIO_InitStruct.Pin = MCF_4_Pin;
 8002a22:	00db      	lsls	r3, r3, #3
  LL_GPIO_Init(MCF_4_GPIO_Port, &GPIO_InitStruct);
 8002a24:	0030      	movs	r0, r6
  GPIO_InitStruct.Pin = MCF_4_Pin;
 8002a26:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002a28:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002a2a:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002a2c:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002a2e:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(MCF_4_GPIO_Port, &GPIO_InitStruct);
 8002a30:	f7fe fa8d 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = MCF_3_Pin;
 8002a34:	2380      	movs	r3, #128	; 0x80
  LL_GPIO_Init(MCF_3_GPIO_Port, &GPIO_InitStruct);
 8002a36:	0021      	movs	r1, r4
  GPIO_InitStruct.Pin = MCF_3_Pin;
 8002a38:	011b      	lsls	r3, r3, #4
  LL_GPIO_Init(MCF_3_GPIO_Port, &GPIO_InitStruct);
 8002a3a:	0030      	movs	r0, r6
  GPIO_InitStruct.Pin = MCF_3_Pin;
 8002a3c:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002a3e:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002a40:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002a42:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002a44:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(MCF_3_GPIO_Port, &GPIO_InitStruct);
 8002a46:	f7fe fa82 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = DCS_Pin;
 8002a4a:	2380      	movs	r3, #128	; 0x80
  LL_GPIO_Init(DCS_GPIO_Port, &GPIO_InitStruct);
 8002a4c:	0021      	movs	r1, r4
  GPIO_InitStruct.Pin = DCS_Pin;
 8002a4e:	015b      	lsls	r3, r3, #5
  LL_GPIO_Init(DCS_GPIO_Port, &GPIO_InitStruct);
 8002a50:	0030      	movs	r0, r6
  GPIO_InitStruct.Pin = DCS_Pin;
 8002a52:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002a54:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002a56:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002a58:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002a5a:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(DCS_GPIO_Port, &GPIO_InitStruct);
 8002a5c:	f7fe fa77 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = HG_JRS_Pin;
 8002a60:	2380      	movs	r3, #128	; 0x80
  LL_GPIO_Init(HG_JRS_GPIO_Port, &GPIO_InitStruct);
 8002a62:	0021      	movs	r1, r4
  GPIO_InitStruct.Pin = HG_JRS_Pin;
 8002a64:	019b      	lsls	r3, r3, #6
  LL_GPIO_Init(HG_JRS_GPIO_Port, &GPIO_InitStruct);
 8002a66:	0030      	movs	r0, r6
  GPIO_InitStruct.Pin = HG_JRS_Pin;
 8002a68:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002a6a:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002a6c:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002a6e:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002a70:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(HG_JRS_GPIO_Port, &GPIO_InitStruct);
 8002a72:	f7fe fa6c 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = ZQ_JRS_Pin;
 8002a76:	2380      	movs	r3, #128	; 0x80
  LL_GPIO_Init(ZQ_JRS_GPIO_Port, &GPIO_InitStruct);
 8002a78:	0021      	movs	r1, r4
  GPIO_InitStruct.Pin = ZQ_JRS_Pin;
 8002a7a:	01db      	lsls	r3, r3, #7
  LL_GPIO_Init(ZQ_JRS_GPIO_Port, &GPIO_InitStruct);
 8002a7c:	0030      	movs	r0, r6
  GPIO_InitStruct.Pin = ZQ_JRS_Pin;
 8002a7e:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002a80:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002a82:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002a84:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002a86:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(ZQ_JRS_GPIO_Port, &GPIO_InitStruct);
 8002a88:	f7fe fa61 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = QB_Pin;
 8002a8c:	2380      	movs	r3, #128	; 0x80
  LL_GPIO_Init(QB_GPIO_Port, &GPIO_InitStruct);
 8002a8e:	0021      	movs	r1, r4
  GPIO_InitStruct.Pin = QB_Pin;
 8002a90:	021b      	lsls	r3, r3, #8
  LL_GPIO_Init(QB_GPIO_Port, &GPIO_InitStruct);
 8002a92:	0030      	movs	r0, r6
  GPIO_InitStruct.Pin = QB_Pin;
 8002a94:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002a96:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002a98:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002a9a:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8002a9c:	6125      	str	r5, [r4, #16]
  LL_GPIO_Init(QB_GPIO_Port, &GPIO_InitStruct);
 8002a9e:	f7fe fa56 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = DCF_Pin;
 8002aa2:	2380      	movs	r3, #128	; 0x80
  LL_GPIO_Init(DCF_GPIO_Port, &GPIO_InitStruct);
 8002aa4:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pin = DCF_Pin;
 8002aa6:	005b      	lsls	r3, r3, #1
  LL_GPIO_Init(DCF_GPIO_Port, &GPIO_InitStruct);
 8002aa8:	0021      	movs	r1, r4
 8002aaa:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = DCF_Pin;
 8002aac:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002aae:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002ab0:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002ab2:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002ab4:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(DCF_GPIO_Port, &GPIO_InitStruct);
 8002ab6:	f7fe fa4a 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = CC_Pin;
 8002aba:	2380      	movs	r3, #128	; 0x80
  LL_GPIO_Init(CC_GPIO_Port, &GPIO_InitStruct);
 8002abc:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pin = CC_Pin;
 8002abe:	011b      	lsls	r3, r3, #4
  LL_GPIO_Init(CC_GPIO_Port, &GPIO_InitStruct);
 8002ac0:	0021      	movs	r1, r4
 8002ac2:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = CC_Pin;
 8002ac4:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002ac6:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002ac8:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002aca:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002acc:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(CC_GPIO_Port, &GPIO_InitStruct);
 8002ace:	f7fe fa3e 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = HG_FAN_Pin;
 8002ad2:	2380      	movs	r3, #128	; 0x80
  LL_GPIO_Init(HG_FAN_GPIO_Port, &GPIO_InitStruct);
 8002ad4:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pin = HG_FAN_Pin;
 8002ad6:	015b      	lsls	r3, r3, #5
  LL_GPIO_Init(HG_FAN_GPIO_Port, &GPIO_InitStruct);
 8002ad8:	0021      	movs	r1, r4
 8002ada:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = HG_FAN_Pin;
 8002adc:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002ade:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002ae0:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002ae2:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002ae4:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(HG_FAN_GPIO_Port, &GPIO_InitStruct);
 8002ae6:	f7fe fa32 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = ZM_Pin;
 8002aea:	2340      	movs	r3, #64	; 0x40
  LL_GPIO_Init(ZM_GPIO_Port, &GPIO_InitStruct);
 8002aec:	0021      	movs	r1, r4
 8002aee:	487a      	ldr	r0, [pc, #488]	; (8002cd8 <main+0x448>)
  GPIO_InitStruct.Pin = ZM_Pin;
 8002af0:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002af2:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002af4:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002af6:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002af8:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(ZM_GPIO_Port, &GPIO_InitStruct);
 8002afa:	f7fe fa28 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = FMQ_Pin;
 8002afe:	2380      	movs	r3, #128	; 0x80
  LL_GPIO_Init(FMQ_GPIO_Port, &GPIO_InitStruct);
 8002b00:	0021      	movs	r1, r4
 8002b02:	4875      	ldr	r0, [pc, #468]	; (8002cd8 <main+0x448>)
  GPIO_InitStruct.Pin = FMQ_Pin;
 8002b04:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002b06:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002b08:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002b0a:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002b0c:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(FMQ_GPIO_Port, &GPIO_InitStruct);
 8002b0e:	f7fe fa1e 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = BJJ_8_Pin;
 8002b12:	2380      	movs	r3, #128	; 0x80
  LL_GPIO_Init(BJJ_8_GPIO_Port, &GPIO_InitStruct);
 8002b14:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pin = BJJ_8_Pin;
 8002b16:	021b      	lsls	r3, r3, #8
  LL_GPIO_Init(BJJ_8_GPIO_Port, &GPIO_InitStruct);
 8002b18:	0021      	movs	r1, r4
 8002b1a:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = BJJ_8_Pin;
 8002b1c:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002b1e:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002b20:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002b22:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002b24:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(BJJ_8_GPIO_Port, &GPIO_InitStruct);
 8002b26:	f7fe fa12 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = BJJ_7_Pin;
 8002b2a:	2308      	movs	r3, #8
  LL_GPIO_Init(BJJ_7_GPIO_Port, &GPIO_InitStruct);
 8002b2c:	0021      	movs	r1, r4
 8002b2e:	0030      	movs	r0, r6
  GPIO_InitStruct.Pin = BJJ_7_Pin;
 8002b30:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002b32:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002b34:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002b36:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002b38:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(BJJ_7_GPIO_Port, &GPIO_InitStruct);
 8002b3a:	f7fe fa08 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = BJJ_6_Pin;
 8002b3e:	2310      	movs	r3, #16
  LL_GPIO_Init(BJJ_6_GPIO_Port, &GPIO_InitStruct);
 8002b40:	0021      	movs	r1, r4
 8002b42:	0030      	movs	r0, r6
  GPIO_InitStruct.Pin = BJJ_6_Pin;
 8002b44:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002b46:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002b48:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002b4a:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002b4c:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(BJJ_6_GPIO_Port, &GPIO_InitStruct);
 8002b4e:	f7fe f9fe 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = BJJ_5_Pin;
 8002b52:	2320      	movs	r3, #32
  LL_GPIO_Init(BJJ_5_GPIO_Port, &GPIO_InitStruct);
 8002b54:	0021      	movs	r1, r4
 8002b56:	0030      	movs	r0, r6
  GPIO_InitStruct.Pin = BJJ_5_Pin;
 8002b58:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002b5a:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002b5c:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002b5e:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002b60:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(BJJ_5_GPIO_Port, &GPIO_InitStruct);
 8002b62:	f7fe f9f4 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = BJJ_4_Pin;
 8002b66:	2340      	movs	r3, #64	; 0x40
  LL_GPIO_Init(BJJ_4_GPIO_Port, &GPIO_InitStruct);
 8002b68:	0021      	movs	r1, r4
 8002b6a:	0030      	movs	r0, r6
  GPIO_InitStruct.Pin = BJJ_4_Pin;
 8002b6c:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002b6e:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002b70:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002b72:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002b74:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(BJJ_4_GPIO_Port, &GPIO_InitStruct);
 8002b76:	f7fe f9ea 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = BJJ_3_Pin;
 8002b7a:	2380      	movs	r3, #128	; 0x80
  LL_GPIO_Init(BJJ_3_GPIO_Port, &GPIO_InitStruct);
 8002b7c:	0021      	movs	r1, r4
 8002b7e:	0030      	movs	r0, r6
  GPIO_InitStruct.Pin = BJJ_3_Pin;
 8002b80:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002b82:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002b84:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002b86:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002b88:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(BJJ_3_GPIO_Port, &GPIO_InitStruct);
 8002b8a:	f7fe f9e0 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = BJJ_2_Pin;
 8002b8e:	2380      	movs	r3, #128	; 0x80
  LL_GPIO_Init(BJJ_2_GPIO_Port, &GPIO_InitStruct);
 8002b90:	0021      	movs	r1, r4
  GPIO_InitStruct.Pin = BJJ_2_Pin;
 8002b92:	005b      	lsls	r3, r3, #1
  LL_GPIO_Init(BJJ_2_GPIO_Port, &GPIO_InitStruct);
 8002b94:	0030      	movs	r0, r6
  GPIO_InitStruct.Pin = BJJ_2_Pin;
 8002b96:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002b98:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002b9a:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002b9c:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002b9e:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(BJJ_2_GPIO_Port, &GPIO_InitStruct);
 8002ba0:	f7fe f9d5 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = BJJ_1_Pin;
 8002ba4:	2380      	movs	r3, #128	; 0x80
  LL_GPIO_Init(BJJ_1_GPIO_Port, &GPIO_InitStruct);
 8002ba6:	0021      	movs	r1, r4
  GPIO_InitStruct.Pin = BJJ_1_Pin;
 8002ba8:	009b      	lsls	r3, r3, #2
  LL_GPIO_Init(BJJ_1_GPIO_Port, &GPIO_InitStruct);
 8002baa:	0030      	movs	r0, r6
  GPIO_InitStruct.Pin = BJJ_1_Pin;
 8002bac:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8002bae:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8002bb0:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002bb2:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8002bb4:	6127      	str	r7, [r4, #16]
  LL_GPIO_Init(BJJ_1_GPIO_Port, &GPIO_InitStruct);
 8002bb6:	f7fe f9ca 	bl	8000f4e <LL_GPIO_Init>
  __HAL_RCC_DMA1_CLK_ENABLE();
 8002bba:	4b49      	ldr	r3, [pc, #292]	; (8002ce0 <main+0x450>)
 8002bbc:	4a48      	ldr	r2, [pc, #288]	; (8002ce0 <main+0x450>)
 8002bbe:	695b      	ldr	r3, [r3, #20]
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002bc0:	4948      	ldr	r1, [pc, #288]	; (8002ce4 <main+0x454>)
 8002bc2:	433b      	orrs	r3, r7
 8002bc4:	6153      	str	r3, [r2, #20]
 8002bc6:	6953      	ldr	r3, [r2, #20]
 8002bc8:	22c2      	movs	r2, #194	; 0xc2
 8002bca:	403b      	ands	r3, r7
 8002bcc:	9304      	str	r3, [sp, #16]
 8002bce:	9b04      	ldr	r3, [sp, #16]
 8002bd0:	4b45      	ldr	r3, [pc, #276]	; (8002ce8 <main+0x458>)
 8002bd2:	0092      	lsls	r2, r2, #2
 8002bd4:	589b      	ldr	r3, [r3, r2]
  LL_USART_InitTypeDef USART_InitStruct = {0};
 8002bd6:	0020      	movs	r0, r4
 8002bd8:	4019      	ands	r1, r3
 8002bda:	23c0      	movs	r3, #192	; 0xc0
 8002bdc:	041b      	lsls	r3, r3, #16
 8002bde:	430b      	orrs	r3, r1
 8002be0:	4941      	ldr	r1, [pc, #260]	; (8002ce8 <main+0x458>)
  LL_USART_Init(USART2, &USART_InitStruct);
 8002be2:	4e42      	ldr	r6, [pc, #264]	; (8002cec <main+0x45c>)
 8002be4:	508b      	str	r3, [r1, r2]
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8002be6:	000b      	movs	r3, r1
 8002be8:	2180      	movs	r1, #128	; 0x80
 8002bea:	00c9      	lsls	r1, r1, #3
 8002bec:	6019      	str	r1, [r3, #0]
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002bee:	21c0      	movs	r1, #192	; 0xc0
 8002bf0:	589b      	ldr	r3, [r3, r2]
 8002bf2:	0609      	lsls	r1, r1, #24
 8002bf4:	021b      	lsls	r3, r3, #8
 8002bf6:	0a1b      	lsrs	r3, r3, #8
 8002bf8:	430b      	orrs	r3, r1
 8002bfa:	493b      	ldr	r1, [pc, #236]	; (8002ce8 <main+0x458>)
 8002bfc:	508b      	str	r3, [r1, r2]
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8002bfe:	2280      	movs	r2, #128	; 0x80
 8002c00:	0112      	lsls	r2, r2, #4
 8002c02:	600a      	str	r2, [r1, #0]
  LL_USART_InitTypeDef USART_InitStruct = {0};
 8002c04:	221c      	movs	r2, #28
 8002c06:	0029      	movs	r1, r5
 8002c08:	f000 fbd3 	bl	80033b2 <memset>
  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 8002c0c:	0029      	movs	r1, r5
 8002c0e:	2218      	movs	r2, #24
 8002c10:	a80b      	add	r0, sp, #44	; 0x2c
 8002c12:	f000 fbce 	bl	80033b2 <memset>
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR, Periphs);
 8002c16:	2280      	movs	r2, #128	; 0x80
 8002c18:	4b31      	ldr	r3, [pc, #196]	; (8002ce0 <main+0x450>)
 8002c1a:	0292      	lsls	r2, r2, #10
 8002c1c:	69db      	ldr	r3, [r3, #28]
 8002c1e:	4313      	orrs	r3, r2
 8002c20:	4a2f      	ldr	r2, [pc, #188]	; (8002ce0 <main+0x450>)
 8002c22:	61d3      	str	r3, [r2, #28]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
 8002c24:	69d3      	ldr	r3, [r2, #28]
 8002c26:	2280      	movs	r2, #128	; 0x80
 8002c28:	0292      	lsls	r2, r2, #10
 8002c2a:	4013      	ands	r3, r2
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);
 8002c2c:	0010      	movs	r0, r2
 8002c2e:	9305      	str	r3, [sp, #20]
  (void)tmpreg;
 8002c30:	9b05      	ldr	r3, [sp, #20]
 8002c32:	f7ff fde1 	bl	80027f8 <LL_AHB1_GRP1_EnableClock>
  GPIO_InitStruct.Pin = BT_TX_Pin;
 8002c36:	2304      	movs	r3, #4
  LL_GPIO_Init(BT_TX_GPIO_Port, &GPIO_InitStruct);
 8002c38:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pin = BT_TX_Pin;
 8002c3a:	930b      	str	r3, [sp, #44]	; 0x2c
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 8002c3c:	3b02      	subs	r3, #2
 8002c3e:	930c      	str	r3, [sp, #48]	; 0x30
  LL_GPIO_Init(BT_TX_GPIO_Port, &GPIO_InitStruct);
 8002c40:	a90b      	add	r1, sp, #44	; 0x2c
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
 8002c42:	19db      	adds	r3, r3, r7
  LL_GPIO_Init(BT_TX_GPIO_Port, &GPIO_InitStruct);
 8002c44:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
 8002c46:	930d      	str	r3, [sp, #52]	; 0x34
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002c48:	950e      	str	r5, [sp, #56]	; 0x38
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8002c4a:	950f      	str	r5, [sp, #60]	; 0x3c
  GPIO_InitStruct.Alternate = LL_GPIO_AF_1;
 8002c4c:	9710      	str	r7, [sp, #64]	; 0x40
  LL_GPIO_Init(BT_TX_GPIO_Port, &GPIO_InitStruct);
 8002c4e:	f7fe f97e 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = BT_RX_Pin;
 8002c52:	2308      	movs	r3, #8
  LL_GPIO_Init(BT_RX_GPIO_Port, &GPIO_InitStruct);
 8002c54:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pin = BT_RX_Pin;
 8002c56:	930b      	str	r3, [sp, #44]	; 0x2c
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 8002c58:	3b06      	subs	r3, #6
 8002c5a:	930c      	str	r3, [sp, #48]	; 0x30
  LL_GPIO_Init(BT_RX_GPIO_Port, &GPIO_InitStruct);
 8002c5c:	a90b      	add	r1, sp, #44	; 0x2c
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
 8002c5e:	19db      	adds	r3, r3, r7
  LL_GPIO_Init(BT_RX_GPIO_Port, &GPIO_InitStruct);
 8002c60:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
 8002c62:	930d      	str	r3, [sp, #52]	; 0x34
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002c64:	950e      	str	r5, [sp, #56]	; 0x38
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8002c66:	950f      	str	r5, [sp, #60]	; 0x3c
  GPIO_InitStruct.Alternate = LL_GPIO_AF_1;
 8002c68:	9710      	str	r7, [sp, #64]	; 0x40
  LL_GPIO_Init(BT_RX_GPIO_Port, &GPIO_InitStruct);
 8002c6a:	f7fe f970 	bl	8000f4e <LL_GPIO_Init>
  *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_MEMORY
  * @retval None
  */
__STATIC_INLINE void LL_DMA_SetDataTransferDirection(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Direction)
{
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
 8002c6e:	4b20      	ldr	r3, [pc, #128]	; (8002cf0 <main+0x460>)
 8002c70:	4920      	ldr	r1, [pc, #128]	; (8002cf4 <main+0x464>)
 8002c72:	681a      	ldr	r2, [r3, #0]
  LL_USART_Init(USART2, &USART_InitStruct);
 8002c74:	0030      	movs	r0, r6
 8002c76:	400a      	ands	r2, r1
 8002c78:	2110      	movs	r1, #16
 8002c7a:	430a      	orrs	r2, r1
 8002c7c:	601a      	str	r2, [r3, #0]
  *         @arg @ref LL_DMA_PRIORITY_VERYHIGH
  * @retval None
  */
__STATIC_INLINE void LL_DMA_SetChannelPriorityLevel(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Priority)
{
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PL,
 8002c7e:	681a      	ldr	r2, [r3, #0]
 8002c80:	491d      	ldr	r1, [pc, #116]	; (8002cf8 <main+0x468>)
 8002c82:	400a      	ands	r2, r1
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_CIRC,
 8002c84:	2120      	movs	r1, #32
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PL,
 8002c86:	601a      	str	r2, [r3, #0]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_CIRC,
 8002c88:	681a      	ldr	r2, [r3, #0]
 8002c8a:	438a      	bics	r2, r1
 8002c8c:	601a      	str	r2, [r3, #0]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PINC,
 8002c8e:	681a      	ldr	r2, [r3, #0]
 8002c90:	1849      	adds	r1, r1, r1
 8002c92:	438a      	bics	r2, r1
 8002c94:	601a      	str	r2, [r3, #0]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MINC,
 8002c96:	681a      	ldr	r2, [r3, #0]
 8002c98:	3140      	adds	r1, #64	; 0x40
 8002c9a:	438a      	bics	r2, r1
 8002c9c:	430a      	orrs	r2, r1
 8002c9e:	601a      	str	r2, [r3, #0]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PSIZE,
 8002ca0:	681a      	ldr	r2, [r3, #0]
 8002ca2:	4916      	ldr	r1, [pc, #88]	; (8002cfc <main+0x46c>)
 8002ca4:	400a      	ands	r2, r1
 8002ca6:	601a      	str	r2, [r3, #0]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MSIZE,
 8002ca8:	681a      	ldr	r2, [r3, #0]
 8002caa:	4915      	ldr	r1, [pc, #84]	; (8002d00 <main+0x470>)
 8002cac:	400a      	ands	r2, r1
 8002cae:	601a      	str	r2, [r3, #0]
  USART_InitStruct.BaudRate = 9600;
 8002cb0:	2396      	movs	r3, #150	; 0x96
 8002cb2:	019b      	lsls	r3, r3, #6
 8002cb4:	9311      	str	r3, [sp, #68]	; 0x44
  USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
 8002cb6:	230c      	movs	r3, #12
  LL_USART_Init(USART2, &USART_InitStruct);
 8002cb8:	0021      	movs	r1, r4
  USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
 8002cba:	6123      	str	r3, [r4, #16]
  USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;
 8002cbc:	6065      	str	r5, [r4, #4]
  USART_InitStruct.StopBits = LL_USART_STOPBITS_1;
 8002cbe:	60a5      	str	r5, [r4, #8]
  USART_InitStruct.Parity = LL_USART_PARITY_NONE;
 8002cc0:	60e5      	str	r5, [r4, #12]
  USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;
 8002cc2:	6165      	str	r5, [r4, #20]
  USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_16;
 8002cc4:	61a5      	str	r5, [r4, #24]
  LL_USART_Init(USART2, &USART_InitStruct);
 8002cc6:	f7fe fa15 	bl	80010f4 <LL_USART_Init>
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_DisableIT_CTS(USART_TypeDef *USARTx)
{
  CLEAR_BIT(USARTx->CR3, USART_CR3_CTSIE);
 8002cca:	68b3      	ldr	r3, [r6, #8]
 8002ccc:	4a0d      	ldr	r2, [pc, #52]	; (8002d04 <main+0x474>)
  LL_USART_InitTypeDef USART_InitStruct = {0};
 8002cce:	0029      	movs	r1, r5
 8002cd0:	4013      	ands	r3, r2
 8002cd2:	e019      	b.n	8002d08 <main+0x478>
 8002cd4:	48000400 	.word	0x48000400
 8002cd8:	48001400 	.word	0x48001400
 8002cdc:	48000800 	.word	0x48000800
 8002ce0:	40021000 	.word	0x40021000
 8002ce4:	ff00ffff 	.word	0xff00ffff
 8002ce8:	e000e100 	.word	0xe000e100
 8002cec:	40004400 	.word	0x40004400
 8002cf0:	40020044 	.word	0x40020044
 8002cf4:	ffffbfef 	.word	0xffffbfef
 8002cf8:	ffffcfff 	.word	0xffffcfff
 8002cfc:	fffffcff 	.word	0xfffffcff
 8002d00:	fffff3ff 	.word	0xfffff3ff
 8002d04:	fffffbff 	.word	0xfffffbff
 8002d08:	60b3      	str	r3, [r6, #8]
  CLEAR_BIT(USARTx->CR2, USART_CR2_CLKEN);
 8002d0a:	6873      	ldr	r3, [r6, #4]
 8002d0c:	4a87      	ldr	r2, [pc, #540]	; (8002f2c <main+0x69c>)
 8002d0e:	0020      	movs	r0, r4
 8002d10:	4013      	ands	r3, r2
  CLEAR_BIT(USARTx->CR3, USART_CR3_HDSEL);
 8002d12:	2208      	movs	r2, #8
  CLEAR_BIT(USARTx->CR2, USART_CR2_CLKEN);
 8002d14:	6073      	str	r3, [r6, #4]
  CLEAR_BIT(USARTx->CR3, USART_CR3_HDSEL);
 8002d16:	68b3      	ldr	r3, [r6, #8]
 8002d18:	4393      	bics	r3, r2
 8002d1a:	60b3      	str	r3, [r6, #8]
  SET_BIT(USARTx->CR1, USART_CR1_UE);
 8002d1c:	6833      	ldr	r3, [r6, #0]
  SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 8002d1e:	3218      	adds	r2, #24
  SET_BIT(USARTx->CR1, USART_CR1_UE);
 8002d20:	433b      	orrs	r3, r7
 8002d22:	6033      	str	r3, [r6, #0]
  SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 8002d24:	6833      	ldr	r3, [r6, #0]
 8002d26:	4313      	orrs	r3, r2
 8002d28:	6033      	str	r3, [r6, #0]
 8002d2a:	3a04      	subs	r2, #4
 8002d2c:	f000 fb41 	bl	80033b2 <memset>
  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 8002d30:	0029      	movs	r1, r5
 8002d32:	2218      	movs	r2, #24
 8002d34:	a80b      	add	r0, sp, #44	; 0x2c
 8002d36:	f000 fb3c 	bl	80033b2 <memset>
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP2_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 8002d3a:	2280      	movs	r2, #128	; 0x80
 8002d3c:	4b7c      	ldr	r3, [pc, #496]	; (8002f30 <main+0x6a0>)
 8002d3e:	01d2      	lsls	r2, r2, #7
 8002d40:	699b      	ldr	r3, [r3, #24]
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);
 8002d42:	2080      	movs	r0, #128	; 0x80
 8002d44:	4313      	orrs	r3, r2
 8002d46:	4a7a      	ldr	r2, [pc, #488]	; (8002f30 <main+0x6a0>)
 8002d48:	0280      	lsls	r0, r0, #10
 8002d4a:	6193      	str	r3, [r2, #24]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 8002d4c:	6993      	ldr	r3, [r2, #24]
 8002d4e:	2280      	movs	r2, #128	; 0x80
 8002d50:	01d2      	lsls	r2, r2, #7
 8002d52:	4013      	ands	r3, r2
 8002d54:	9306      	str	r3, [sp, #24]
  (void)tmpreg;
 8002d56:	9b06      	ldr	r3, [sp, #24]
 8002d58:	f7ff fd4e 	bl	80027f8 <LL_AHB1_GRP1_EnableClock>
  GPIO_InitStruct.Pin = JRS_TX_PIN_Pin;
 8002d5c:	2380      	movs	r3, #128	; 0x80
  LL_GPIO_Init(JRS_TX_PIN_GPIO_Port, &GPIO_InitStruct);
 8002d5e:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pin = JRS_TX_PIN_Pin;
 8002d60:	009b      	lsls	r3, r3, #2
 8002d62:	930b      	str	r3, [sp, #44]	; 0x2c
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 8002d64:	3bff      	subs	r3, #255	; 0xff
 8002d66:	3bff      	subs	r3, #255	; 0xff
 8002d68:	930c      	str	r3, [sp, #48]	; 0x30
  LL_GPIO_Init(JRS_TX_PIN_GPIO_Port, &GPIO_InitStruct);
 8002d6a:	a90b      	add	r1, sp, #44	; 0x2c
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
 8002d6c:	19db      	adds	r3, r3, r7
  LL_GPIO_Init(JRS_TX_PIN_GPIO_Port, &GPIO_InitStruct);
 8002d6e:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
 8002d70:	930d      	str	r3, [sp, #52]	; 0x34
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002d72:	950e      	str	r5, [sp, #56]	; 0x38
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8002d74:	950f      	str	r5, [sp, #60]	; 0x3c
  GPIO_InitStruct.Alternate = LL_GPIO_AF_1;
 8002d76:	9710      	str	r7, [sp, #64]	; 0x40
  LL_GPIO_Init(JRS_TX_PIN_GPIO_Port, &GPIO_InitStruct);
 8002d78:	f7fe f8e9 	bl	8000f4e <LL_GPIO_Init>
  GPIO_InitStruct.Pin = JRS_RX_PIN_Pin;
 8002d7c:	2380      	movs	r3, #128	; 0x80
 8002d7e:	00db      	lsls	r3, r3, #3
 8002d80:	930b      	str	r3, [sp, #44]	; 0x2c
  LL_GPIO_Init(JRS_RX_PIN_GPIO_Port, &GPIO_InitStruct);
 8002d82:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 8002d84:	2302      	movs	r3, #2
  LL_GPIO_Init(JRS_RX_PIN_GPIO_Port, &GPIO_InitStruct);
 8002d86:	a90b      	add	r1, sp, #44	; 0x2c
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 8002d88:	930c      	str	r3, [sp, #48]	; 0x30
  LL_GPIO_Init(JRS_RX_PIN_GPIO_Port, &GPIO_InitStruct);
 8002d8a:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
 8002d8c:	19db      	adds	r3, r3, r7
 8002d8e:	930d      	str	r3, [sp, #52]	; 0x34
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8002d90:	950e      	str	r5, [sp, #56]	; 0x38
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8002d92:	950f      	str	r5, [sp, #60]	; 0x3c
  GPIO_InitStruct.Alternate = LL_GPIO_AF_1;
 8002d94:	9710      	str	r7, [sp, #64]	; 0x40
  LL_GPIO_Init(JRS_RX_PIN_GPIO_Port, &GPIO_InitStruct);
 8002d96:	f7fe f8da 	bl	8000f4e <LL_GPIO_Init>
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
 8002d9a:	4b66      	ldr	r3, [pc, #408]	; (8002f34 <main+0x6a4>)
 8002d9c:	4966      	ldr	r1, [pc, #408]	; (8002f38 <main+0x6a8>)
 8002d9e:	681a      	ldr	r2, [r3, #0]
  LL_USART_Init(USART1, &USART_InitStruct);
 8002da0:	4e66      	ldr	r6, [pc, #408]	; (8002f3c <main+0x6ac>)
 8002da2:	400a      	ands	r2, r1
 8002da4:	2110      	movs	r1, #16
 8002da6:	430a      	orrs	r2, r1
 8002da8:	601a      	str	r2, [r3, #0]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PL,
 8002daa:	681a      	ldr	r2, [r3, #0]
 8002dac:	4964      	ldr	r1, [pc, #400]	; (8002f40 <main+0x6b0>)
 8002dae:	0030      	movs	r0, r6
 8002db0:	400a      	ands	r2, r1
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_CIRC,
 8002db2:	2120      	movs	r1, #32
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PL,
 8002db4:	601a      	str	r2, [r3, #0]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_CIRC,
 8002db6:	681a      	ldr	r2, [r3, #0]
 8002db8:	438a      	bics	r2, r1
 8002dba:	601a      	str	r2, [r3, #0]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PINC,
 8002dbc:	681a      	ldr	r2, [r3, #0]
 8002dbe:	1849      	adds	r1, r1, r1
 8002dc0:	438a      	bics	r2, r1
 8002dc2:	601a      	str	r2, [r3, #0]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MINC,
 8002dc4:	681a      	ldr	r2, [r3, #0]
 8002dc6:	3140      	adds	r1, #64	; 0x40
 8002dc8:	438a      	bics	r2, r1
 8002dca:	430a      	orrs	r2, r1
 8002dcc:	601a      	str	r2, [r3, #0]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PSIZE,
 8002dce:	681a      	ldr	r2, [r3, #0]
 8002dd0:	495c      	ldr	r1, [pc, #368]	; (8002f44 <main+0x6b4>)
 8002dd2:	400a      	ands	r2, r1
 8002dd4:	601a      	str	r2, [r3, #0]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MSIZE,
 8002dd6:	681a      	ldr	r2, [r3, #0]
 8002dd8:	495b      	ldr	r1, [pc, #364]	; (8002f48 <main+0x6b8>)
 8002dda:	400a      	ands	r2, r1
 8002ddc:	601a      	str	r2, [r3, #0]
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002dde:	22c6      	movs	r2, #198	; 0xc6
 8002de0:	21c0      	movs	r1, #192	; 0xc0
 8002de2:	4b5a      	ldr	r3, [pc, #360]	; (8002f4c <main+0x6bc>)
 8002de4:	0092      	lsls	r2, r2, #2
 8002de6:	589b      	ldr	r3, [r3, r2]
 8002de8:	0609      	lsls	r1, r1, #24
 8002dea:	021b      	lsls	r3, r3, #8
 8002dec:	0a1b      	lsrs	r3, r3, #8
 8002dee:	430b      	orrs	r3, r1
 8002df0:	4956      	ldr	r1, [pc, #344]	; (8002f4c <main+0x6bc>)
 8002df2:	508b      	str	r3, [r1, r2]
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8002df4:	2380      	movs	r3, #128	; 0x80
 8002df6:	051b      	lsls	r3, r3, #20
 8002df8:	600b      	str	r3, [r1, #0]
  USART_InitStruct.BaudRate = 2400;
 8002dfa:	2396      	movs	r3, #150	; 0x96
 8002dfc:	011b      	lsls	r3, r3, #4
 8002dfe:	9311      	str	r3, [sp, #68]	; 0x44
  USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
 8002e00:	230c      	movs	r3, #12
 8002e02:	6123      	str	r3, [r4, #16]
  USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_8;
 8002e04:	2380      	movs	r3, #128	; 0x80
  LL_USART_Init(USART1, &USART_InitStruct);
 8002e06:	0021      	movs	r1, r4
  USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_8;
 8002e08:	021b      	lsls	r3, r3, #8
 8002e0a:	61a3      	str	r3, [r4, #24]
  USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;
 8002e0c:	6065      	str	r5, [r4, #4]
  USART_InitStruct.StopBits = LL_USART_STOPBITS_1;
 8002e0e:	60a5      	str	r5, [r4, #8]
  USART_InitStruct.Parity = LL_USART_PARITY_NONE;
 8002e10:	60e5      	str	r5, [r4, #12]
  USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;
 8002e12:	6165      	str	r5, [r4, #20]
  LL_USART_Init(USART1, &USART_InitStruct);
 8002e14:	f7fe f96e 	bl	80010f4 <LL_USART_Init>
  CLEAR_BIT(USARTx->CR3, USART_CR3_CTSIE);
 8002e18:	68b3      	ldr	r3, [r6, #8]
 8002e1a:	4a4d      	ldr	r2, [pc, #308]	; (8002f50 <main+0x6c0>)
  ADC_ChannelConfTypeDef sConfig = {0};
 8002e1c:	0029      	movs	r1, r5
 8002e1e:	4013      	ands	r3, r2
 8002e20:	60b3      	str	r3, [r6, #8]
  CLEAR_BIT(USARTx->CR2, USART_CR2_CLKEN);
 8002e22:	6873      	ldr	r3, [r6, #4]
 8002e24:	4a41      	ldr	r2, [pc, #260]	; (8002f2c <main+0x69c>)
 8002e26:	0020      	movs	r0, r4
 8002e28:	4013      	ands	r3, r2
  CLEAR_BIT(USARTx->CR3, USART_CR3_HDSEL);
 8002e2a:	2208      	movs	r2, #8
  CLEAR_BIT(USARTx->CR2, USART_CR2_CLKEN);
 8002e2c:	6073      	str	r3, [r6, #4]
  CLEAR_BIT(USARTx->CR3, USART_CR3_HDSEL);
 8002e2e:	68b3      	ldr	r3, [r6, #8]
 8002e30:	4393      	bics	r3, r2
 8002e32:	60b3      	str	r3, [r6, #8]
  SET_BIT(USARTx->CR1, USART_CR1_UE);
 8002e34:	6833      	ldr	r3, [r6, #0]
 8002e36:	3204      	adds	r2, #4
 8002e38:	433b      	orrs	r3, r7
 8002e3a:	6033      	str	r3, [r6, #0]
 8002e3c:	f000 fab9 	bl	80033b2 <memset>
  hadc.Instance = ADC1;
 8002e40:	4e44      	ldr	r6, [pc, #272]	; (8002f54 <main+0x6c4>)
 8002e42:	4b45      	ldr	r3, [pc, #276]	; (8002f58 <main+0x6c8>)
  if (HAL_ADC_Init(&hadc) != HAL_OK)
 8002e44:	0030      	movs	r0, r6
  hadc.Instance = ADC1;
 8002e46:	6033      	str	r3, [r6, #0]
  hadc.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 8002e48:	2380      	movs	r3, #128	; 0x80
 8002e4a:	061b      	lsls	r3, r3, #24
 8002e4c:	6073      	str	r3, [r6, #4]
  hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8002e4e:	2304      	movs	r3, #4
 8002e50:	6173      	str	r3, [r6, #20]
  hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8002e52:	23c2      	movs	r3, #194	; 0xc2
 8002e54:	33ff      	adds	r3, #255	; 0xff
  hadc.Init.Resolution = ADC_RESOLUTION_12B;
 8002e56:	60b5      	str	r5, [r6, #8]
  hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8002e58:	60f5      	str	r5, [r6, #12]
  hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 8002e5a:	6137      	str	r7, [r6, #16]
  hadc.Init.LowPowerAutoWait = DISABLE;
 8002e5c:	61b5      	str	r5, [r6, #24]
  hadc.Init.LowPowerAutoPowerOff = DISABLE;
 8002e5e:	61f5      	str	r5, [r6, #28]
  hadc.Init.ContinuousConvMode = DISABLE;
 8002e60:	6235      	str	r5, [r6, #32]
  hadc.Init.DiscontinuousConvMode = DISABLE;
 8002e62:	6275      	str	r5, [r6, #36]	; 0x24
  hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8002e64:	62b3      	str	r3, [r6, #40]	; 0x28
  hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8002e66:	62f5      	str	r5, [r6, #44]	; 0x2c
  hadc.Init.DMAContinuousRequests = DISABLE;
 8002e68:	6335      	str	r5, [r6, #48]	; 0x30
  hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8002e6a:	6377      	str	r7, [r6, #52]	; 0x34
  if (HAL_ADC_Init(&hadc) != HAL_OK)
 8002e6c:	f7fd f9f6 	bl	800025c <HAL_ADC_Init>
 8002e70:	42a8      	cmp	r0, r5
 8002e72:	d000      	beq.n	8002e76 <main+0x5e6>
 8002e74:	e7fe      	b.n	8002e74 <main+0x5e4>
  sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
 8002e76:	2380      	movs	r3, #128	; 0x80
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 8002e78:	2580      	movs	r5, #128	; 0x80
  sConfig.Channel = ADC_CHANNEL_0;
 8002e7a:	9011      	str	r0, [sp, #68]	; 0x44
  sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
 8002e7c:	015b      	lsls	r3, r3, #5
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 8002e7e:	056d      	lsls	r5, r5, #21
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 8002e80:	0021      	movs	r1, r4
 8002e82:	0030      	movs	r0, r6
  sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
 8002e84:	6063      	str	r3, [r4, #4]
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 8002e86:	60a5      	str	r5, [r4, #8]
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 8002e88:	f7fd fa8e 	bl	80003a8 <HAL_ADC_ConfigChannel>
 8002e8c:	9001      	str	r0, [sp, #4]
 8002e8e:	2800      	cmp	r0, #0
 8002e90:	d000      	beq.n	8002e94 <main+0x604>
 8002e92:	e7fe      	b.n	8002e92 <main+0x602>
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002e94:	21c7      	movs	r1, #199	; 0xc7
 8002e96:	22ff      	movs	r2, #255	; 0xff
 8002e98:	4b2c      	ldr	r3, [pc, #176]	; (8002f4c <main+0x6bc>)
 8002e9a:	0089      	lsls	r1, r1, #2
 8002e9c:	585b      	ldr	r3, [r3, r1]
  RCTigHandle = osSemaphoreCreate(osSemaphore(RCTig), 1);
 8002e9e:	a802      	add	r0, sp, #8
 8002ea0:	4393      	bics	r3, r2
 8002ea2:	001a      	movs	r2, r3
 8002ea4:	23c0      	movs	r3, #192	; 0xc0
 8002ea6:	4313      	orrs	r3, r2
 8002ea8:	4a28      	ldr	r2, [pc, #160]	; (8002f4c <main+0x6bc>)
 8002eaa:	5053      	str	r3, [r2, r1]
  osSemaphoreDef(RCTig);
 8002eac:	9b01      	ldr	r3, [sp, #4]
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8002eae:	6015      	str	r5, [r2, #0]
  RCTigHandle = osSemaphoreCreate(osSemaphore(RCTig), 1);
 8002eb0:	0039      	movs	r1, r7
  osSemaphoreDef(RCTig);
 8002eb2:	9302      	str	r3, [sp, #8]
  RCTigHandle = osSemaphoreCreate(osSemaphore(RCTig), 1);
 8002eb4:	f7fe f9d2 	bl	800125c <osSemaphoreCreate>
 8002eb8:	4b28      	ldr	r3, [pc, #160]	; (8002f5c <main+0x6cc>)
  myTimer01Handle = osTimerCreate(osTimer(myTimer01), osTimerPeriodic, NULL);
 8002eba:	9a01      	ldr	r2, [sp, #4]
  RCTigHandle = osSemaphoreCreate(osSemaphore(RCTig), 1);
 8002ebc:	6018      	str	r0, [r3, #0]
  osTimerDef(myTimer01, Callback01);
 8002ebe:	4b28      	ldr	r3, [pc, #160]	; (8002f60 <main+0x6d0>)
  myTimer01Handle = osTimerCreate(osTimer(myTimer01), osTimerPeriodic, NULL);
 8002ec0:	0039      	movs	r1, r7
 8002ec2:	a803      	add	r0, sp, #12
  osTimerDef(myTimer01, Callback01);
 8002ec4:	9303      	str	r3, [sp, #12]
  myTimer01Handle = osTimerCreate(osTimer(myTimer01), osTimerPeriodic, NULL);
 8002ec6:	f7fe f9b9 	bl	800123c <osTimerCreate>
 8002eca:	4b26      	ldr	r3, [pc, #152]	; (8002f64 <main+0x6d4>)
  osMessageQDef(clearQue, 4, uint16_t);
 8002ecc:	4d26      	ldr	r5, [pc, #152]	; (8002f68 <main+0x6d8>)
  myTimer01Handle = osTimerCreate(osTimer(myTimer01), osTimerPeriodic, NULL);
 8002ece:	6018      	str	r0, [r3, #0]
  osMessageQDef(clearQue, 4, uint16_t);
 8002ed0:	a807      	add	r0, sp, #28
 8002ed2:	0003      	movs	r3, r0
 8002ed4:	002e      	movs	r6, r5
 8002ed6:	ce06      	ldmia	r6!, {r1, r2}
 8002ed8:	c306      	stmia	r3!, {r1, r2}
  clearQueHandle = osMessageCreate(osMessageQ(clearQue), NULL);
 8002eda:	9901      	ldr	r1, [sp, #4]
 8002edc:	f7fe fa16 	bl	800130c <osMessageCreate>
 8002ee0:	4b22      	ldr	r3, [pc, #136]	; (8002f6c <main+0x6dc>)
  osThreadDef(RCTask, StartRemoteControl, osPriorityHigh, 0, 64);
 8002ee2:	3524      	adds	r5, #36	; 0x24
  clearQueHandle = osMessageCreate(osMessageQ(clearQue), NULL);
 8002ee4:	6018      	str	r0, [r3, #0]
  osMessageQDef(ctrlQue, 6, uint16_t);
 8002ee6:	a809      	add	r0, sp, #36	; 0x24
 8002ee8:	0003      	movs	r3, r0
 8002eea:	ce06      	ldmia	r6!, {r1, r2}
 8002eec:	c306      	stmia	r3!, {r1, r2}
  ctrlQueHandle = osMessageCreate(osMessageQ(ctrlQue), NULL);
 8002eee:	9901      	ldr	r1, [sp, #4]
 8002ef0:	f7fe fa0c 	bl	800130c <osMessageCreate>
 8002ef4:	4b1e      	ldr	r3, [pc, #120]	; (8002f70 <main+0x6e0>)
 8002ef6:	6018      	str	r0, [r3, #0]
  osThreadDef(LEDTask, StartLEDTask, osPriorityLow, 0, 64);
 8002ef8:	ab0b      	add	r3, sp, #44	; 0x2c
 8002efa:	ce07      	ldmia	r6!, {r0, r1, r2}
 8002efc:	c307      	stmia	r3!, {r0, r1, r2}
 8002efe:	ce06      	ldmia	r6!, {r1, r2}
 8002f00:	c306      	stmia	r3!, {r1, r2}
  LEDTaskHandle = osThreadCreate(osThread(LEDTask), NULL);
 8002f02:	a80b      	add	r0, sp, #44	; 0x2c
 8002f04:	9901      	ldr	r1, [sp, #4]
 8002f06:	f7fe f979 	bl	80011fc <osThreadCreate>
 8002f0a:	4b1a      	ldr	r3, [pc, #104]	; (8002f74 <main+0x6e4>)
 8002f0c:	6018      	str	r0, [r3, #0]
  osThreadDef(RCTask, StartRemoteControl, osPriorityHigh, 0, 64);
 8002f0e:	0023      	movs	r3, r4
 8002f10:	cd07      	ldmia	r5!, {r0, r1, r2}
 8002f12:	c307      	stmia	r3!, {r0, r1, r2}
 8002f14:	cd06      	ldmia	r5!, {r1, r2}
 8002f16:	c306      	stmia	r3!, {r1, r2}
  RCTaskHandle = osThreadCreate(osThread(RCTask), NULL);
 8002f18:	0020      	movs	r0, r4
 8002f1a:	9901      	ldr	r1, [sp, #4]
 8002f1c:	f7fe f96e 	bl	80011fc <osThreadCreate>
 8002f20:	4b15      	ldr	r3, [pc, #84]	; (8002f78 <main+0x6e8>)
 8002f22:	6018      	str	r0, [r3, #0]
  osKernelStart();
 8002f24:	f7fe f965 	bl	80011f2 <osKernelStart>
 8002f28:	e7fe      	b.n	8002f28 <main+0x698>
 8002f2a:	46c0      	nop			; (mov r8, r8)
 8002f2c:	fffff7ff 	.word	0xfffff7ff
 8002f30:	40021000 	.word	0x40021000
 8002f34:	4002001c 	.word	0x4002001c
 8002f38:	ffffbfef 	.word	0xffffbfef
 8002f3c:	40013800 	.word	0x40013800
 8002f40:	ffffcfff 	.word	0xffffcfff
 8002f44:	fffffcff 	.word	0xfffffcff
 8002f48:	fffff3ff 	.word	0xfffff3ff
 8002f4c:	e000e100 	.word	0xe000e100
 8002f50:	fffffbff 	.word	0xfffffbff
 8002f54:	2000176c 	.word	0x2000176c
 8002f58:	40012400 	.word	0x40012400
 8002f5c:	20001754 	.word	0x20001754
 8002f60:	08002815 	.word	0x08002815
 8002f64:	20001764 	.word	0x20001764
 8002f68:	08004260 	.word	0x08004260
 8002f6c:	20001768 	.word	0x20001768
 8002f70:	2000175c 	.word	0x2000175c
 8002f74:	20001750 	.word	0x20001750
 8002f78:	200017b8 	.word	0x200017b8

08002f7c <HAL_TIM_PeriodElapsedCallback>:
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM17) {
 8002f7c:	4b03      	ldr	r3, [pc, #12]	; (8002f8c <HAL_TIM_PeriodElapsedCallback+0x10>)
 8002f7e:	6802      	ldr	r2, [r0, #0]
{
 8002f80:	b510      	push	{r4, lr}
  if (htim->Instance == TIM17) {
 8002f82:	429a      	cmp	r2, r3
 8002f84:	d101      	bne.n	8002f8a <HAL_TIM_PeriodElapsedCallback+0xe>
    HAL_IncTick();
 8002f86:	f7fd f95b 	bl	8000240 <HAL_IncTick>
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 8002f8a:	bd10      	pop	{r4, pc}
 8002f8c:	40014800 	.word	0x40014800

08002f90 <StartRemoteControl>:
uint8_t remoteCtrlBackData[10];
//bool Usart2Free;
	//remoteCtrlData format is 0x00 data[1]~data[8] 0x00;
	// and data[8]= data[1]^.....data[7]
	// 2 data[1] data[2]
void StartRemoteControl(void const * argument){
 8002f90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	remoteCtrlAdd[0]=0x34;
 8002f92:	2334      	movs	r3, #52	; 0x34
	remoteCtrlAdd[1]=0x35;
	while(1){
		if(osSemaphoreWait(RCTigHandle,osWaitForever)==osOK){
 8002f94:	2601      	movs	r6, #1
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 8002f96:	2540      	movs	r5, #64	; 0x40
	remoteCtrlAdd[0]=0x34;
 8002f98:	4c23      	ldr	r4, [pc, #140]	; (8003028 <StartRemoteControl+0x98>)
		if(osSemaphoreWait(RCTigHandle,osWaitForever)==osOK){
 8002f9a:	4276      	negs	r6, r6
	remoteCtrlAdd[0]=0x34;
 8002f9c:	7023      	strb	r3, [r4, #0]
	remoteCtrlAdd[1]=0x35;
 8002f9e:	3301      	adds	r3, #1
 8002fa0:	7063      	strb	r3, [r4, #1]
		if(osSemaphoreWait(RCTigHandle,osWaitForever)==osOK){
 8002fa2:	4b22      	ldr	r3, [pc, #136]	; (800302c <StartRemoteControl+0x9c>)
 8002fa4:	0031      	movs	r1, r6
 8002fa6:	6818      	ldr	r0, [r3, #0]
 8002fa8:	f7fe f96a 	bl	8001280 <osSemaphoreWait>
 8002fac:	2800      	cmp	r0, #0
 8002fae:	d1f8      	bne.n	8002fa2 <StartRemoteControl+0x12>
			uint8_t indCode=remoteCtrlData[1]^remoteCtrlData[2]^remoteCtrlData[3]^remoteCtrlData[4]^remoteCtrlData[5]^remoteCtrlData[6]^remoteCtrlData[7];
 8002fb0:	481f      	ldr	r0, [pc, #124]	; (8003030 <StartRemoteControl+0xa0>)
 8002fb2:	7841      	ldrb	r1, [r0, #1]
 8002fb4:	7882      	ldrb	r2, [r0, #2]
 8002fb6:	000b      	movs	r3, r1
 8002fb8:	78c7      	ldrb	r7, [r0, #3]
 8002fba:	4053      	eors	r3, r2
 8002fbc:	407b      	eors	r3, r7
 8002fbe:	7907      	ldrb	r7, [r0, #4]
 8002fc0:	407b      	eors	r3, r7
 8002fc2:	7947      	ldrb	r7, [r0, #5]
 8002fc4:	407b      	eors	r3, r7
 8002fc6:	7987      	ldrb	r7, [r0, #6]
 8002fc8:	407b      	eors	r3, r7
 8002fca:	79c7      	ldrb	r7, [r0, #7]
			if(indCode== remoteCtrlData[8]){	//
 8002fcc:	7a00      	ldrb	r0, [r0, #8]
 8002fce:	407b      	eors	r3, r7
 8002fd0:	4298      	cmp	r0, r3
 8002fd2:	d108      	bne.n	8002fe6 <StartRemoteControl+0x56>
				if(remoteCtrlData[1]==remoteCtrlAdd[0] && remoteCtrlData[2]==remoteCtrlAdd[1]){	//
 8002fd4:	7823      	ldrb	r3, [r4, #0]
 8002fd6:	428b      	cmp	r3, r1
 8002fd8:	d105      	bne.n	8002fe6 <StartRemoteControl+0x56>
 8002fda:	7863      	ldrb	r3, [r4, #1]
 8002fdc:	4293      	cmp	r3, r2
 8002fde:	d102      	bne.n	8002fe6 <StartRemoteControl+0x56>
					//,2,,,,.
					printf("USART's receive Data!");
 8002fe0:	4814      	ldr	r0, [pc, #80]	; (8003034 <StartRemoteControl+0xa4>)
 8002fe2:	f000 f9ef 	bl	80033c4 <iprintf>
  * @param  NbData Between Min_Data = 0 and Max_Data = 0x0000FFFF
  * @retval None
  */
__STATIC_INLINE void LL_DMA_SetDataLength(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t NbData)
{
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR,
 8002fe6:	210a      	movs	r1, #10
				}else if(remoteCtrlData[1]==0x56 && remoteCtrlData[2]==0x38) {
					//  0x56 0x38
				}
			}
			LL_DMA_SetPeriphAddress(DMA1,LL_DMA_CHANNEL_4,*remoteCtrlBackData);
 8002fe8:	4b13      	ldr	r3, [pc, #76]	; (8003038 <StartRemoteControl+0xa8>)
  * @param  PeriphAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
  * @retval None
  */
__STATIC_INLINE void LL_DMA_SetPeriphAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphAddress)
{
  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, PeriphAddress);
 8002fea:	4a14      	ldr	r2, [pc, #80]	; (800303c <StartRemoteControl+0xac>)
 8002fec:	781b      	ldrb	r3, [r3, #0]
 8002fee:	4f14      	ldr	r7, [pc, #80]	; (8003040 <StartRemoteControl+0xb0>)
 8002ff0:	6093      	str	r3, [r2, #8]
  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, MemoryAddress);
 8002ff2:	4b14      	ldr	r3, [pc, #80]	; (8003044 <StartRemoteControl+0xb4>)
 8002ff4:	60d3      	str	r3, [r2, #12]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR,
 8002ff6:	6853      	ldr	r3, [r2, #4]
 8002ff8:	0c1b      	lsrs	r3, r3, #16
 8002ffa:	041b      	lsls	r3, r3, #16
 8002ffc:	430b      	orrs	r3, r1
 8002ffe:	6053      	str	r3, [r2, #4]
 8003000:	623d      	str	r5, [r7, #32]
  SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 8003002:	6839      	ldr	r1, [r7, #0]
 8003004:	4329      	orrs	r1, r5
 8003006:	6039      	str	r1, [r7, #0]
  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_EN);
 8003008:	2101      	movs	r1, #1
 800300a:	6810      	ldr	r0, [r2, #0]
 800300c:	4301      	orrs	r1, r0
 800300e:	6011      	str	r1, [r2, #0]
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_EnableDMAReq_TX(USART_TypeDef *USARTx)
{
  SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 8003010:	2280      	movs	r2, #128	; 0x80
 8003012:	68b9      	ldr	r1, [r7, #8]
 8003014:	430a      	orrs	r2, r1
 8003016:	60ba      	str	r2, [r7, #8]
  return (READ_BIT(USARTx->ISR, USART_ISR_TC) == (USART_ISR_TC));
 8003018:	69fb      	ldr	r3, [r7, #28]
			LL_USART_ClearFlag_TC(USART2);
			LL_USART_EnableIT_TC(USART2);
			LL_DMA_EnableChannel(DMA1,LL_DMA_CHANNEL_4);
			LL_USART_EnableDMAReq_TX(USART2);
			//HAL_USART_Transmit_DMA(USART2,remoteCtrlBackData,10);
			while(!LL_USART_IsActiveFlag_TC(USART2)) osDelay(5);
 800301a:	422b      	tst	r3, r5
 800301c:	d1c1      	bne.n	8002fa2 <StartRemoteControl+0x12>
 800301e:	2005      	movs	r0, #5
 8003020:	f7fe f904 	bl	800122c <osDelay>
 8003024:	e7f8      	b.n	8003018 <StartRemoteControl+0x88>
 8003026:	46c0      	nop			; (mov r8, r8)
 8003028:	200017bc 	.word	0x200017bc
 800302c:	20001754 	.word	0x20001754
 8003030:	20001812 	.word	0x20001812
 8003034:	080042b9 	.word	0x080042b9
 8003038:	200017be 	.word	0x200017be
 800303c:	40020044 	.word	0x40020044
 8003040:	40004400 	.word	0x40004400
 8003044:	40004428 	.word	0x40004428

08003048 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8003048:	b507      	push	{r0, r1, r2, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800304a:	2001      	movs	r0, #1
 800304c:	4b0b      	ldr	r3, [pc, #44]	; (800307c <HAL_MspInit+0x34>)
 800304e:	6999      	ldr	r1, [r3, #24]
 8003050:	4301      	orrs	r1, r0
 8003052:	6199      	str	r1, [r3, #24]
  __HAL_RCC_PWR_CLK_ENABLE();
 8003054:	2180      	movs	r1, #128	; 0x80
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8003056:	699a      	ldr	r2, [r3, #24]
  __HAL_RCC_PWR_CLK_ENABLE();
 8003058:	0549      	lsls	r1, r1, #21
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800305a:	4002      	ands	r2, r0
 800305c:	9200      	str	r2, [sp, #0]
 800305e:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8003060:	69da      	ldr	r2, [r3, #28]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 3, 0);
 8003062:	3803      	subs	r0, #3
  __HAL_RCC_PWR_CLK_ENABLE();
 8003064:	430a      	orrs	r2, r1
 8003066:	61da      	str	r2, [r3, #28]
 8003068:	69db      	ldr	r3, [r3, #28]
  HAL_NVIC_SetPriority(PendSV_IRQn, 3, 0);
 800306a:	2200      	movs	r2, #0
  __HAL_RCC_PWR_CLK_ENABLE();
 800306c:	400b      	ands	r3, r1
 800306e:	9301      	str	r3, [sp, #4]
  HAL_NVIC_SetPriority(PendSV_IRQn, 3, 0);
 8003070:	2103      	movs	r1, #3
  __HAL_RCC_PWR_CLK_ENABLE();
 8003072:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(PendSV_IRQn, 3, 0);
 8003074:	f7fd fa0e 	bl	8000494 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8003078:	bd07      	pop	{r0, r1, r2, pc}
 800307a:	46c0      	nop			; (mov r8, r8)
 800307c:	40021000 	.word	0x40021000

08003080 <HAL_ADC_MspInit>:
* This function configures the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8003080:	b510      	push	{r4, lr}
 8003082:	0004      	movs	r4, r0
 8003084:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003086:	2214      	movs	r2, #20
 8003088:	2100      	movs	r1, #0
 800308a:	a803      	add	r0, sp, #12
 800308c:	f000 f991 	bl	80033b2 <memset>
  if(hadc->Instance==ADC1)
 8003090:	4b10      	ldr	r3, [pc, #64]	; (80030d4 <HAL_ADC_MspInit+0x54>)
 8003092:	6822      	ldr	r2, [r4, #0]
 8003094:	429a      	cmp	r2, r3
 8003096:	d11b      	bne.n	80030d0 <HAL_ADC_MspInit+0x50>
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_ADC1_CLK_ENABLE();
 8003098:	2080      	movs	r0, #128	; 0x80
 800309a:	4b0f      	ldr	r3, [pc, #60]	; (80030d8 <HAL_ADC_MspInit+0x58>)
 800309c:	0080      	lsls	r0, r0, #2
 800309e:	6999      	ldr	r1, [r3, #24]
 80030a0:	4301      	orrs	r1, r0
 80030a2:	6199      	str	r1, [r3, #24]
  
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80030a4:	2180      	movs	r1, #128	; 0x80
    __HAL_RCC_ADC1_CLK_ENABLE();
 80030a6:	699a      	ldr	r2, [r3, #24]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80030a8:	0289      	lsls	r1, r1, #10
    __HAL_RCC_ADC1_CLK_ENABLE();
 80030aa:	4002      	ands	r2, r0
 80030ac:	9201      	str	r2, [sp, #4]
 80030ae:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80030b0:	695a      	ldr	r2, [r3, #20]
    PA0     ------> ADC_IN0 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80030b2:	2090      	movs	r0, #144	; 0x90
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80030b4:	430a      	orrs	r2, r1
 80030b6:	615a      	str	r2, [r3, #20]
 80030b8:	695b      	ldr	r3, [r3, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80030ba:	05c0      	lsls	r0, r0, #23
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80030bc:	400b      	ands	r3, r1
 80030be:	9302      	str	r3, [sp, #8]
 80030c0:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 80030c2:	2301      	movs	r3, #1
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80030c4:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 80030c6:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80030c8:	3302      	adds	r3, #2
 80030ca:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80030cc:	f7fd fa1c 	bl	8000508 <HAL_GPIO_Init>
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }

}
 80030d0:	b008      	add	sp, #32
 80030d2:	bd10      	pop	{r4, pc}
 80030d4:	40012400 	.word	0x40012400
 80030d8:	40021000 	.word	0x40021000

080030dc <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig(). 
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80030dc:	b510      	push	{r4, lr}
 80030de:	0001      	movs	r1, r0
 80030e0:	b086      	sub	sp, #24
  uint32_t              uwTimclock = 0;
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  
  /*Configure the TIM17 IRQ priority */
  HAL_NVIC_SetPriority(TIM17_IRQn, TickPriority ,0); 
 80030e2:	2200      	movs	r2, #0
 80030e4:	2016      	movs	r0, #22
 80030e6:	f7fd f9d5 	bl	8000494 <HAL_NVIC_SetPriority>
  
  /* Enable the TIM17 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM17_IRQn); 
 80030ea:	2016      	movs	r0, #22
 80030ec:	f7fd fa02 	bl	80004f4 <HAL_NVIC_EnableIRQ>
  
  /* Enable TIM17 clock */
  __HAL_RCC_TIM17_CLK_ENABLE();
 80030f0:	2080      	movs	r0, #128	; 0x80
 80030f2:	4a14      	ldr	r2, [pc, #80]	; (8003144 <HAL_InitTick+0x68>)
 80030f4:	02c0      	lsls	r0, r0, #11
 80030f6:	6991      	ldr	r1, [r2, #24]
 80030f8:	4301      	orrs	r1, r0
 80030fa:	6191      	str	r1, [r2, #24]
 80030fc:	6993      	ldr	r3, [r2, #24]
  
  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 80030fe:	4669      	mov	r1, sp
  __HAL_RCC_TIM17_CLK_ENABLE();
 8003100:	4003      	ands	r3, r0
 8003102:	9301      	str	r3, [sp, #4]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8003104:	a802      	add	r0, sp, #8
  __HAL_RCC_TIM17_CLK_ENABLE();
 8003106:	9b01      	ldr	r3, [sp, #4]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8003108:	f7fd fd68 	bl	8000bdc <HAL_RCC_GetClockConfig>
  
  /* Compute TIM17 clock */
  uwTimclock = HAL_RCC_GetPCLK1Freq();
 800310c:	f7fd fd56 	bl	8000bbc <HAL_RCC_GetPCLK1Freq>
   
  /* Compute the prescaler value to have TIM17 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
  
  /* Initialize TIM17 */
  htim17.Instance = TIM17;
 8003110:	4c0d      	ldr	r4, [pc, #52]	; (8003148 <HAL_InitTick+0x6c>)
 8003112:	4b0e      	ldr	r3, [pc, #56]	; (800314c <HAL_InitTick+0x70>)
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 8003114:	490e      	ldr	r1, [pc, #56]	; (8003150 <HAL_InitTick+0x74>)
  htim17.Instance = TIM17;
 8003116:	6023      	str	r3, [r4, #0]
  + Period = [(TIM17CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim17.Init.Period = (1000000 / 1000) - 1;
 8003118:	4b0e      	ldr	r3, [pc, #56]	; (8003154 <HAL_InitTick+0x78>)
 800311a:	60e3      	str	r3, [r4, #12]
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 800311c:	f7fc fff4 	bl	8000108 <__udivsi3>
  htim17.Init.Prescaler = uwPrescalerValue;
  htim17.Init.ClockDivision = 0;
 8003120:	2300      	movs	r3, #0
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 8003122:	3801      	subs	r0, #1
  htim17.Init.Prescaler = uwPrescalerValue;
 8003124:	6060      	str	r0, [r4, #4]
  htim17.Init.CounterMode = TIM_COUNTERMODE_UP;
  if(HAL_TIM_Base_Init(&htim17) == HAL_OK)
 8003126:	0020      	movs	r0, r4
  htim17.Init.ClockDivision = 0;
 8003128:	6123      	str	r3, [r4, #16]
  htim17.Init.CounterMode = TIM_COUNTERMODE_UP;
 800312a:	60a3      	str	r3, [r4, #8]
  if(HAL_TIM_Base_Init(&htim17) == HAL_OK)
 800312c:	f7fd fef2 	bl	8000f14 <HAL_TIM_Base_Init>
 8003130:	0003      	movs	r3, r0
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim17);
  }
  
  /* Return function status */
  return HAL_ERROR;
 8003132:	2001      	movs	r0, #1
  if(HAL_TIM_Base_Init(&htim17) == HAL_OK)
 8003134:	2b00      	cmp	r3, #0
 8003136:	d102      	bne.n	800313e <HAL_InitTick+0x62>
    return HAL_TIM_Base_Start_IT(&htim17);
 8003138:	0020      	movs	r0, r4
 800313a:	f7fd fdf0 	bl	8000d1e <HAL_TIM_Base_Start_IT>
}
 800313e:	b006      	add	sp, #24
 8003140:	bd10      	pop	{r4, pc}
 8003142:	46c0      	nop			; (mov r8, r8)
 8003144:	40021000 	.word	0x40021000
 8003148:	200017c8 	.word	0x200017c8
 800314c:	40014800 	.word	0x40014800
 8003150:	000f4240 	.word	0x000f4240
 8003154:	000003e7 	.word	0x000003e7

08003158 <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 8003158:	4770      	bx	lr

0800315a <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 800315a:	e7fe      	b.n	800315a <HardFault_Handler>

0800315c <TIM17_IRQHandler>:

/**
  * @brief This function handles TIM17 global interrupt.
  */
void TIM17_IRQHandler(void)
{
 800315c:	b510      	push	{r4, lr}
  /* USER CODE BEGIN TIM17_IRQn 0 */

  /* USER CODE END TIM17_IRQn 0 */
  HAL_TIM_IRQHandler(&htim17);
 800315e:	4802      	ldr	r0, [pc, #8]	; (8003168 <TIM17_IRQHandler+0xc>)
 8003160:	f7fd fdeb 	bl	8000d3a <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM17_IRQn 1 */

  /* USER CODE END TIM17_IRQn 1 */
}
 8003164:	bd10      	pop	{r4, pc}
 8003166:	46c0      	nop			; (mov r8, r8)
 8003168:	200017c8 	.word	0x200017c8

0800316c <USART1_IRQHandler>:
  return (READ_BIT(USARTx->ISR, USART_ISR_RXNE) == (USART_ISR_RXNE));
 800316c:	4b02      	ldr	r3, [pc, #8]	; (8003178 <USART1_IRQHandler+0xc>)
 800316e:	69da      	ldr	r2, [r3, #28]
  * @brief This function handles USART1 global interrupt.
  */
void USART1_IRQHandler(void)
{
  /* USER CODE BEGIN USART1_IRQn 0 */
	if(LL_USART_IsActiveFlag_RXNE(USART1)){
 8003170:	0692      	lsls	r2, r2, #26
 8003172:	d500      	bpl.n	8003176 <USART1_IRQHandler+0xa>
  * @param  USARTx USART Instance
  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
  */
__STATIC_INLINE uint8_t LL_USART_ReceiveData8(USART_TypeDef *USARTx)
{
  return (uint8_t)(READ_BIT(USARTx->RDR, USART_RDR_RDR));
 8003174:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
	}
  /* USER CODE END USART1_IRQn 0 */
  /* USER CODE BEGIN USART1_IRQn 1 */

  /* USER CODE END USART1_IRQn 1 */
}
 8003176:	4770      	bx	lr
 8003178:	40013800 	.word	0x40013800

0800317c <USART2_IRQHandler>:
  return (READ_BIT(USARTx->ISR, USART_ISR_RXNE) == (USART_ISR_RXNE));
 800317c:	4a15      	ldr	r2, [pc, #84]	; (80031d4 <USART2_IRQHandler+0x58>)

/**
  * @brief This function handles USART2 global interrupt.
  */
void USART2_IRQHandler(void)
{
 800317e:	b570      	push	{r4, r5, r6, lr}
 8003180:	69d3      	ldr	r3, [r2, #28]
  /* USER CODE BEGIN USART2_IRQn 0 */
	if(LL_USART_IsActiveFlag_RXNE(USART2)){
 8003182:	069b      	lsls	r3, r3, #26
 8003184:	d519      	bpl.n	80031ba <USART2_IRQHandler+0x3e>
		remoteCtrlData[remoteCtrlPos]= LL_USART_ReceiveData8(USART2);
 8003186:	4c14      	ldr	r4, [pc, #80]	; (80031d8 <USART2_IRQHandler+0x5c>)
  return (uint8_t)(READ_BIT(USARTx->RDR, USART_RDR_RDR));
 8003188:	8c91      	ldrh	r1, [r2, #36]	; 0x24
 800318a:	7823      	ldrb	r3, [r4, #0]
 800318c:	4a13      	ldr	r2, [pc, #76]	; (80031dc <USART2_IRQHandler+0x60>)
 800318e:	54d1      	strb	r1, [r2, r3]
		if(remoteCtrlPos==0 && remoteCtrlData[0]!=0x00){
 8003190:	2b00      	cmp	r3, #0
 8003192:	d103      	bne.n	800319c <USART2_IRQHandler+0x20>
 8003194:	7812      	ldrb	r2, [r2, #0]
 8003196:	2a00      	cmp	r2, #0
 8003198:	d00c      	beq.n	80031b4 <USART2_IRQHandler+0x38>
	}
  /* USER CODE END USART2_IRQn 0 */
  /* USER CODE BEGIN USART2_IRQn 1 */

  /* USER CODE END USART2_IRQn 1 */
}
 800319a:	bd70      	pop	{r4, r5, r6, pc}
		if(remoteCtrlPos==9) {
 800319c:	2b09      	cmp	r3, #9
 800319e:	d109      	bne.n	80031b4 <USART2_IRQHandler+0x38>
			if(remoteCtrlData[9]!=0x00){
 80031a0:	7a55      	ldrb	r5, [r2, #9]
				remoteCtrlPos=0;
 80031a2:	2300      	movs	r3, #0
			if(remoteCtrlData[9]!=0x00){
 80031a4:	2d00      	cmp	r5, #0
 80031a6:	d106      	bne.n	80031b6 <USART2_IRQHandler+0x3a>
				osSemaphoreRelease(RCTigHandle);
 80031a8:	4b0d      	ldr	r3, [pc, #52]	; (80031e0 <USART2_IRQHandler+0x64>)
 80031aa:	6818      	ldr	r0, [r3, #0]
 80031ac:	f7fe f88e 	bl	80012cc <osSemaphoreRelease>
				remoteCtrlPos=0;
 80031b0:	7025      	strb	r5, [r4, #0]
				return;
 80031b2:	e7f2      	b.n	800319a <USART2_IRQHandler+0x1e>
		remoteCtrlPos++;
 80031b4:	3301      	adds	r3, #1
 80031b6:	7023      	strb	r3, [r4, #0]
		return;
 80031b8:	e7ef      	b.n	800319a <USART2_IRQHandler+0x1e>
  return (READ_BIT(USARTx->ISR, USART_ISR_TC) == (USART_ISR_TC));
 80031ba:	2140      	movs	r1, #64	; 0x40
 80031bc:	69d3      	ldr	r3, [r2, #28]
	if(LL_USART_IsActiveFlag_TC(USART2)){
 80031be:	420b      	tst	r3, r1
 80031c0:	d0eb      	beq.n	800319a <USART2_IRQHandler+0x1e>
  CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 80031c2:	6813      	ldr	r3, [r2, #0]
 80031c4:	438b      	bics	r3, r1
 80031c6:	6013      	str	r3, [r2, #0]
  CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_EN);
 80031c8:	4a06      	ldr	r2, [pc, #24]	; (80031e4 <USART2_IRQHandler+0x68>)
 80031ca:	393f      	subs	r1, #63	; 0x3f
 80031cc:	6813      	ldr	r3, [r2, #0]
 80031ce:	438b      	bics	r3, r1
 80031d0:	6013      	str	r3, [r2, #0]
 80031d2:	e7e2      	b.n	800319a <USART2_IRQHandler+0x1e>
 80031d4:	40004400 	.word	0x40004400
 80031d8:	20001294 	.word	0x20001294
 80031dc:	20001812 	.word	0x20001812
 80031e0:	20001754 	.word	0x20001754
 80031e4:	40020044 	.word	0x40020044

080031e8 <_read>:
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 80031e8:	b570      	push	{r4, r5, r6, lr}
 80031ea:	000e      	movs	r6, r1
 80031ec:	0015      	movs	r5, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80031ee:	000c      	movs	r4, r1
 80031f0:	1ba3      	subs	r3, r4, r6
 80031f2:	429d      	cmp	r5, r3
 80031f4:	dc01      	bgt.n	80031fa <_read+0x12>
	{
		*ptr++ = __io_getchar();
	}

return len;
}
 80031f6:	0028      	movs	r0, r5
 80031f8:	bd70      	pop	{r4, r5, r6, pc}
		*ptr++ = __io_getchar();
 80031fa:	e000      	b.n	80031fe <_read+0x16>
 80031fc:	bf00      	nop
 80031fe:	7020      	strb	r0, [r4, #0]
 8003200:	3401      	adds	r4, #1
 8003202:	e7f5      	b.n	80031f0 <_read+0x8>

08003204 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8003204:	b570      	push	{r4, r5, r6, lr}
 8003206:	000e      	movs	r6, r1
 8003208:	0015      	movs	r5, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800320a:	000c      	movs	r4, r1
 800320c:	1ba3      	subs	r3, r4, r6
 800320e:	429d      	cmp	r5, r3
 8003210:	dc01      	bgt.n	8003216 <_write+0x12>
	{
		__io_putchar(*ptr++);
	}
	return len;
}
 8003212:	0028      	movs	r0, r5
 8003214:	bd70      	pop	{r4, r5, r6, pc}
		__io_putchar(*ptr++);
 8003216:	7820      	ldrb	r0, [r4, #0]
 8003218:	e000      	b.n	800321c <_write+0x18>
 800321a:	bf00      	nop
 800321c:	3401      	adds	r4, #1
 800321e:	e7f5      	b.n	800320c <_write+0x8>

08003220 <_sbrk>:
{
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 8003220:	4b0a      	ldr	r3, [pc, #40]	; (800324c <_sbrk+0x2c>)
{
 8003222:	b510      	push	{r4, lr}
	if (heap_end == 0)
 8003224:	6819      	ldr	r1, [r3, #0]
{
 8003226:	0002      	movs	r2, r0
	if (heap_end == 0)
 8003228:	2900      	cmp	r1, #0
 800322a:	d101      	bne.n	8003230 <_sbrk+0x10>
		heap_end = &end;
 800322c:	4908      	ldr	r1, [pc, #32]	; (8003250 <_sbrk+0x30>)
 800322e:	6019      	str	r1, [r3, #0]

	prev_heap_end = heap_end;
	if (heap_end + incr > stack_ptr)
 8003230:	4669      	mov	r1, sp
	prev_heap_end = heap_end;
 8003232:	6818      	ldr	r0, [r3, #0]
	if (heap_end + incr > stack_ptr)
 8003234:	1882      	adds	r2, r0, r2
 8003236:	428a      	cmp	r2, r1
 8003238:	d906      	bls.n	8003248 <_sbrk+0x28>
	{
//		write(1, "Heap and stack collision\n", 25);
//		abort();
		errno = ENOMEM;
 800323a:	f000 f887 	bl	800334c <__errno>
 800323e:	230c      	movs	r3, #12
 8003240:	6003      	str	r3, [r0, #0]
		return (caddr_t) -1;
 8003242:	2001      	movs	r0, #1
 8003244:	4240      	negs	r0, r0
	}

	heap_end += incr;

	return (caddr_t) prev_heap_end;
}
 8003246:	bd10      	pop	{r4, pc}
	heap_end += incr;
 8003248:	601a      	str	r2, [r3, #0]
	return (caddr_t) prev_heap_end;
 800324a:	e7fc      	b.n	8003246 <_sbrk+0x26>
 800324c:	20001298 	.word	0x20001298
 8003250:	20001820 	.word	0x20001820

08003254 <_close>:

int _close(int file)
{
	return -1;
}
 8003254:	2001      	movs	r0, #1
 8003256:	4240      	negs	r0, r0
 8003258:	4770      	bx	lr

0800325a <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 800325a:	2380      	movs	r3, #128	; 0x80
 800325c:	019b      	lsls	r3, r3, #6
	return 0;
}
 800325e:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
 8003260:	604b      	str	r3, [r1, #4]
}
 8003262:	4770      	bx	lr

08003264 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 8003264:	2001      	movs	r0, #1
 8003266:	4770      	bx	lr

08003268 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 8003268:	2000      	movs	r0, #0
 800326a:	4770      	bx	lr

0800326c <SystemInit>:
  */
void SystemInit(void)
{
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001U;
 800326c:	2101      	movs	r1, #1
 800326e:	4b11      	ldr	r3, [pc, #68]	; (80032b4 <SystemInit+0x48>)
#if defined (STM32F051x8) || defined (STM32F058x8)
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE and MCOSEL[2:0] bits */
  RCC->CFGR &= (uint32_t)0xF8FFB80CU;
#else
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE, MCOSEL[2:0], MCOPRE[2:0] and PLLNODIV bits */
  RCC->CFGR &= (uint32_t)0x08FFB80CU;
 8003270:	4811      	ldr	r0, [pc, #68]	; (80032b8 <SystemInit+0x4c>)
  RCC->CR |= (uint32_t)0x00000001U;
 8003272:	681a      	ldr	r2, [r3, #0]
 8003274:	430a      	orrs	r2, r1
 8003276:	601a      	str	r2, [r3, #0]
  RCC->CFGR &= (uint32_t)0x08FFB80CU;
 8003278:	685a      	ldr	r2, [r3, #4]
 800327a:	4002      	ands	r2, r0
 800327c:	605a      	str	r2, [r3, #4]
#endif /* STM32F051x8 or STM32F058x8 */
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFFU;
 800327e:	681a      	ldr	r2, [r3, #0]
 8003280:	480e      	ldr	r0, [pc, #56]	; (80032bc <SystemInit+0x50>)
 8003282:	4002      	ands	r2, r0
 8003284:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFFU;
 8003286:	681a      	ldr	r2, [r3, #0]
 8003288:	480d      	ldr	r0, [pc, #52]	; (80032c0 <SystemInit+0x54>)
 800328a:	4002      	ands	r2, r0
 800328c:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  RCC->CFGR &= (uint32_t)0xFFC0FFFFU;
 800328e:	685a      	ldr	r2, [r3, #4]
 8003290:	480c      	ldr	r0, [pc, #48]	; (80032c4 <SystemInit+0x58>)
 8003292:	4002      	ands	r2, r0

  /* Reset PREDIV[3:0] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0U;
 8003294:	200f      	movs	r0, #15
  RCC->CFGR &= (uint32_t)0xFFC0FFFFU;
 8003296:	605a      	str	r2, [r3, #4]
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0U;
 8003298:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800329a:	4382      	bics	r2, r0
 800329c:	62da      	str	r2, [r3, #44]	; 0x2c
#elif defined (STM32F091xC) || defined (STM32F098xx)
  /* Reset USART3SW[1:0], USART2SW[1:0], USART1SW[1:0], I2C1SW, CECSW and ADCSW bits */
  RCC->CFGR3 &= (uint32_t)0xFFF0FEACU;
#elif defined (STM32F030x6) || defined (STM32F030x8) || defined (STM32F031x6) || defined (STM32F038xx) || defined (STM32F030xC)
  /* Reset USART1SW[1:0], I2C1SW and ADCSW bits */
  RCC->CFGR3 &= (uint32_t)0xFFFFFEECU;
 800329e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80032a0:	4809      	ldr	r0, [pc, #36]	; (80032c8 <SystemInit+0x5c>)
 80032a2:	4002      	ands	r2, r0
 80032a4:	631a      	str	r2, [r3, #48]	; 0x30
#else
 #warning "No target selected"
#endif

  /* Reset HSI14 bit */
  RCC->CR2 &= (uint32_t)0xFFFFFFFEU;
 80032a6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80032a8:	438a      	bics	r2, r1
 80032aa:	635a      	str	r2, [r3, #52]	; 0x34

  /* Disable all interrupts */
  RCC->CIR = 0x00000000U;
 80032ac:	2200      	movs	r2, #0
 80032ae:	609a      	str	r2, [r3, #8]

}
 80032b0:	4770      	bx	lr
 80032b2:	46c0      	nop			; (mov r8, r8)
 80032b4:	40021000 	.word	0x40021000
 80032b8:	08ffb80c 	.word	0x08ffb80c
 80032bc:	fef6ffff 	.word	0xfef6ffff
 80032c0:	fffbffff 	.word	0xfffbffff
 80032c4:	ffc0ffff 	.word	0xffc0ffff
 80032c8:	fffffeec 	.word	0xfffffeec

080032cc <USER_status>:
DSTATUS USER_status (
	BYTE pdrv       /* Physical drive number to identify the drive */
)
{
  /* USER CODE BEGIN STATUS */
    Stat = STA_NOINIT;
 80032cc:	2201      	movs	r2, #1
 80032ce:	4b02      	ldr	r3, [pc, #8]	; (80032d8 <USER_status+0xc>)
 80032d0:	701a      	strb	r2, [r3, #0]
    return Stat;
 80032d2:	7818      	ldrb	r0, [r3, #0]
 80032d4:	b2c0      	uxtb	r0, r0
  /* USER CODE END STATUS */
}
 80032d6:	4770      	bx	lr
 80032d8:	20000008 	.word	0x20000008

080032dc <USER_write>:
{ 
  /* USER CODE BEGIN WRITE */
  /* USER CODE HERE */
    return RES_OK;
  /* USER CODE END WRITE */
}
 80032dc:	2000      	movs	r0, #0
 80032de:	4770      	bx	lr

080032e0 <USER_ioctl>:
{
  /* USER CODE BEGIN IOCTL */
    DRESULT res = RES_ERROR;
    return res;
  /* USER CODE END IOCTL */
}
 80032e0:	2001      	movs	r0, #1
 80032e2:	4770      	bx	lr

080032e4 <USER_read>:
 80032e4:	2000      	movs	r0, #0
 80032e6:	4770      	bx	lr

080032e8 <USER_initialize>:
 80032e8:	2201      	movs	r2, #1
 80032ea:	4b02      	ldr	r3, [pc, #8]	; (80032f4 <USER_initialize+0xc>)
 80032ec:	701a      	strb	r2, [r3, #0]
 80032ee:	7818      	ldrb	r0, [r3, #0]
 80032f0:	b2c0      	uxtb	r0, r0
 80032f2:	4770      	bx	lr
 80032f4:	20000008 	.word	0x20000008

080032f8 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 80032f8:	480d      	ldr	r0, [pc, #52]	; (8003330 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 80032fa:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 80032fc:	480d      	ldr	r0, [pc, #52]	; (8003334 <LoopForever+0x6>)
  ldr r1, =_edata
 80032fe:	490e      	ldr	r1, [pc, #56]	; (8003338 <LoopForever+0xa>)
  ldr r2, =_sidata
 8003300:	4a0e      	ldr	r2, [pc, #56]	; (800333c <LoopForever+0xe>)
  movs r3, #0
 8003302:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8003304:	e002      	b.n	800330c <LoopCopyDataInit>

08003306 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8003306:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8003308:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800330a:	3304      	adds	r3, #4

0800330c <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 800330c:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800330e:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8003310:	d3f9      	bcc.n	8003306 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8003312:	4a0b      	ldr	r2, [pc, #44]	; (8003340 <LoopForever+0x12>)
  ldr r4, =_ebss
 8003314:	4c0b      	ldr	r4, [pc, #44]	; (8003344 <LoopForever+0x16>)
  movs r3, #0
 8003316:	2300      	movs	r3, #0
  b LoopFillZerobss
 8003318:	e001      	b.n	800331e <LoopFillZerobss>

0800331a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800331a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800331c:	3204      	adds	r2, #4

0800331e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800331e:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8003320:	d3fb      	bcc.n	800331a <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 8003322:	f7ff ffa3 	bl	800326c <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 8003326:	f000 f817 	bl	8003358 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 800332a:	f7ff fab1 	bl	8002890 <main>

0800332e <LoopForever>:

LoopForever:
    b LoopForever
 800332e:	e7fe      	b.n	800332e <LoopForever>
  ldr   r0, =_estack
 8003330:	20002000 	.word	0x20002000
  ldr r0, =_sdata
 8003334:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8003338:	20000084 	.word	0x20000084
  ldr r2, =_sidata
 800333c:	08004388 	.word	0x08004388
  ldr r2, =_sbss
 8003340:	20000084 	.word	0x20000084
  ldr r4, =_ebss
 8003344:	20001820 	.word	0x20001820

08003348 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8003348:	e7fe      	b.n	8003348 <ADC1_IRQHandler>
	...

0800334c <__errno>:
 800334c:	4b01      	ldr	r3, [pc, #4]	; (8003354 <__errno+0x8>)
 800334e:	6818      	ldr	r0, [r3, #0]
 8003350:	4770      	bx	lr
 8003352:	46c0      	nop			; (mov r8, r8)
 8003354:	20000020 	.word	0x20000020

08003358 <__libc_init_array>:
 8003358:	b570      	push	{r4, r5, r6, lr}
 800335a:	2600      	movs	r6, #0
 800335c:	4d0c      	ldr	r5, [pc, #48]	; (8003390 <__libc_init_array+0x38>)
 800335e:	4c0d      	ldr	r4, [pc, #52]	; (8003394 <__libc_init_array+0x3c>)
 8003360:	1b64      	subs	r4, r4, r5
 8003362:	10a4      	asrs	r4, r4, #2
 8003364:	42a6      	cmp	r6, r4
 8003366:	d109      	bne.n	800337c <__libc_init_array+0x24>
 8003368:	2600      	movs	r6, #0
 800336a:	f000 ff5d 	bl	8004228 <_init>
 800336e:	4d0a      	ldr	r5, [pc, #40]	; (8003398 <__libc_init_array+0x40>)
 8003370:	4c0a      	ldr	r4, [pc, #40]	; (800339c <__libc_init_array+0x44>)
 8003372:	1b64      	subs	r4, r4, r5
 8003374:	10a4      	asrs	r4, r4, #2
 8003376:	42a6      	cmp	r6, r4
 8003378:	d105      	bne.n	8003386 <__libc_init_array+0x2e>
 800337a:	bd70      	pop	{r4, r5, r6, pc}
 800337c:	00b3      	lsls	r3, r6, #2
 800337e:	58eb      	ldr	r3, [r5, r3]
 8003380:	4798      	blx	r3
 8003382:	3601      	adds	r6, #1
 8003384:	e7ee      	b.n	8003364 <__libc_init_array+0xc>
 8003386:	00b3      	lsls	r3, r6, #2
 8003388:	58eb      	ldr	r3, [r5, r3]
 800338a:	4798      	blx	r3
 800338c:	3601      	adds	r6, #1
 800338e:	e7f2      	b.n	8003376 <__libc_init_array+0x1e>
 8003390:	08004380 	.word	0x08004380
 8003394:	08004380 	.word	0x08004380
 8003398:	08004380 	.word	0x08004380
 800339c:	08004384 	.word	0x08004384

080033a0 <memcpy>:
 80033a0:	2300      	movs	r3, #0
 80033a2:	b510      	push	{r4, lr}
 80033a4:	429a      	cmp	r2, r3
 80033a6:	d100      	bne.n	80033aa <memcpy+0xa>
 80033a8:	bd10      	pop	{r4, pc}
 80033aa:	5ccc      	ldrb	r4, [r1, r3]
 80033ac:	54c4      	strb	r4, [r0, r3]
 80033ae:	3301      	adds	r3, #1
 80033b0:	e7f8      	b.n	80033a4 <memcpy+0x4>

080033b2 <memset>:
 80033b2:	0003      	movs	r3, r0
 80033b4:	1882      	adds	r2, r0, r2
 80033b6:	4293      	cmp	r3, r2
 80033b8:	d100      	bne.n	80033bc <memset+0xa>
 80033ba:	4770      	bx	lr
 80033bc:	7019      	strb	r1, [r3, #0]
 80033be:	3301      	adds	r3, #1
 80033c0:	e7f9      	b.n	80033b6 <memset+0x4>
	...

080033c4 <iprintf>:
 80033c4:	b40f      	push	{r0, r1, r2, r3}
 80033c6:	4b0b      	ldr	r3, [pc, #44]	; (80033f4 <iprintf+0x30>)
 80033c8:	b513      	push	{r0, r1, r4, lr}
 80033ca:	681c      	ldr	r4, [r3, #0]
 80033cc:	2c00      	cmp	r4, #0
 80033ce:	d005      	beq.n	80033dc <iprintf+0x18>
 80033d0:	69a3      	ldr	r3, [r4, #24]
 80033d2:	2b00      	cmp	r3, #0
 80033d4:	d102      	bne.n	80033dc <iprintf+0x18>
 80033d6:	0020      	movs	r0, r4
 80033d8:	f000 f850 	bl	800347c <__sinit>
 80033dc:	ab05      	add	r3, sp, #20
 80033de:	9a04      	ldr	r2, [sp, #16]
 80033e0:	68a1      	ldr	r1, [r4, #8]
 80033e2:	0020      	movs	r0, r4
 80033e4:	9301      	str	r3, [sp, #4]
 80033e6:	f000 f965 	bl	80036b4 <_vfiprintf_r>
 80033ea:	bc16      	pop	{r1, r2, r4}
 80033ec:	bc08      	pop	{r3}
 80033ee:	b004      	add	sp, #16
 80033f0:	4718      	bx	r3
 80033f2:	46c0      	nop			; (mov r8, r8)
 80033f4:	20000020 	.word	0x20000020

080033f8 <_cleanup_r>:
 80033f8:	b510      	push	{r4, lr}
 80033fa:	4902      	ldr	r1, [pc, #8]	; (8003404 <_cleanup_r+0xc>)
 80033fc:	f000 f8b2 	bl	8003564 <_fwalk_reent>
 8003400:	bd10      	pop	{r4, pc}
 8003402:	46c0      	nop			; (mov r8, r8)
 8003404:	08003fb1 	.word	0x08003fb1

08003408 <std.isra.0>:
 8003408:	2300      	movs	r3, #0
 800340a:	b510      	push	{r4, lr}
 800340c:	0004      	movs	r4, r0
 800340e:	6003      	str	r3, [r0, #0]
 8003410:	6043      	str	r3, [r0, #4]
 8003412:	6083      	str	r3, [r0, #8]
 8003414:	8181      	strh	r1, [r0, #12]
 8003416:	6643      	str	r3, [r0, #100]	; 0x64
 8003418:	81c2      	strh	r2, [r0, #14]
 800341a:	6103      	str	r3, [r0, #16]
 800341c:	6143      	str	r3, [r0, #20]
 800341e:	6183      	str	r3, [r0, #24]
 8003420:	0019      	movs	r1, r3
 8003422:	2208      	movs	r2, #8
 8003424:	305c      	adds	r0, #92	; 0x5c
 8003426:	f7ff ffc4 	bl	80033b2 <memset>
 800342a:	4b05      	ldr	r3, [pc, #20]	; (8003440 <std.isra.0+0x38>)
 800342c:	6224      	str	r4, [r4, #32]
 800342e:	6263      	str	r3, [r4, #36]	; 0x24
 8003430:	4b04      	ldr	r3, [pc, #16]	; (8003444 <std.isra.0+0x3c>)
 8003432:	62a3      	str	r3, [r4, #40]	; 0x28
 8003434:	4b04      	ldr	r3, [pc, #16]	; (8003448 <std.isra.0+0x40>)
 8003436:	62e3      	str	r3, [r4, #44]	; 0x2c
 8003438:	4b04      	ldr	r3, [pc, #16]	; (800344c <std.isra.0+0x44>)
 800343a:	6323      	str	r3, [r4, #48]	; 0x30
 800343c:	bd10      	pop	{r4, pc}
 800343e:	46c0      	nop			; (mov r8, r8)
 8003440:	08003c21 	.word	0x08003c21
 8003444:	08003c49 	.word	0x08003c49
 8003448:	08003c81 	.word	0x08003c81
 800344c:	08003cad 	.word	0x08003cad

08003450 <__sfmoreglue>:
 8003450:	b570      	push	{r4, r5, r6, lr}
 8003452:	2568      	movs	r5, #104	; 0x68
 8003454:	1e4a      	subs	r2, r1, #1
 8003456:	4355      	muls	r5, r2
 8003458:	000e      	movs	r6, r1
 800345a:	0029      	movs	r1, r5
 800345c:	3174      	adds	r1, #116	; 0x74
 800345e:	f000 f8a3 	bl	80035a8 <_malloc_r>
 8003462:	1e04      	subs	r4, r0, #0
 8003464:	d008      	beq.n	8003478 <__sfmoreglue+0x28>
 8003466:	2100      	movs	r1, #0
 8003468:	002a      	movs	r2, r5
 800346a:	6001      	str	r1, [r0, #0]
 800346c:	6046      	str	r6, [r0, #4]
 800346e:	300c      	adds	r0, #12
 8003470:	60a0      	str	r0, [r4, #8]
 8003472:	3268      	adds	r2, #104	; 0x68
 8003474:	f7ff ff9d 	bl	80033b2 <memset>
 8003478:	0020      	movs	r0, r4
 800347a:	bd70      	pop	{r4, r5, r6, pc}

0800347c <__sinit>:
 800347c:	6983      	ldr	r3, [r0, #24]
 800347e:	b513      	push	{r0, r1, r4, lr}
 8003480:	0004      	movs	r4, r0
 8003482:	2b00      	cmp	r3, #0
 8003484:	d128      	bne.n	80034d8 <__sinit+0x5c>
 8003486:	6483      	str	r3, [r0, #72]	; 0x48
 8003488:	64c3      	str	r3, [r0, #76]	; 0x4c
 800348a:	6503      	str	r3, [r0, #80]	; 0x50
 800348c:	4b13      	ldr	r3, [pc, #76]	; (80034dc <__sinit+0x60>)
 800348e:	4a14      	ldr	r2, [pc, #80]	; (80034e0 <__sinit+0x64>)
 8003490:	681b      	ldr	r3, [r3, #0]
 8003492:	6282      	str	r2, [r0, #40]	; 0x28
 8003494:	9301      	str	r3, [sp, #4]
 8003496:	4298      	cmp	r0, r3
 8003498:	d101      	bne.n	800349e <__sinit+0x22>
 800349a:	2301      	movs	r3, #1
 800349c:	6183      	str	r3, [r0, #24]
 800349e:	0020      	movs	r0, r4
 80034a0:	f000 f820 	bl	80034e4 <__sfp>
 80034a4:	6060      	str	r0, [r4, #4]
 80034a6:	0020      	movs	r0, r4
 80034a8:	f000 f81c 	bl	80034e4 <__sfp>
 80034ac:	60a0      	str	r0, [r4, #8]
 80034ae:	0020      	movs	r0, r4
 80034b0:	f000 f818 	bl	80034e4 <__sfp>
 80034b4:	2200      	movs	r2, #0
 80034b6:	60e0      	str	r0, [r4, #12]
 80034b8:	2104      	movs	r1, #4
 80034ba:	6860      	ldr	r0, [r4, #4]
 80034bc:	f7ff ffa4 	bl	8003408 <std.isra.0>
 80034c0:	2201      	movs	r2, #1
 80034c2:	2109      	movs	r1, #9
 80034c4:	68a0      	ldr	r0, [r4, #8]
 80034c6:	f7ff ff9f 	bl	8003408 <std.isra.0>
 80034ca:	2202      	movs	r2, #2
 80034cc:	2112      	movs	r1, #18
 80034ce:	68e0      	ldr	r0, [r4, #12]
 80034d0:	f7ff ff9a 	bl	8003408 <std.isra.0>
 80034d4:	2301      	movs	r3, #1
 80034d6:	61a3      	str	r3, [r4, #24]
 80034d8:	bd13      	pop	{r0, r1, r4, pc}
 80034da:	46c0      	nop			; (mov r8, r8)
 80034dc:	080042e8 	.word	0x080042e8
 80034e0:	080033f9 	.word	0x080033f9

080034e4 <__sfp>:
 80034e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80034e6:	4b1e      	ldr	r3, [pc, #120]	; (8003560 <__sfp+0x7c>)
 80034e8:	0007      	movs	r7, r0
 80034ea:	681e      	ldr	r6, [r3, #0]
 80034ec:	69b3      	ldr	r3, [r6, #24]
 80034ee:	2b00      	cmp	r3, #0
 80034f0:	d102      	bne.n	80034f8 <__sfp+0x14>
 80034f2:	0030      	movs	r0, r6
 80034f4:	f7ff ffc2 	bl	800347c <__sinit>
 80034f8:	3648      	adds	r6, #72	; 0x48
 80034fa:	68b4      	ldr	r4, [r6, #8]
 80034fc:	6873      	ldr	r3, [r6, #4]
 80034fe:	3b01      	subs	r3, #1
 8003500:	d504      	bpl.n	800350c <__sfp+0x28>
 8003502:	6833      	ldr	r3, [r6, #0]
 8003504:	2b00      	cmp	r3, #0
 8003506:	d007      	beq.n	8003518 <__sfp+0x34>
 8003508:	6836      	ldr	r6, [r6, #0]
 800350a:	e7f6      	b.n	80034fa <__sfp+0x16>
 800350c:	220c      	movs	r2, #12
 800350e:	5ea5      	ldrsh	r5, [r4, r2]
 8003510:	2d00      	cmp	r5, #0
 8003512:	d00d      	beq.n	8003530 <__sfp+0x4c>
 8003514:	3468      	adds	r4, #104	; 0x68
 8003516:	e7f2      	b.n	80034fe <__sfp+0x1a>
 8003518:	2104      	movs	r1, #4
 800351a:	0038      	movs	r0, r7
 800351c:	f7ff ff98 	bl	8003450 <__sfmoreglue>
 8003520:	6030      	str	r0, [r6, #0]
 8003522:	2800      	cmp	r0, #0
 8003524:	d1f0      	bne.n	8003508 <__sfp+0x24>
 8003526:	230c      	movs	r3, #12
 8003528:	0004      	movs	r4, r0
 800352a:	603b      	str	r3, [r7, #0]
 800352c:	0020      	movs	r0, r4
 800352e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003530:	2301      	movs	r3, #1
 8003532:	0020      	movs	r0, r4
 8003534:	425b      	negs	r3, r3
 8003536:	81e3      	strh	r3, [r4, #14]
 8003538:	3302      	adds	r3, #2
 800353a:	81a3      	strh	r3, [r4, #12]
 800353c:	6665      	str	r5, [r4, #100]	; 0x64
 800353e:	6025      	str	r5, [r4, #0]
 8003540:	60a5      	str	r5, [r4, #8]
 8003542:	6065      	str	r5, [r4, #4]
 8003544:	6125      	str	r5, [r4, #16]
 8003546:	6165      	str	r5, [r4, #20]
 8003548:	61a5      	str	r5, [r4, #24]
 800354a:	2208      	movs	r2, #8
 800354c:	0029      	movs	r1, r5
 800354e:	305c      	adds	r0, #92	; 0x5c
 8003550:	f7ff ff2f 	bl	80033b2 <memset>
 8003554:	6365      	str	r5, [r4, #52]	; 0x34
 8003556:	63a5      	str	r5, [r4, #56]	; 0x38
 8003558:	64a5      	str	r5, [r4, #72]	; 0x48
 800355a:	64e5      	str	r5, [r4, #76]	; 0x4c
 800355c:	e7e6      	b.n	800352c <__sfp+0x48>
 800355e:	46c0      	nop			; (mov r8, r8)
 8003560:	080042e8 	.word	0x080042e8

08003564 <_fwalk_reent>:
 8003564:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8003566:	0004      	movs	r4, r0
 8003568:	0007      	movs	r7, r0
 800356a:	2600      	movs	r6, #0
 800356c:	9101      	str	r1, [sp, #4]
 800356e:	3448      	adds	r4, #72	; 0x48
 8003570:	2c00      	cmp	r4, #0
 8003572:	d101      	bne.n	8003578 <_fwalk_reent+0x14>
 8003574:	0030      	movs	r0, r6
 8003576:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8003578:	6863      	ldr	r3, [r4, #4]
 800357a:	68a5      	ldr	r5, [r4, #8]
 800357c:	9300      	str	r3, [sp, #0]
 800357e:	9b00      	ldr	r3, [sp, #0]
 8003580:	3b01      	subs	r3, #1
 8003582:	9300      	str	r3, [sp, #0]
 8003584:	d501      	bpl.n	800358a <_fwalk_reent+0x26>
 8003586:	6824      	ldr	r4, [r4, #0]
 8003588:	e7f2      	b.n	8003570 <_fwalk_reent+0xc>
 800358a:	89ab      	ldrh	r3, [r5, #12]
 800358c:	2b01      	cmp	r3, #1
 800358e:	d908      	bls.n	80035a2 <_fwalk_reent+0x3e>
 8003590:	220e      	movs	r2, #14
 8003592:	5eab      	ldrsh	r3, [r5, r2]
 8003594:	3301      	adds	r3, #1
 8003596:	d004      	beq.n	80035a2 <_fwalk_reent+0x3e>
 8003598:	0029      	movs	r1, r5
 800359a:	0038      	movs	r0, r7
 800359c:	9b01      	ldr	r3, [sp, #4]
 800359e:	4798      	blx	r3
 80035a0:	4306      	orrs	r6, r0
 80035a2:	3568      	adds	r5, #104	; 0x68
 80035a4:	e7eb      	b.n	800357e <_fwalk_reent+0x1a>
	...

080035a8 <_malloc_r>:
 80035a8:	2303      	movs	r3, #3
 80035aa:	b570      	push	{r4, r5, r6, lr}
 80035ac:	1ccd      	adds	r5, r1, #3
 80035ae:	439d      	bics	r5, r3
 80035b0:	3508      	adds	r5, #8
 80035b2:	0006      	movs	r6, r0
 80035b4:	2d0c      	cmp	r5, #12
 80035b6:	d21e      	bcs.n	80035f6 <_malloc_r+0x4e>
 80035b8:	250c      	movs	r5, #12
 80035ba:	42a9      	cmp	r1, r5
 80035bc:	d81d      	bhi.n	80035fa <_malloc_r+0x52>
 80035be:	0030      	movs	r0, r6
 80035c0:	f000 fdad 	bl	800411e <__malloc_lock>
 80035c4:	4a25      	ldr	r2, [pc, #148]	; (800365c <_malloc_r+0xb4>)
 80035c6:	6814      	ldr	r4, [r2, #0]
 80035c8:	0021      	movs	r1, r4
 80035ca:	2900      	cmp	r1, #0
 80035cc:	d119      	bne.n	8003602 <_malloc_r+0x5a>
 80035ce:	4c24      	ldr	r4, [pc, #144]	; (8003660 <_malloc_r+0xb8>)
 80035d0:	6823      	ldr	r3, [r4, #0]
 80035d2:	2b00      	cmp	r3, #0
 80035d4:	d103      	bne.n	80035de <_malloc_r+0x36>
 80035d6:	0030      	movs	r0, r6
 80035d8:	f000 fb10 	bl	8003bfc <_sbrk_r>
 80035dc:	6020      	str	r0, [r4, #0]
 80035de:	0029      	movs	r1, r5
 80035e0:	0030      	movs	r0, r6
 80035e2:	f000 fb0b 	bl	8003bfc <_sbrk_r>
 80035e6:	1c43      	adds	r3, r0, #1
 80035e8:	d12c      	bne.n	8003644 <_malloc_r+0x9c>
 80035ea:	230c      	movs	r3, #12
 80035ec:	0030      	movs	r0, r6
 80035ee:	6033      	str	r3, [r6, #0]
 80035f0:	f000 fd96 	bl	8004120 <__malloc_unlock>
 80035f4:	e003      	b.n	80035fe <_malloc_r+0x56>
 80035f6:	2d00      	cmp	r5, #0
 80035f8:	dadf      	bge.n	80035ba <_malloc_r+0x12>
 80035fa:	230c      	movs	r3, #12
 80035fc:	6033      	str	r3, [r6, #0]
 80035fe:	2000      	movs	r0, #0
 8003600:	bd70      	pop	{r4, r5, r6, pc}
 8003602:	680b      	ldr	r3, [r1, #0]
 8003604:	1b5b      	subs	r3, r3, r5
 8003606:	d41a      	bmi.n	800363e <_malloc_r+0x96>
 8003608:	2b0b      	cmp	r3, #11
 800360a:	d903      	bls.n	8003614 <_malloc_r+0x6c>
 800360c:	600b      	str	r3, [r1, #0]
 800360e:	18cc      	adds	r4, r1, r3
 8003610:	6025      	str	r5, [r4, #0]
 8003612:	e003      	b.n	800361c <_malloc_r+0x74>
 8003614:	428c      	cmp	r4, r1
 8003616:	d10e      	bne.n	8003636 <_malloc_r+0x8e>
 8003618:	6863      	ldr	r3, [r4, #4]
 800361a:	6013      	str	r3, [r2, #0]
 800361c:	0030      	movs	r0, r6
 800361e:	f000 fd7f 	bl	8004120 <__malloc_unlock>
 8003622:	0020      	movs	r0, r4
 8003624:	2207      	movs	r2, #7
 8003626:	300b      	adds	r0, #11
 8003628:	1d23      	adds	r3, r4, #4
 800362a:	4390      	bics	r0, r2
 800362c:	1ac3      	subs	r3, r0, r3
 800362e:	d0e7      	beq.n	8003600 <_malloc_r+0x58>
 8003630:	425a      	negs	r2, r3
 8003632:	50e2      	str	r2, [r4, r3]
 8003634:	e7e4      	b.n	8003600 <_malloc_r+0x58>
 8003636:	684b      	ldr	r3, [r1, #4]
 8003638:	6063      	str	r3, [r4, #4]
 800363a:	000c      	movs	r4, r1
 800363c:	e7ee      	b.n	800361c <_malloc_r+0x74>
 800363e:	000c      	movs	r4, r1
 8003640:	6849      	ldr	r1, [r1, #4]
 8003642:	e7c2      	b.n	80035ca <_malloc_r+0x22>
 8003644:	2303      	movs	r3, #3
 8003646:	1cc4      	adds	r4, r0, #3
 8003648:	439c      	bics	r4, r3
 800364a:	42a0      	cmp	r0, r4
 800364c:	d0e0      	beq.n	8003610 <_malloc_r+0x68>
 800364e:	1a21      	subs	r1, r4, r0
 8003650:	0030      	movs	r0, r6
 8003652:	f000 fad3 	bl	8003bfc <_sbrk_r>
 8003656:	1c43      	adds	r3, r0, #1
 8003658:	d1da      	bne.n	8003610 <_malloc_r+0x68>
 800365a:	e7c6      	b.n	80035ea <_malloc_r+0x42>
 800365c:	2000129c 	.word	0x2000129c
 8003660:	200012a0 	.word	0x200012a0

08003664 <__sfputc_r>:
 8003664:	6893      	ldr	r3, [r2, #8]
 8003666:	b510      	push	{r4, lr}
 8003668:	3b01      	subs	r3, #1
 800366a:	6093      	str	r3, [r2, #8]
 800366c:	2b00      	cmp	r3, #0
 800366e:	da05      	bge.n	800367c <__sfputc_r+0x18>
 8003670:	6994      	ldr	r4, [r2, #24]
 8003672:	42a3      	cmp	r3, r4
 8003674:	db08      	blt.n	8003688 <__sfputc_r+0x24>
 8003676:	b2cb      	uxtb	r3, r1
 8003678:	2b0a      	cmp	r3, #10
 800367a:	d005      	beq.n	8003688 <__sfputc_r+0x24>
 800367c:	6813      	ldr	r3, [r2, #0]
 800367e:	1c58      	adds	r0, r3, #1
 8003680:	6010      	str	r0, [r2, #0]
 8003682:	7019      	strb	r1, [r3, #0]
 8003684:	b2c8      	uxtb	r0, r1
 8003686:	bd10      	pop	{r4, pc}
 8003688:	f000 fb16 	bl	8003cb8 <__swbuf_r>
 800368c:	e7fb      	b.n	8003686 <__sfputc_r+0x22>

0800368e <__sfputs_r>:
 800368e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003690:	0006      	movs	r6, r0
 8003692:	000f      	movs	r7, r1
 8003694:	0014      	movs	r4, r2
 8003696:	18d5      	adds	r5, r2, r3
 8003698:	42ac      	cmp	r4, r5
 800369a:	d101      	bne.n	80036a0 <__sfputs_r+0x12>
 800369c:	2000      	movs	r0, #0
 800369e:	e007      	b.n	80036b0 <__sfputs_r+0x22>
 80036a0:	7821      	ldrb	r1, [r4, #0]
 80036a2:	003a      	movs	r2, r7
 80036a4:	0030      	movs	r0, r6
 80036a6:	f7ff ffdd 	bl	8003664 <__sfputc_r>
 80036aa:	3401      	adds	r4, #1
 80036ac:	1c43      	adds	r3, r0, #1
 80036ae:	d1f3      	bne.n	8003698 <__sfputs_r+0xa>
 80036b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080036b4 <_vfiprintf_r>:
 80036b4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80036b6:	b09f      	sub	sp, #124	; 0x7c
 80036b8:	0006      	movs	r6, r0
 80036ba:	000f      	movs	r7, r1
 80036bc:	0014      	movs	r4, r2
 80036be:	9305      	str	r3, [sp, #20]
 80036c0:	2800      	cmp	r0, #0
 80036c2:	d004      	beq.n	80036ce <_vfiprintf_r+0x1a>
 80036c4:	6983      	ldr	r3, [r0, #24]
 80036c6:	2b00      	cmp	r3, #0
 80036c8:	d101      	bne.n	80036ce <_vfiprintf_r+0x1a>
 80036ca:	f7ff fed7 	bl	800347c <__sinit>
 80036ce:	4b7f      	ldr	r3, [pc, #508]	; (80038cc <_vfiprintf_r+0x218>)
 80036d0:	429f      	cmp	r7, r3
 80036d2:	d15c      	bne.n	800378e <_vfiprintf_r+0xda>
 80036d4:	6877      	ldr	r7, [r6, #4]
 80036d6:	89bb      	ldrh	r3, [r7, #12]
 80036d8:	071b      	lsls	r3, r3, #28
 80036da:	d562      	bpl.n	80037a2 <_vfiprintf_r+0xee>
 80036dc:	693b      	ldr	r3, [r7, #16]
 80036de:	2b00      	cmp	r3, #0
 80036e0:	d05f      	beq.n	80037a2 <_vfiprintf_r+0xee>
 80036e2:	2300      	movs	r3, #0
 80036e4:	ad06      	add	r5, sp, #24
 80036e6:	616b      	str	r3, [r5, #20]
 80036e8:	3320      	adds	r3, #32
 80036ea:	766b      	strb	r3, [r5, #25]
 80036ec:	3310      	adds	r3, #16
 80036ee:	76ab      	strb	r3, [r5, #26]
 80036f0:	9402      	str	r4, [sp, #8]
 80036f2:	9c02      	ldr	r4, [sp, #8]
 80036f4:	7823      	ldrb	r3, [r4, #0]
 80036f6:	2b00      	cmp	r3, #0
 80036f8:	d15d      	bne.n	80037b6 <_vfiprintf_r+0x102>
 80036fa:	9b02      	ldr	r3, [sp, #8]
 80036fc:	1ae3      	subs	r3, r4, r3
 80036fe:	9304      	str	r3, [sp, #16]
 8003700:	d00d      	beq.n	800371e <_vfiprintf_r+0x6a>
 8003702:	9b04      	ldr	r3, [sp, #16]
 8003704:	9a02      	ldr	r2, [sp, #8]
 8003706:	0039      	movs	r1, r7
 8003708:	0030      	movs	r0, r6
 800370a:	f7ff ffc0 	bl	800368e <__sfputs_r>
 800370e:	1c43      	adds	r3, r0, #1
 8003710:	d100      	bne.n	8003714 <_vfiprintf_r+0x60>
 8003712:	e0cc      	b.n	80038ae <_vfiprintf_r+0x1fa>
 8003714:	696a      	ldr	r2, [r5, #20]
 8003716:	9b04      	ldr	r3, [sp, #16]
 8003718:	4694      	mov	ip, r2
 800371a:	4463      	add	r3, ip
 800371c:	616b      	str	r3, [r5, #20]
 800371e:	7823      	ldrb	r3, [r4, #0]
 8003720:	2b00      	cmp	r3, #0
 8003722:	d100      	bne.n	8003726 <_vfiprintf_r+0x72>
 8003724:	e0c3      	b.n	80038ae <_vfiprintf_r+0x1fa>
 8003726:	2201      	movs	r2, #1
 8003728:	2300      	movs	r3, #0
 800372a:	4252      	negs	r2, r2
 800372c:	606a      	str	r2, [r5, #4]
 800372e:	a902      	add	r1, sp, #8
 8003730:	3254      	adds	r2, #84	; 0x54
 8003732:	1852      	adds	r2, r2, r1
 8003734:	3401      	adds	r4, #1
 8003736:	602b      	str	r3, [r5, #0]
 8003738:	60eb      	str	r3, [r5, #12]
 800373a:	60ab      	str	r3, [r5, #8]
 800373c:	7013      	strb	r3, [r2, #0]
 800373e:	65ab      	str	r3, [r5, #88]	; 0x58
 8003740:	7821      	ldrb	r1, [r4, #0]
 8003742:	2205      	movs	r2, #5
 8003744:	4862      	ldr	r0, [pc, #392]	; (80038d0 <_vfiprintf_r+0x21c>)
 8003746:	f000 fcdf 	bl	8004108 <memchr>
 800374a:	1c63      	adds	r3, r4, #1
 800374c:	469c      	mov	ip, r3
 800374e:	2800      	cmp	r0, #0
 8003750:	d135      	bne.n	80037be <_vfiprintf_r+0x10a>
 8003752:	6829      	ldr	r1, [r5, #0]
 8003754:	06cb      	lsls	r3, r1, #27
 8003756:	d504      	bpl.n	8003762 <_vfiprintf_r+0xae>
 8003758:	2353      	movs	r3, #83	; 0x53
 800375a:	aa02      	add	r2, sp, #8
 800375c:	3020      	adds	r0, #32
 800375e:	189b      	adds	r3, r3, r2
 8003760:	7018      	strb	r0, [r3, #0]
 8003762:	070b      	lsls	r3, r1, #28
 8003764:	d504      	bpl.n	8003770 <_vfiprintf_r+0xbc>
 8003766:	2353      	movs	r3, #83	; 0x53
 8003768:	202b      	movs	r0, #43	; 0x2b
 800376a:	aa02      	add	r2, sp, #8
 800376c:	189b      	adds	r3, r3, r2
 800376e:	7018      	strb	r0, [r3, #0]
 8003770:	7823      	ldrb	r3, [r4, #0]
 8003772:	2b2a      	cmp	r3, #42	; 0x2a
 8003774:	d02c      	beq.n	80037d0 <_vfiprintf_r+0x11c>
 8003776:	2000      	movs	r0, #0
 8003778:	210a      	movs	r1, #10
 800377a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800377c:	7822      	ldrb	r2, [r4, #0]
 800377e:	3a30      	subs	r2, #48	; 0x30
 8003780:	2a09      	cmp	r2, #9
 8003782:	d800      	bhi.n	8003786 <_vfiprintf_r+0xd2>
 8003784:	e06b      	b.n	800385e <_vfiprintf_r+0x1aa>
 8003786:	2800      	cmp	r0, #0
 8003788:	d02a      	beq.n	80037e0 <_vfiprintf_r+0x12c>
 800378a:	9309      	str	r3, [sp, #36]	; 0x24
 800378c:	e028      	b.n	80037e0 <_vfiprintf_r+0x12c>
 800378e:	4b51      	ldr	r3, [pc, #324]	; (80038d4 <_vfiprintf_r+0x220>)
 8003790:	429f      	cmp	r7, r3
 8003792:	d101      	bne.n	8003798 <_vfiprintf_r+0xe4>
 8003794:	68b7      	ldr	r7, [r6, #8]
 8003796:	e79e      	b.n	80036d6 <_vfiprintf_r+0x22>
 8003798:	4b4f      	ldr	r3, [pc, #316]	; (80038d8 <_vfiprintf_r+0x224>)
 800379a:	429f      	cmp	r7, r3
 800379c:	d19b      	bne.n	80036d6 <_vfiprintf_r+0x22>
 800379e:	68f7      	ldr	r7, [r6, #12]
 80037a0:	e799      	b.n	80036d6 <_vfiprintf_r+0x22>
 80037a2:	0039      	movs	r1, r7
 80037a4:	0030      	movs	r0, r6
 80037a6:	f000 faf1 	bl	8003d8c <__swsetup_r>
 80037aa:	2800      	cmp	r0, #0
 80037ac:	d099      	beq.n	80036e2 <_vfiprintf_r+0x2e>
 80037ae:	2001      	movs	r0, #1
 80037b0:	4240      	negs	r0, r0
 80037b2:	b01f      	add	sp, #124	; 0x7c
 80037b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80037b6:	2b25      	cmp	r3, #37	; 0x25
 80037b8:	d09f      	beq.n	80036fa <_vfiprintf_r+0x46>
 80037ba:	3401      	adds	r4, #1
 80037bc:	e79a      	b.n	80036f4 <_vfiprintf_r+0x40>
 80037be:	4b44      	ldr	r3, [pc, #272]	; (80038d0 <_vfiprintf_r+0x21c>)
 80037c0:	6829      	ldr	r1, [r5, #0]
 80037c2:	1ac0      	subs	r0, r0, r3
 80037c4:	2301      	movs	r3, #1
 80037c6:	4083      	lsls	r3, r0
 80037c8:	430b      	orrs	r3, r1
 80037ca:	602b      	str	r3, [r5, #0]
 80037cc:	4664      	mov	r4, ip
 80037ce:	e7b7      	b.n	8003740 <_vfiprintf_r+0x8c>
 80037d0:	9b05      	ldr	r3, [sp, #20]
 80037d2:	1d18      	adds	r0, r3, #4
 80037d4:	681b      	ldr	r3, [r3, #0]
 80037d6:	9005      	str	r0, [sp, #20]
 80037d8:	2b00      	cmp	r3, #0
 80037da:	db3a      	blt.n	8003852 <_vfiprintf_r+0x19e>
 80037dc:	9309      	str	r3, [sp, #36]	; 0x24
 80037de:	4664      	mov	r4, ip
 80037e0:	7823      	ldrb	r3, [r4, #0]
 80037e2:	2b2e      	cmp	r3, #46	; 0x2e
 80037e4:	d10b      	bne.n	80037fe <_vfiprintf_r+0x14a>
 80037e6:	7863      	ldrb	r3, [r4, #1]
 80037e8:	1c62      	adds	r2, r4, #1
 80037ea:	2b2a      	cmp	r3, #42	; 0x2a
 80037ec:	d13f      	bne.n	800386e <_vfiprintf_r+0x1ba>
 80037ee:	9b05      	ldr	r3, [sp, #20]
 80037f0:	3402      	adds	r4, #2
 80037f2:	1d1a      	adds	r2, r3, #4
 80037f4:	681b      	ldr	r3, [r3, #0]
 80037f6:	9205      	str	r2, [sp, #20]
 80037f8:	2b00      	cmp	r3, #0
 80037fa:	db35      	blt.n	8003868 <_vfiprintf_r+0x1b4>
 80037fc:	9307      	str	r3, [sp, #28]
 80037fe:	7821      	ldrb	r1, [r4, #0]
 8003800:	2203      	movs	r2, #3
 8003802:	4836      	ldr	r0, [pc, #216]	; (80038dc <_vfiprintf_r+0x228>)
 8003804:	f000 fc80 	bl	8004108 <memchr>
 8003808:	2800      	cmp	r0, #0
 800380a:	d007      	beq.n	800381c <_vfiprintf_r+0x168>
 800380c:	4b33      	ldr	r3, [pc, #204]	; (80038dc <_vfiprintf_r+0x228>)
 800380e:	682a      	ldr	r2, [r5, #0]
 8003810:	1ac0      	subs	r0, r0, r3
 8003812:	2340      	movs	r3, #64	; 0x40
 8003814:	4083      	lsls	r3, r0
 8003816:	4313      	orrs	r3, r2
 8003818:	602b      	str	r3, [r5, #0]
 800381a:	3401      	adds	r4, #1
 800381c:	7821      	ldrb	r1, [r4, #0]
 800381e:	1c63      	adds	r3, r4, #1
 8003820:	2206      	movs	r2, #6
 8003822:	482f      	ldr	r0, [pc, #188]	; (80038e0 <_vfiprintf_r+0x22c>)
 8003824:	9302      	str	r3, [sp, #8]
 8003826:	7629      	strb	r1, [r5, #24]
 8003828:	f000 fc6e 	bl	8004108 <memchr>
 800382c:	2800      	cmp	r0, #0
 800382e:	d044      	beq.n	80038ba <_vfiprintf_r+0x206>
 8003830:	4b2c      	ldr	r3, [pc, #176]	; (80038e4 <_vfiprintf_r+0x230>)
 8003832:	2b00      	cmp	r3, #0
 8003834:	d12f      	bne.n	8003896 <_vfiprintf_r+0x1e2>
 8003836:	6829      	ldr	r1, [r5, #0]
 8003838:	9b05      	ldr	r3, [sp, #20]
 800383a:	2207      	movs	r2, #7
 800383c:	05c9      	lsls	r1, r1, #23
 800383e:	d528      	bpl.n	8003892 <_vfiprintf_r+0x1de>
 8003840:	189b      	adds	r3, r3, r2
 8003842:	4393      	bics	r3, r2
 8003844:	3308      	adds	r3, #8
 8003846:	9305      	str	r3, [sp, #20]
 8003848:	696b      	ldr	r3, [r5, #20]
 800384a:	9a03      	ldr	r2, [sp, #12]
 800384c:	189b      	adds	r3, r3, r2
 800384e:	616b      	str	r3, [r5, #20]
 8003850:	e74f      	b.n	80036f2 <_vfiprintf_r+0x3e>
 8003852:	425b      	negs	r3, r3
 8003854:	60eb      	str	r3, [r5, #12]
 8003856:	2302      	movs	r3, #2
 8003858:	430b      	orrs	r3, r1
 800385a:	602b      	str	r3, [r5, #0]
 800385c:	e7bf      	b.n	80037de <_vfiprintf_r+0x12a>
 800385e:	434b      	muls	r3, r1
 8003860:	3401      	adds	r4, #1
 8003862:	189b      	adds	r3, r3, r2
 8003864:	2001      	movs	r0, #1
 8003866:	e789      	b.n	800377c <_vfiprintf_r+0xc8>
 8003868:	2301      	movs	r3, #1
 800386a:	425b      	negs	r3, r3
 800386c:	e7c6      	b.n	80037fc <_vfiprintf_r+0x148>
 800386e:	2300      	movs	r3, #0
 8003870:	0014      	movs	r4, r2
 8003872:	200a      	movs	r0, #10
 8003874:	001a      	movs	r2, r3
 8003876:	606b      	str	r3, [r5, #4]
 8003878:	7821      	ldrb	r1, [r4, #0]
 800387a:	3930      	subs	r1, #48	; 0x30
 800387c:	2909      	cmp	r1, #9
 800387e:	d903      	bls.n	8003888 <_vfiprintf_r+0x1d4>
 8003880:	2b00      	cmp	r3, #0
 8003882:	d0bc      	beq.n	80037fe <_vfiprintf_r+0x14a>
 8003884:	9207      	str	r2, [sp, #28]
 8003886:	e7ba      	b.n	80037fe <_vfiprintf_r+0x14a>
 8003888:	4342      	muls	r2, r0
 800388a:	3401      	adds	r4, #1
 800388c:	1852      	adds	r2, r2, r1
 800388e:	2301      	movs	r3, #1
 8003890:	e7f2      	b.n	8003878 <_vfiprintf_r+0x1c4>
 8003892:	3307      	adds	r3, #7
 8003894:	e7d5      	b.n	8003842 <_vfiprintf_r+0x18e>
 8003896:	ab05      	add	r3, sp, #20
 8003898:	9300      	str	r3, [sp, #0]
 800389a:	003a      	movs	r2, r7
 800389c:	4b12      	ldr	r3, [pc, #72]	; (80038e8 <_vfiprintf_r+0x234>)
 800389e:	0029      	movs	r1, r5
 80038a0:	0030      	movs	r0, r6
 80038a2:	e000      	b.n	80038a6 <_vfiprintf_r+0x1f2>
 80038a4:	bf00      	nop
 80038a6:	9003      	str	r0, [sp, #12]
 80038a8:	9b03      	ldr	r3, [sp, #12]
 80038aa:	3301      	adds	r3, #1
 80038ac:	d1cc      	bne.n	8003848 <_vfiprintf_r+0x194>
 80038ae:	89bb      	ldrh	r3, [r7, #12]
 80038b0:	065b      	lsls	r3, r3, #25
 80038b2:	d500      	bpl.n	80038b6 <_vfiprintf_r+0x202>
 80038b4:	e77b      	b.n	80037ae <_vfiprintf_r+0xfa>
 80038b6:	980b      	ldr	r0, [sp, #44]	; 0x2c
 80038b8:	e77b      	b.n	80037b2 <_vfiprintf_r+0xfe>
 80038ba:	ab05      	add	r3, sp, #20
 80038bc:	9300      	str	r3, [sp, #0]
 80038be:	003a      	movs	r2, r7
 80038c0:	4b09      	ldr	r3, [pc, #36]	; (80038e8 <_vfiprintf_r+0x234>)
 80038c2:	0029      	movs	r1, r5
 80038c4:	0030      	movs	r0, r6
 80038c6:	f000 f87f 	bl	80039c8 <_printf_i>
 80038ca:	e7ec      	b.n	80038a6 <_vfiprintf_r+0x1f2>
 80038cc:	0800430c 	.word	0x0800430c
 80038d0:	0800434c 	.word	0x0800434c
 80038d4:	0800432c 	.word	0x0800432c
 80038d8:	080042ec 	.word	0x080042ec
 80038dc:	08004352 	.word	0x08004352
 80038e0:	08004356 	.word	0x08004356
 80038e4:	00000000 	.word	0x00000000
 80038e8:	0800368f 	.word	0x0800368f

080038ec <_printf_common>:
 80038ec:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80038ee:	0015      	movs	r5, r2
 80038f0:	9301      	str	r3, [sp, #4]
 80038f2:	688a      	ldr	r2, [r1, #8]
 80038f4:	690b      	ldr	r3, [r1, #16]
 80038f6:	9000      	str	r0, [sp, #0]
 80038f8:	000c      	movs	r4, r1
 80038fa:	4293      	cmp	r3, r2
 80038fc:	da00      	bge.n	8003900 <_printf_common+0x14>
 80038fe:	0013      	movs	r3, r2
 8003900:	0022      	movs	r2, r4
 8003902:	602b      	str	r3, [r5, #0]
 8003904:	3243      	adds	r2, #67	; 0x43
 8003906:	7812      	ldrb	r2, [r2, #0]
 8003908:	2a00      	cmp	r2, #0
 800390a:	d001      	beq.n	8003910 <_printf_common+0x24>
 800390c:	3301      	adds	r3, #1
 800390e:	602b      	str	r3, [r5, #0]
 8003910:	6823      	ldr	r3, [r4, #0]
 8003912:	069b      	lsls	r3, r3, #26
 8003914:	d502      	bpl.n	800391c <_printf_common+0x30>
 8003916:	682b      	ldr	r3, [r5, #0]
 8003918:	3302      	adds	r3, #2
 800391a:	602b      	str	r3, [r5, #0]
 800391c:	2706      	movs	r7, #6
 800391e:	6823      	ldr	r3, [r4, #0]
 8003920:	401f      	ands	r7, r3
 8003922:	d027      	beq.n	8003974 <_printf_common+0x88>
 8003924:	0023      	movs	r3, r4
 8003926:	3343      	adds	r3, #67	; 0x43
 8003928:	781b      	ldrb	r3, [r3, #0]
 800392a:	1e5a      	subs	r2, r3, #1
 800392c:	4193      	sbcs	r3, r2
 800392e:	6822      	ldr	r2, [r4, #0]
 8003930:	0692      	lsls	r2, r2, #26
 8003932:	d430      	bmi.n	8003996 <_printf_common+0xaa>
 8003934:	0022      	movs	r2, r4
 8003936:	9901      	ldr	r1, [sp, #4]
 8003938:	3243      	adds	r2, #67	; 0x43
 800393a:	9800      	ldr	r0, [sp, #0]
 800393c:	9e08      	ldr	r6, [sp, #32]
 800393e:	47b0      	blx	r6
 8003940:	1c43      	adds	r3, r0, #1
 8003942:	d025      	beq.n	8003990 <_printf_common+0xa4>
 8003944:	2306      	movs	r3, #6
 8003946:	6820      	ldr	r0, [r4, #0]
 8003948:	682a      	ldr	r2, [r5, #0]
 800394a:	68e1      	ldr	r1, [r4, #12]
 800394c:	4003      	ands	r3, r0
 800394e:	2500      	movs	r5, #0
 8003950:	2b04      	cmp	r3, #4
 8003952:	d103      	bne.n	800395c <_printf_common+0x70>
 8003954:	1a8d      	subs	r5, r1, r2
 8003956:	43eb      	mvns	r3, r5
 8003958:	17db      	asrs	r3, r3, #31
 800395a:	401d      	ands	r5, r3
 800395c:	68a3      	ldr	r3, [r4, #8]
 800395e:	6922      	ldr	r2, [r4, #16]
 8003960:	4293      	cmp	r3, r2
 8003962:	dd01      	ble.n	8003968 <_printf_common+0x7c>
 8003964:	1a9b      	subs	r3, r3, r2
 8003966:	18ed      	adds	r5, r5, r3
 8003968:	2700      	movs	r7, #0
 800396a:	42bd      	cmp	r5, r7
 800396c:	d120      	bne.n	80039b0 <_printf_common+0xc4>
 800396e:	2000      	movs	r0, #0
 8003970:	e010      	b.n	8003994 <_printf_common+0xa8>
 8003972:	3701      	adds	r7, #1
 8003974:	68e3      	ldr	r3, [r4, #12]
 8003976:	682a      	ldr	r2, [r5, #0]
 8003978:	1a9b      	subs	r3, r3, r2
 800397a:	429f      	cmp	r7, r3
 800397c:	dad2      	bge.n	8003924 <_printf_common+0x38>
 800397e:	0022      	movs	r2, r4
 8003980:	2301      	movs	r3, #1
 8003982:	3219      	adds	r2, #25
 8003984:	9901      	ldr	r1, [sp, #4]
 8003986:	9800      	ldr	r0, [sp, #0]
 8003988:	9e08      	ldr	r6, [sp, #32]
 800398a:	47b0      	blx	r6
 800398c:	1c43      	adds	r3, r0, #1
 800398e:	d1f0      	bne.n	8003972 <_printf_common+0x86>
 8003990:	2001      	movs	r0, #1
 8003992:	4240      	negs	r0, r0
 8003994:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8003996:	2030      	movs	r0, #48	; 0x30
 8003998:	18e1      	adds	r1, r4, r3
 800399a:	3143      	adds	r1, #67	; 0x43
 800399c:	7008      	strb	r0, [r1, #0]
 800399e:	0021      	movs	r1, r4
 80039a0:	1c5a      	adds	r2, r3, #1
 80039a2:	3145      	adds	r1, #69	; 0x45
 80039a4:	7809      	ldrb	r1, [r1, #0]
 80039a6:	18a2      	adds	r2, r4, r2
 80039a8:	3243      	adds	r2, #67	; 0x43
 80039aa:	3302      	adds	r3, #2
 80039ac:	7011      	strb	r1, [r2, #0]
 80039ae:	e7c1      	b.n	8003934 <_printf_common+0x48>
 80039b0:	0022      	movs	r2, r4
 80039b2:	2301      	movs	r3, #1
 80039b4:	321a      	adds	r2, #26
 80039b6:	9901      	ldr	r1, [sp, #4]
 80039b8:	9800      	ldr	r0, [sp, #0]
 80039ba:	9e08      	ldr	r6, [sp, #32]
 80039bc:	47b0      	blx	r6
 80039be:	1c43      	adds	r3, r0, #1
 80039c0:	d0e6      	beq.n	8003990 <_printf_common+0xa4>
 80039c2:	3701      	adds	r7, #1
 80039c4:	e7d1      	b.n	800396a <_printf_common+0x7e>
	...

080039c8 <_printf_i>:
 80039c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80039ca:	b08b      	sub	sp, #44	; 0x2c
 80039cc:	9206      	str	r2, [sp, #24]
 80039ce:	000a      	movs	r2, r1
 80039d0:	3243      	adds	r2, #67	; 0x43
 80039d2:	9307      	str	r3, [sp, #28]
 80039d4:	9005      	str	r0, [sp, #20]
 80039d6:	9204      	str	r2, [sp, #16]
 80039d8:	7e0a      	ldrb	r2, [r1, #24]
 80039da:	000c      	movs	r4, r1
 80039dc:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80039de:	2a6e      	cmp	r2, #110	; 0x6e
 80039e0:	d100      	bne.n	80039e4 <_printf_i+0x1c>
 80039e2:	e08f      	b.n	8003b04 <_printf_i+0x13c>
 80039e4:	d817      	bhi.n	8003a16 <_printf_i+0x4e>
 80039e6:	2a63      	cmp	r2, #99	; 0x63
 80039e8:	d02c      	beq.n	8003a44 <_printf_i+0x7c>
 80039ea:	d808      	bhi.n	80039fe <_printf_i+0x36>
 80039ec:	2a00      	cmp	r2, #0
 80039ee:	d100      	bne.n	80039f2 <_printf_i+0x2a>
 80039f0:	e099      	b.n	8003b26 <_printf_i+0x15e>
 80039f2:	2a58      	cmp	r2, #88	; 0x58
 80039f4:	d054      	beq.n	8003aa0 <_printf_i+0xd8>
 80039f6:	0026      	movs	r6, r4
 80039f8:	3642      	adds	r6, #66	; 0x42
 80039fa:	7032      	strb	r2, [r6, #0]
 80039fc:	e029      	b.n	8003a52 <_printf_i+0x8a>
 80039fe:	2a64      	cmp	r2, #100	; 0x64
 8003a00:	d001      	beq.n	8003a06 <_printf_i+0x3e>
 8003a02:	2a69      	cmp	r2, #105	; 0x69
 8003a04:	d1f7      	bne.n	80039f6 <_printf_i+0x2e>
 8003a06:	6821      	ldr	r1, [r4, #0]
 8003a08:	681a      	ldr	r2, [r3, #0]
 8003a0a:	0608      	lsls	r0, r1, #24
 8003a0c:	d523      	bpl.n	8003a56 <_printf_i+0x8e>
 8003a0e:	1d11      	adds	r1, r2, #4
 8003a10:	6019      	str	r1, [r3, #0]
 8003a12:	6815      	ldr	r5, [r2, #0]
 8003a14:	e025      	b.n	8003a62 <_printf_i+0x9a>
 8003a16:	2a73      	cmp	r2, #115	; 0x73
 8003a18:	d100      	bne.n	8003a1c <_printf_i+0x54>
 8003a1a:	e088      	b.n	8003b2e <_printf_i+0x166>
 8003a1c:	d808      	bhi.n	8003a30 <_printf_i+0x68>
 8003a1e:	2a6f      	cmp	r2, #111	; 0x6f
 8003a20:	d029      	beq.n	8003a76 <_printf_i+0xae>
 8003a22:	2a70      	cmp	r2, #112	; 0x70
 8003a24:	d1e7      	bne.n	80039f6 <_printf_i+0x2e>
 8003a26:	2220      	movs	r2, #32
 8003a28:	6809      	ldr	r1, [r1, #0]
 8003a2a:	430a      	orrs	r2, r1
 8003a2c:	6022      	str	r2, [r4, #0]
 8003a2e:	e003      	b.n	8003a38 <_printf_i+0x70>
 8003a30:	2a75      	cmp	r2, #117	; 0x75
 8003a32:	d020      	beq.n	8003a76 <_printf_i+0xae>
 8003a34:	2a78      	cmp	r2, #120	; 0x78
 8003a36:	d1de      	bne.n	80039f6 <_printf_i+0x2e>
 8003a38:	0022      	movs	r2, r4
 8003a3a:	2178      	movs	r1, #120	; 0x78
 8003a3c:	3245      	adds	r2, #69	; 0x45
 8003a3e:	7011      	strb	r1, [r2, #0]
 8003a40:	4a6c      	ldr	r2, [pc, #432]	; (8003bf4 <_printf_i+0x22c>)
 8003a42:	e030      	b.n	8003aa6 <_printf_i+0xde>
 8003a44:	000e      	movs	r6, r1
 8003a46:	681a      	ldr	r2, [r3, #0]
 8003a48:	3642      	adds	r6, #66	; 0x42
 8003a4a:	1d11      	adds	r1, r2, #4
 8003a4c:	6019      	str	r1, [r3, #0]
 8003a4e:	6813      	ldr	r3, [r2, #0]
 8003a50:	7033      	strb	r3, [r6, #0]
 8003a52:	2301      	movs	r3, #1
 8003a54:	e079      	b.n	8003b4a <_printf_i+0x182>
 8003a56:	0649      	lsls	r1, r1, #25
 8003a58:	d5d9      	bpl.n	8003a0e <_printf_i+0x46>
 8003a5a:	1d11      	adds	r1, r2, #4
 8003a5c:	6019      	str	r1, [r3, #0]
 8003a5e:	2300      	movs	r3, #0
 8003a60:	5ed5      	ldrsh	r5, [r2, r3]
 8003a62:	2d00      	cmp	r5, #0
 8003a64:	da03      	bge.n	8003a6e <_printf_i+0xa6>
 8003a66:	232d      	movs	r3, #45	; 0x2d
 8003a68:	9a04      	ldr	r2, [sp, #16]
 8003a6a:	426d      	negs	r5, r5
 8003a6c:	7013      	strb	r3, [r2, #0]
 8003a6e:	4b62      	ldr	r3, [pc, #392]	; (8003bf8 <_printf_i+0x230>)
 8003a70:	270a      	movs	r7, #10
 8003a72:	9303      	str	r3, [sp, #12]
 8003a74:	e02f      	b.n	8003ad6 <_printf_i+0x10e>
 8003a76:	6820      	ldr	r0, [r4, #0]
 8003a78:	6819      	ldr	r1, [r3, #0]
 8003a7a:	0605      	lsls	r5, r0, #24
 8003a7c:	d503      	bpl.n	8003a86 <_printf_i+0xbe>
 8003a7e:	1d08      	adds	r0, r1, #4
 8003a80:	6018      	str	r0, [r3, #0]
 8003a82:	680d      	ldr	r5, [r1, #0]
 8003a84:	e005      	b.n	8003a92 <_printf_i+0xca>
 8003a86:	0640      	lsls	r0, r0, #25
 8003a88:	d5f9      	bpl.n	8003a7e <_printf_i+0xb6>
 8003a8a:	680d      	ldr	r5, [r1, #0]
 8003a8c:	1d08      	adds	r0, r1, #4
 8003a8e:	6018      	str	r0, [r3, #0]
 8003a90:	b2ad      	uxth	r5, r5
 8003a92:	4b59      	ldr	r3, [pc, #356]	; (8003bf8 <_printf_i+0x230>)
 8003a94:	2708      	movs	r7, #8
 8003a96:	9303      	str	r3, [sp, #12]
 8003a98:	2a6f      	cmp	r2, #111	; 0x6f
 8003a9a:	d018      	beq.n	8003ace <_printf_i+0x106>
 8003a9c:	270a      	movs	r7, #10
 8003a9e:	e016      	b.n	8003ace <_printf_i+0x106>
 8003aa0:	3145      	adds	r1, #69	; 0x45
 8003aa2:	700a      	strb	r2, [r1, #0]
 8003aa4:	4a54      	ldr	r2, [pc, #336]	; (8003bf8 <_printf_i+0x230>)
 8003aa6:	9203      	str	r2, [sp, #12]
 8003aa8:	681a      	ldr	r2, [r3, #0]
 8003aaa:	6821      	ldr	r1, [r4, #0]
 8003aac:	1d10      	adds	r0, r2, #4
 8003aae:	6018      	str	r0, [r3, #0]
 8003ab0:	6815      	ldr	r5, [r2, #0]
 8003ab2:	0608      	lsls	r0, r1, #24
 8003ab4:	d522      	bpl.n	8003afc <_printf_i+0x134>
 8003ab6:	07cb      	lsls	r3, r1, #31
 8003ab8:	d502      	bpl.n	8003ac0 <_printf_i+0xf8>
 8003aba:	2320      	movs	r3, #32
 8003abc:	4319      	orrs	r1, r3
 8003abe:	6021      	str	r1, [r4, #0]
 8003ac0:	2710      	movs	r7, #16
 8003ac2:	2d00      	cmp	r5, #0
 8003ac4:	d103      	bne.n	8003ace <_printf_i+0x106>
 8003ac6:	2320      	movs	r3, #32
 8003ac8:	6822      	ldr	r2, [r4, #0]
 8003aca:	439a      	bics	r2, r3
 8003acc:	6022      	str	r2, [r4, #0]
 8003ace:	0023      	movs	r3, r4
 8003ad0:	2200      	movs	r2, #0
 8003ad2:	3343      	adds	r3, #67	; 0x43
 8003ad4:	701a      	strb	r2, [r3, #0]
 8003ad6:	6863      	ldr	r3, [r4, #4]
 8003ad8:	60a3      	str	r3, [r4, #8]
 8003ada:	2b00      	cmp	r3, #0
 8003adc:	db5c      	blt.n	8003b98 <_printf_i+0x1d0>
 8003ade:	2204      	movs	r2, #4
 8003ae0:	6821      	ldr	r1, [r4, #0]
 8003ae2:	4391      	bics	r1, r2
 8003ae4:	6021      	str	r1, [r4, #0]
 8003ae6:	2d00      	cmp	r5, #0
 8003ae8:	d158      	bne.n	8003b9c <_printf_i+0x1d4>
 8003aea:	9e04      	ldr	r6, [sp, #16]
 8003aec:	2b00      	cmp	r3, #0
 8003aee:	d064      	beq.n	8003bba <_printf_i+0x1f2>
 8003af0:	0026      	movs	r6, r4
 8003af2:	9b03      	ldr	r3, [sp, #12]
 8003af4:	3642      	adds	r6, #66	; 0x42
 8003af6:	781b      	ldrb	r3, [r3, #0]
 8003af8:	7033      	strb	r3, [r6, #0]
 8003afa:	e05e      	b.n	8003bba <_printf_i+0x1f2>
 8003afc:	0648      	lsls	r0, r1, #25
 8003afe:	d5da      	bpl.n	8003ab6 <_printf_i+0xee>
 8003b00:	b2ad      	uxth	r5, r5
 8003b02:	e7d8      	b.n	8003ab6 <_printf_i+0xee>
 8003b04:	6809      	ldr	r1, [r1, #0]
 8003b06:	681a      	ldr	r2, [r3, #0]
 8003b08:	0608      	lsls	r0, r1, #24
 8003b0a:	d505      	bpl.n	8003b18 <_printf_i+0x150>
 8003b0c:	1d11      	adds	r1, r2, #4
 8003b0e:	6019      	str	r1, [r3, #0]
 8003b10:	6813      	ldr	r3, [r2, #0]
 8003b12:	6962      	ldr	r2, [r4, #20]
 8003b14:	601a      	str	r2, [r3, #0]
 8003b16:	e006      	b.n	8003b26 <_printf_i+0x15e>
 8003b18:	0649      	lsls	r1, r1, #25
 8003b1a:	d5f7      	bpl.n	8003b0c <_printf_i+0x144>
 8003b1c:	1d11      	adds	r1, r2, #4
 8003b1e:	6019      	str	r1, [r3, #0]
 8003b20:	6813      	ldr	r3, [r2, #0]
 8003b22:	8aa2      	ldrh	r2, [r4, #20]
 8003b24:	801a      	strh	r2, [r3, #0]
 8003b26:	2300      	movs	r3, #0
 8003b28:	9e04      	ldr	r6, [sp, #16]
 8003b2a:	6123      	str	r3, [r4, #16]
 8003b2c:	e054      	b.n	8003bd8 <_printf_i+0x210>
 8003b2e:	681a      	ldr	r2, [r3, #0]
 8003b30:	1d11      	adds	r1, r2, #4
 8003b32:	6019      	str	r1, [r3, #0]
 8003b34:	6816      	ldr	r6, [r2, #0]
 8003b36:	2100      	movs	r1, #0
 8003b38:	6862      	ldr	r2, [r4, #4]
 8003b3a:	0030      	movs	r0, r6
 8003b3c:	f000 fae4 	bl	8004108 <memchr>
 8003b40:	2800      	cmp	r0, #0
 8003b42:	d001      	beq.n	8003b48 <_printf_i+0x180>
 8003b44:	1b80      	subs	r0, r0, r6
 8003b46:	6060      	str	r0, [r4, #4]
 8003b48:	6863      	ldr	r3, [r4, #4]
 8003b4a:	6123      	str	r3, [r4, #16]
 8003b4c:	2300      	movs	r3, #0
 8003b4e:	9a04      	ldr	r2, [sp, #16]
 8003b50:	7013      	strb	r3, [r2, #0]
 8003b52:	e041      	b.n	8003bd8 <_printf_i+0x210>
 8003b54:	6923      	ldr	r3, [r4, #16]
 8003b56:	0032      	movs	r2, r6
 8003b58:	9906      	ldr	r1, [sp, #24]
 8003b5a:	9805      	ldr	r0, [sp, #20]
 8003b5c:	9d07      	ldr	r5, [sp, #28]
 8003b5e:	47a8      	blx	r5
 8003b60:	1c43      	adds	r3, r0, #1
 8003b62:	d043      	beq.n	8003bec <_printf_i+0x224>
 8003b64:	6823      	ldr	r3, [r4, #0]
 8003b66:	2500      	movs	r5, #0
 8003b68:	079b      	lsls	r3, r3, #30
 8003b6a:	d40f      	bmi.n	8003b8c <_printf_i+0x1c4>
 8003b6c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003b6e:	68e0      	ldr	r0, [r4, #12]
 8003b70:	4298      	cmp	r0, r3
 8003b72:	da3d      	bge.n	8003bf0 <_printf_i+0x228>
 8003b74:	0018      	movs	r0, r3
 8003b76:	e03b      	b.n	8003bf0 <_printf_i+0x228>
 8003b78:	0022      	movs	r2, r4
 8003b7a:	2301      	movs	r3, #1
 8003b7c:	3219      	adds	r2, #25
 8003b7e:	9906      	ldr	r1, [sp, #24]
 8003b80:	9805      	ldr	r0, [sp, #20]
 8003b82:	9e07      	ldr	r6, [sp, #28]
 8003b84:	47b0      	blx	r6
 8003b86:	1c43      	adds	r3, r0, #1
 8003b88:	d030      	beq.n	8003bec <_printf_i+0x224>
 8003b8a:	3501      	adds	r5, #1
 8003b8c:	68e3      	ldr	r3, [r4, #12]
 8003b8e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8003b90:	1a9b      	subs	r3, r3, r2
 8003b92:	429d      	cmp	r5, r3
 8003b94:	dbf0      	blt.n	8003b78 <_printf_i+0x1b0>
 8003b96:	e7e9      	b.n	8003b6c <_printf_i+0x1a4>
 8003b98:	2d00      	cmp	r5, #0
 8003b9a:	d0a9      	beq.n	8003af0 <_printf_i+0x128>
 8003b9c:	9e04      	ldr	r6, [sp, #16]
 8003b9e:	0028      	movs	r0, r5
 8003ba0:	0039      	movs	r1, r7
 8003ba2:	f7fc fb37 	bl	8000214 <__aeabi_uidivmod>
 8003ba6:	9b03      	ldr	r3, [sp, #12]
 8003ba8:	3e01      	subs	r6, #1
 8003baa:	5c5b      	ldrb	r3, [r3, r1]
 8003bac:	0028      	movs	r0, r5
 8003bae:	7033      	strb	r3, [r6, #0]
 8003bb0:	0039      	movs	r1, r7
 8003bb2:	f7fc faa9 	bl	8000108 <__udivsi3>
 8003bb6:	1e05      	subs	r5, r0, #0
 8003bb8:	d1f1      	bne.n	8003b9e <_printf_i+0x1d6>
 8003bba:	2f08      	cmp	r7, #8
 8003bbc:	d109      	bne.n	8003bd2 <_printf_i+0x20a>
 8003bbe:	6823      	ldr	r3, [r4, #0]
 8003bc0:	07db      	lsls	r3, r3, #31
 8003bc2:	d506      	bpl.n	8003bd2 <_printf_i+0x20a>
 8003bc4:	6863      	ldr	r3, [r4, #4]
 8003bc6:	6922      	ldr	r2, [r4, #16]
 8003bc8:	4293      	cmp	r3, r2
 8003bca:	dc02      	bgt.n	8003bd2 <_printf_i+0x20a>
 8003bcc:	2330      	movs	r3, #48	; 0x30
 8003bce:	3e01      	subs	r6, #1
 8003bd0:	7033      	strb	r3, [r6, #0]
 8003bd2:	9b04      	ldr	r3, [sp, #16]
 8003bd4:	1b9b      	subs	r3, r3, r6
 8003bd6:	6123      	str	r3, [r4, #16]
 8003bd8:	9b07      	ldr	r3, [sp, #28]
 8003bda:	aa09      	add	r2, sp, #36	; 0x24
 8003bdc:	9300      	str	r3, [sp, #0]
 8003bde:	0021      	movs	r1, r4
 8003be0:	9b06      	ldr	r3, [sp, #24]
 8003be2:	9805      	ldr	r0, [sp, #20]
 8003be4:	f7ff fe82 	bl	80038ec <_printf_common>
 8003be8:	1c43      	adds	r3, r0, #1
 8003bea:	d1b3      	bne.n	8003b54 <_printf_i+0x18c>
 8003bec:	2001      	movs	r0, #1
 8003bee:	4240      	negs	r0, r0
 8003bf0:	b00b      	add	sp, #44	; 0x2c
 8003bf2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003bf4:	0800436e 	.word	0x0800436e
 8003bf8:	0800435d 	.word	0x0800435d

08003bfc <_sbrk_r>:
 8003bfc:	2300      	movs	r3, #0
 8003bfe:	b570      	push	{r4, r5, r6, lr}
 8003c00:	4c06      	ldr	r4, [pc, #24]	; (8003c1c <_sbrk_r+0x20>)
 8003c02:	0005      	movs	r5, r0
 8003c04:	0008      	movs	r0, r1
 8003c06:	6023      	str	r3, [r4, #0]
 8003c08:	f7ff fb0a 	bl	8003220 <_sbrk>
 8003c0c:	1c43      	adds	r3, r0, #1
 8003c0e:	d103      	bne.n	8003c18 <_sbrk_r+0x1c>
 8003c10:	6823      	ldr	r3, [r4, #0]
 8003c12:	2b00      	cmp	r3, #0
 8003c14:	d000      	beq.n	8003c18 <_sbrk_r+0x1c>
 8003c16:	602b      	str	r3, [r5, #0]
 8003c18:	bd70      	pop	{r4, r5, r6, pc}
 8003c1a:	46c0      	nop			; (mov r8, r8)
 8003c1c:	2000181c 	.word	0x2000181c

08003c20 <__sread>:
 8003c20:	b570      	push	{r4, r5, r6, lr}
 8003c22:	000c      	movs	r4, r1
 8003c24:	250e      	movs	r5, #14
 8003c26:	5f49      	ldrsh	r1, [r1, r5]
 8003c28:	f000 fac6 	bl	80041b8 <_read_r>
 8003c2c:	2800      	cmp	r0, #0
 8003c2e:	db03      	blt.n	8003c38 <__sread+0x18>
 8003c30:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8003c32:	181b      	adds	r3, r3, r0
 8003c34:	6563      	str	r3, [r4, #84]	; 0x54
 8003c36:	bd70      	pop	{r4, r5, r6, pc}
 8003c38:	89a3      	ldrh	r3, [r4, #12]
 8003c3a:	4a02      	ldr	r2, [pc, #8]	; (8003c44 <__sread+0x24>)
 8003c3c:	4013      	ands	r3, r2
 8003c3e:	81a3      	strh	r3, [r4, #12]
 8003c40:	e7f9      	b.n	8003c36 <__sread+0x16>
 8003c42:	46c0      	nop			; (mov r8, r8)
 8003c44:	ffffefff 	.word	0xffffefff

08003c48 <__swrite>:
 8003c48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003c4a:	001f      	movs	r7, r3
 8003c4c:	898b      	ldrh	r3, [r1, #12]
 8003c4e:	0005      	movs	r5, r0
 8003c50:	000c      	movs	r4, r1
 8003c52:	0016      	movs	r6, r2
 8003c54:	05db      	lsls	r3, r3, #23
 8003c56:	d505      	bpl.n	8003c64 <__swrite+0x1c>
 8003c58:	230e      	movs	r3, #14
 8003c5a:	5ec9      	ldrsh	r1, [r1, r3]
 8003c5c:	2200      	movs	r2, #0
 8003c5e:	2302      	movs	r3, #2
 8003c60:	f000 f9d2 	bl	8004008 <_lseek_r>
 8003c64:	89a3      	ldrh	r3, [r4, #12]
 8003c66:	4a05      	ldr	r2, [pc, #20]	; (8003c7c <__swrite+0x34>)
 8003c68:	0028      	movs	r0, r5
 8003c6a:	4013      	ands	r3, r2
 8003c6c:	81a3      	strh	r3, [r4, #12]
 8003c6e:	0032      	movs	r2, r6
 8003c70:	230e      	movs	r3, #14
 8003c72:	5ee1      	ldrsh	r1, [r4, r3]
 8003c74:	003b      	movs	r3, r7
 8003c76:	f000 f875 	bl	8003d64 <_write_r>
 8003c7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003c7c:	ffffefff 	.word	0xffffefff

08003c80 <__sseek>:
 8003c80:	b570      	push	{r4, r5, r6, lr}
 8003c82:	000c      	movs	r4, r1
 8003c84:	250e      	movs	r5, #14
 8003c86:	5f49      	ldrsh	r1, [r1, r5]
 8003c88:	f000 f9be 	bl	8004008 <_lseek_r>
 8003c8c:	89a3      	ldrh	r3, [r4, #12]
 8003c8e:	1c42      	adds	r2, r0, #1
 8003c90:	d103      	bne.n	8003c9a <__sseek+0x1a>
 8003c92:	4a05      	ldr	r2, [pc, #20]	; (8003ca8 <__sseek+0x28>)
 8003c94:	4013      	ands	r3, r2
 8003c96:	81a3      	strh	r3, [r4, #12]
 8003c98:	bd70      	pop	{r4, r5, r6, pc}
 8003c9a:	2280      	movs	r2, #128	; 0x80
 8003c9c:	0152      	lsls	r2, r2, #5
 8003c9e:	4313      	orrs	r3, r2
 8003ca0:	81a3      	strh	r3, [r4, #12]
 8003ca2:	6560      	str	r0, [r4, #84]	; 0x54
 8003ca4:	e7f8      	b.n	8003c98 <__sseek+0x18>
 8003ca6:	46c0      	nop			; (mov r8, r8)
 8003ca8:	ffffefff 	.word	0xffffefff

08003cac <__sclose>:
 8003cac:	b510      	push	{r4, lr}
 8003cae:	230e      	movs	r3, #14
 8003cb0:	5ec9      	ldrsh	r1, [r1, r3]
 8003cb2:	f000 f8e1 	bl	8003e78 <_close_r>
 8003cb6:	bd10      	pop	{r4, pc}

08003cb8 <__swbuf_r>:
 8003cb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003cba:	0005      	movs	r5, r0
 8003cbc:	000e      	movs	r6, r1
 8003cbe:	0014      	movs	r4, r2
 8003cc0:	2800      	cmp	r0, #0
 8003cc2:	d004      	beq.n	8003cce <__swbuf_r+0x16>
 8003cc4:	6983      	ldr	r3, [r0, #24]
 8003cc6:	2b00      	cmp	r3, #0
 8003cc8:	d101      	bne.n	8003cce <__swbuf_r+0x16>
 8003cca:	f7ff fbd7 	bl	800347c <__sinit>
 8003cce:	4b22      	ldr	r3, [pc, #136]	; (8003d58 <__swbuf_r+0xa0>)
 8003cd0:	429c      	cmp	r4, r3
 8003cd2:	d12d      	bne.n	8003d30 <__swbuf_r+0x78>
 8003cd4:	686c      	ldr	r4, [r5, #4]
 8003cd6:	69a3      	ldr	r3, [r4, #24]
 8003cd8:	60a3      	str	r3, [r4, #8]
 8003cda:	89a3      	ldrh	r3, [r4, #12]
 8003cdc:	071b      	lsls	r3, r3, #28
 8003cde:	d531      	bpl.n	8003d44 <__swbuf_r+0x8c>
 8003ce0:	6923      	ldr	r3, [r4, #16]
 8003ce2:	2b00      	cmp	r3, #0
 8003ce4:	d02e      	beq.n	8003d44 <__swbuf_r+0x8c>
 8003ce6:	6823      	ldr	r3, [r4, #0]
 8003ce8:	6922      	ldr	r2, [r4, #16]
 8003cea:	b2f7      	uxtb	r7, r6
 8003cec:	1a98      	subs	r0, r3, r2
 8003cee:	6963      	ldr	r3, [r4, #20]
 8003cf0:	b2f6      	uxtb	r6, r6
 8003cf2:	4298      	cmp	r0, r3
 8003cf4:	db05      	blt.n	8003d02 <__swbuf_r+0x4a>
 8003cf6:	0021      	movs	r1, r4
 8003cf8:	0028      	movs	r0, r5
 8003cfa:	f000 f959 	bl	8003fb0 <_fflush_r>
 8003cfe:	2800      	cmp	r0, #0
 8003d00:	d126      	bne.n	8003d50 <__swbuf_r+0x98>
 8003d02:	68a3      	ldr	r3, [r4, #8]
 8003d04:	3001      	adds	r0, #1
 8003d06:	3b01      	subs	r3, #1
 8003d08:	60a3      	str	r3, [r4, #8]
 8003d0a:	6823      	ldr	r3, [r4, #0]
 8003d0c:	1c5a      	adds	r2, r3, #1
 8003d0e:	6022      	str	r2, [r4, #0]
 8003d10:	701f      	strb	r7, [r3, #0]
 8003d12:	6963      	ldr	r3, [r4, #20]
 8003d14:	4298      	cmp	r0, r3
 8003d16:	d004      	beq.n	8003d22 <__swbuf_r+0x6a>
 8003d18:	89a3      	ldrh	r3, [r4, #12]
 8003d1a:	07db      	lsls	r3, r3, #31
 8003d1c:	d51a      	bpl.n	8003d54 <__swbuf_r+0x9c>
 8003d1e:	2e0a      	cmp	r6, #10
 8003d20:	d118      	bne.n	8003d54 <__swbuf_r+0x9c>
 8003d22:	0021      	movs	r1, r4
 8003d24:	0028      	movs	r0, r5
 8003d26:	f000 f943 	bl	8003fb0 <_fflush_r>
 8003d2a:	2800      	cmp	r0, #0
 8003d2c:	d012      	beq.n	8003d54 <__swbuf_r+0x9c>
 8003d2e:	e00f      	b.n	8003d50 <__swbuf_r+0x98>
 8003d30:	4b0a      	ldr	r3, [pc, #40]	; (8003d5c <__swbuf_r+0xa4>)
 8003d32:	429c      	cmp	r4, r3
 8003d34:	d101      	bne.n	8003d3a <__swbuf_r+0x82>
 8003d36:	68ac      	ldr	r4, [r5, #8]
 8003d38:	e7cd      	b.n	8003cd6 <__swbuf_r+0x1e>
 8003d3a:	4b09      	ldr	r3, [pc, #36]	; (8003d60 <__swbuf_r+0xa8>)
 8003d3c:	429c      	cmp	r4, r3
 8003d3e:	d1ca      	bne.n	8003cd6 <__swbuf_r+0x1e>
 8003d40:	68ec      	ldr	r4, [r5, #12]
 8003d42:	e7c8      	b.n	8003cd6 <__swbuf_r+0x1e>
 8003d44:	0021      	movs	r1, r4
 8003d46:	0028      	movs	r0, r5
 8003d48:	f000 f820 	bl	8003d8c <__swsetup_r>
 8003d4c:	2800      	cmp	r0, #0
 8003d4e:	d0ca      	beq.n	8003ce6 <__swbuf_r+0x2e>
 8003d50:	2601      	movs	r6, #1
 8003d52:	4276      	negs	r6, r6
 8003d54:	0030      	movs	r0, r6
 8003d56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003d58:	0800430c 	.word	0x0800430c
 8003d5c:	0800432c 	.word	0x0800432c
 8003d60:	080042ec 	.word	0x080042ec

08003d64 <_write_r>:
 8003d64:	b570      	push	{r4, r5, r6, lr}
 8003d66:	0005      	movs	r5, r0
 8003d68:	0008      	movs	r0, r1
 8003d6a:	0011      	movs	r1, r2
 8003d6c:	2200      	movs	r2, #0
 8003d6e:	4c06      	ldr	r4, [pc, #24]	; (8003d88 <_write_r+0x24>)
 8003d70:	6022      	str	r2, [r4, #0]
 8003d72:	001a      	movs	r2, r3
 8003d74:	f7ff fa46 	bl	8003204 <_write>
 8003d78:	1c43      	adds	r3, r0, #1
 8003d7a:	d103      	bne.n	8003d84 <_write_r+0x20>
 8003d7c:	6823      	ldr	r3, [r4, #0]
 8003d7e:	2b00      	cmp	r3, #0
 8003d80:	d000      	beq.n	8003d84 <_write_r+0x20>
 8003d82:	602b      	str	r3, [r5, #0]
 8003d84:	bd70      	pop	{r4, r5, r6, pc}
 8003d86:	46c0      	nop			; (mov r8, r8)
 8003d88:	2000181c 	.word	0x2000181c

08003d8c <__swsetup_r>:
 8003d8c:	4b36      	ldr	r3, [pc, #216]	; (8003e68 <__swsetup_r+0xdc>)
 8003d8e:	b570      	push	{r4, r5, r6, lr}
 8003d90:	681d      	ldr	r5, [r3, #0]
 8003d92:	0006      	movs	r6, r0
 8003d94:	000c      	movs	r4, r1
 8003d96:	2d00      	cmp	r5, #0
 8003d98:	d005      	beq.n	8003da6 <__swsetup_r+0x1a>
 8003d9a:	69ab      	ldr	r3, [r5, #24]
 8003d9c:	2b00      	cmp	r3, #0
 8003d9e:	d102      	bne.n	8003da6 <__swsetup_r+0x1a>
 8003da0:	0028      	movs	r0, r5
 8003da2:	f7ff fb6b 	bl	800347c <__sinit>
 8003da6:	4b31      	ldr	r3, [pc, #196]	; (8003e6c <__swsetup_r+0xe0>)
 8003da8:	429c      	cmp	r4, r3
 8003daa:	d10f      	bne.n	8003dcc <__swsetup_r+0x40>
 8003dac:	686c      	ldr	r4, [r5, #4]
 8003dae:	230c      	movs	r3, #12
 8003db0:	5ee2      	ldrsh	r2, [r4, r3]
 8003db2:	b293      	uxth	r3, r2
 8003db4:	0719      	lsls	r1, r3, #28
 8003db6:	d42d      	bmi.n	8003e14 <__swsetup_r+0x88>
 8003db8:	06d9      	lsls	r1, r3, #27
 8003dba:	d411      	bmi.n	8003de0 <__swsetup_r+0x54>
 8003dbc:	2309      	movs	r3, #9
 8003dbe:	2001      	movs	r0, #1
 8003dc0:	6033      	str	r3, [r6, #0]
 8003dc2:	3337      	adds	r3, #55	; 0x37
 8003dc4:	4313      	orrs	r3, r2
 8003dc6:	81a3      	strh	r3, [r4, #12]
 8003dc8:	4240      	negs	r0, r0
 8003dca:	bd70      	pop	{r4, r5, r6, pc}
 8003dcc:	4b28      	ldr	r3, [pc, #160]	; (8003e70 <__swsetup_r+0xe4>)
 8003dce:	429c      	cmp	r4, r3
 8003dd0:	d101      	bne.n	8003dd6 <__swsetup_r+0x4a>
 8003dd2:	68ac      	ldr	r4, [r5, #8]
 8003dd4:	e7eb      	b.n	8003dae <__swsetup_r+0x22>
 8003dd6:	4b27      	ldr	r3, [pc, #156]	; (8003e74 <__swsetup_r+0xe8>)
 8003dd8:	429c      	cmp	r4, r3
 8003dda:	d1e8      	bne.n	8003dae <__swsetup_r+0x22>
 8003ddc:	68ec      	ldr	r4, [r5, #12]
 8003dde:	e7e6      	b.n	8003dae <__swsetup_r+0x22>
 8003de0:	075b      	lsls	r3, r3, #29
 8003de2:	d513      	bpl.n	8003e0c <__swsetup_r+0x80>
 8003de4:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8003de6:	2900      	cmp	r1, #0
 8003de8:	d008      	beq.n	8003dfc <__swsetup_r+0x70>
 8003dea:	0023      	movs	r3, r4
 8003dec:	3344      	adds	r3, #68	; 0x44
 8003dee:	4299      	cmp	r1, r3
 8003df0:	d002      	beq.n	8003df8 <__swsetup_r+0x6c>
 8003df2:	0030      	movs	r0, r6
 8003df4:	f000 f996 	bl	8004124 <_free_r>
 8003df8:	2300      	movs	r3, #0
 8003dfa:	6363      	str	r3, [r4, #52]	; 0x34
 8003dfc:	2224      	movs	r2, #36	; 0x24
 8003dfe:	89a3      	ldrh	r3, [r4, #12]
 8003e00:	4393      	bics	r3, r2
 8003e02:	81a3      	strh	r3, [r4, #12]
 8003e04:	2300      	movs	r3, #0
 8003e06:	6063      	str	r3, [r4, #4]
 8003e08:	6923      	ldr	r3, [r4, #16]
 8003e0a:	6023      	str	r3, [r4, #0]
 8003e0c:	2308      	movs	r3, #8
 8003e0e:	89a2      	ldrh	r2, [r4, #12]
 8003e10:	4313      	orrs	r3, r2
 8003e12:	81a3      	strh	r3, [r4, #12]
 8003e14:	6923      	ldr	r3, [r4, #16]
 8003e16:	2b00      	cmp	r3, #0
 8003e18:	d10b      	bne.n	8003e32 <__swsetup_r+0xa6>
 8003e1a:	21a0      	movs	r1, #160	; 0xa0
 8003e1c:	2280      	movs	r2, #128	; 0x80
 8003e1e:	89a3      	ldrh	r3, [r4, #12]
 8003e20:	0089      	lsls	r1, r1, #2
 8003e22:	0092      	lsls	r2, r2, #2
 8003e24:	400b      	ands	r3, r1
 8003e26:	4293      	cmp	r3, r2
 8003e28:	d003      	beq.n	8003e32 <__swsetup_r+0xa6>
 8003e2a:	0021      	movs	r1, r4
 8003e2c:	0030      	movs	r0, r6
 8003e2e:	f000 f927 	bl	8004080 <__smakebuf_r>
 8003e32:	2301      	movs	r3, #1
 8003e34:	89a2      	ldrh	r2, [r4, #12]
 8003e36:	4013      	ands	r3, r2
 8003e38:	d011      	beq.n	8003e5e <__swsetup_r+0xd2>
 8003e3a:	2300      	movs	r3, #0
 8003e3c:	60a3      	str	r3, [r4, #8]
 8003e3e:	6963      	ldr	r3, [r4, #20]
 8003e40:	425b      	negs	r3, r3
 8003e42:	61a3      	str	r3, [r4, #24]
 8003e44:	2000      	movs	r0, #0
 8003e46:	6923      	ldr	r3, [r4, #16]
 8003e48:	4283      	cmp	r3, r0
 8003e4a:	d1be      	bne.n	8003dca <__swsetup_r+0x3e>
 8003e4c:	230c      	movs	r3, #12
 8003e4e:	5ee2      	ldrsh	r2, [r4, r3]
 8003e50:	0613      	lsls	r3, r2, #24
 8003e52:	d5ba      	bpl.n	8003dca <__swsetup_r+0x3e>
 8003e54:	2340      	movs	r3, #64	; 0x40
 8003e56:	4313      	orrs	r3, r2
 8003e58:	81a3      	strh	r3, [r4, #12]
 8003e5a:	3801      	subs	r0, #1
 8003e5c:	e7b5      	b.n	8003dca <__swsetup_r+0x3e>
 8003e5e:	0792      	lsls	r2, r2, #30
 8003e60:	d400      	bmi.n	8003e64 <__swsetup_r+0xd8>
 8003e62:	6963      	ldr	r3, [r4, #20]
 8003e64:	60a3      	str	r3, [r4, #8]
 8003e66:	e7ed      	b.n	8003e44 <__swsetup_r+0xb8>
 8003e68:	20000020 	.word	0x20000020
 8003e6c:	0800430c 	.word	0x0800430c
 8003e70:	0800432c 	.word	0x0800432c
 8003e74:	080042ec 	.word	0x080042ec

08003e78 <_close_r>:
 8003e78:	2300      	movs	r3, #0
 8003e7a:	b570      	push	{r4, r5, r6, lr}
 8003e7c:	4c06      	ldr	r4, [pc, #24]	; (8003e98 <_close_r+0x20>)
 8003e7e:	0005      	movs	r5, r0
 8003e80:	0008      	movs	r0, r1
 8003e82:	6023      	str	r3, [r4, #0]
 8003e84:	f7ff f9e6 	bl	8003254 <_close>
 8003e88:	1c43      	adds	r3, r0, #1
 8003e8a:	d103      	bne.n	8003e94 <_close_r+0x1c>
 8003e8c:	6823      	ldr	r3, [r4, #0]
 8003e8e:	2b00      	cmp	r3, #0
 8003e90:	d000      	beq.n	8003e94 <_close_r+0x1c>
 8003e92:	602b      	str	r3, [r5, #0]
 8003e94:	bd70      	pop	{r4, r5, r6, pc}
 8003e96:	46c0      	nop			; (mov r8, r8)
 8003e98:	2000181c 	.word	0x2000181c

08003e9c <__sflush_r>:
 8003e9c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8003e9e:	898a      	ldrh	r2, [r1, #12]
 8003ea0:	0005      	movs	r5, r0
 8003ea2:	000c      	movs	r4, r1
 8003ea4:	0713      	lsls	r3, r2, #28
 8003ea6:	d460      	bmi.n	8003f6a <__sflush_r+0xce>
 8003ea8:	684b      	ldr	r3, [r1, #4]
 8003eaa:	2b00      	cmp	r3, #0
 8003eac:	dc04      	bgt.n	8003eb8 <__sflush_r+0x1c>
 8003eae:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 8003eb0:	2b00      	cmp	r3, #0
 8003eb2:	dc01      	bgt.n	8003eb8 <__sflush_r+0x1c>
 8003eb4:	2000      	movs	r0, #0
 8003eb6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8003eb8:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 8003eba:	2f00      	cmp	r7, #0
 8003ebc:	d0fa      	beq.n	8003eb4 <__sflush_r+0x18>
 8003ebe:	2300      	movs	r3, #0
 8003ec0:	682e      	ldr	r6, [r5, #0]
 8003ec2:	602b      	str	r3, [r5, #0]
 8003ec4:	2380      	movs	r3, #128	; 0x80
 8003ec6:	015b      	lsls	r3, r3, #5
 8003ec8:	401a      	ands	r2, r3
 8003eca:	d034      	beq.n	8003f36 <__sflush_r+0x9a>
 8003ecc:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8003ece:	89a3      	ldrh	r3, [r4, #12]
 8003ed0:	075b      	lsls	r3, r3, #29
 8003ed2:	d506      	bpl.n	8003ee2 <__sflush_r+0x46>
 8003ed4:	6863      	ldr	r3, [r4, #4]
 8003ed6:	1ac0      	subs	r0, r0, r3
 8003ed8:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8003eda:	2b00      	cmp	r3, #0
 8003edc:	d001      	beq.n	8003ee2 <__sflush_r+0x46>
 8003ede:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8003ee0:	1ac0      	subs	r0, r0, r3
 8003ee2:	0002      	movs	r2, r0
 8003ee4:	6a21      	ldr	r1, [r4, #32]
 8003ee6:	2300      	movs	r3, #0
 8003ee8:	0028      	movs	r0, r5
 8003eea:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 8003eec:	47b8      	blx	r7
 8003eee:	89a1      	ldrh	r1, [r4, #12]
 8003ef0:	1c43      	adds	r3, r0, #1
 8003ef2:	d106      	bne.n	8003f02 <__sflush_r+0x66>
 8003ef4:	682b      	ldr	r3, [r5, #0]
 8003ef6:	2b1d      	cmp	r3, #29
 8003ef8:	d831      	bhi.n	8003f5e <__sflush_r+0xc2>
 8003efa:	4a2c      	ldr	r2, [pc, #176]	; (8003fac <__sflush_r+0x110>)
 8003efc:	40da      	lsrs	r2, r3
 8003efe:	07d3      	lsls	r3, r2, #31
 8003f00:	d52d      	bpl.n	8003f5e <__sflush_r+0xc2>
 8003f02:	2300      	movs	r3, #0
 8003f04:	6063      	str	r3, [r4, #4]
 8003f06:	6923      	ldr	r3, [r4, #16]
 8003f08:	6023      	str	r3, [r4, #0]
 8003f0a:	04cb      	lsls	r3, r1, #19
 8003f0c:	d505      	bpl.n	8003f1a <__sflush_r+0x7e>
 8003f0e:	1c43      	adds	r3, r0, #1
 8003f10:	d102      	bne.n	8003f18 <__sflush_r+0x7c>
 8003f12:	682b      	ldr	r3, [r5, #0]
 8003f14:	2b00      	cmp	r3, #0
 8003f16:	d100      	bne.n	8003f1a <__sflush_r+0x7e>
 8003f18:	6560      	str	r0, [r4, #84]	; 0x54
 8003f1a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8003f1c:	602e      	str	r6, [r5, #0]
 8003f1e:	2900      	cmp	r1, #0
 8003f20:	d0c8      	beq.n	8003eb4 <__sflush_r+0x18>
 8003f22:	0023      	movs	r3, r4
 8003f24:	3344      	adds	r3, #68	; 0x44
 8003f26:	4299      	cmp	r1, r3
 8003f28:	d002      	beq.n	8003f30 <__sflush_r+0x94>
 8003f2a:	0028      	movs	r0, r5
 8003f2c:	f000 f8fa 	bl	8004124 <_free_r>
 8003f30:	2000      	movs	r0, #0
 8003f32:	6360      	str	r0, [r4, #52]	; 0x34
 8003f34:	e7bf      	b.n	8003eb6 <__sflush_r+0x1a>
 8003f36:	2301      	movs	r3, #1
 8003f38:	6a21      	ldr	r1, [r4, #32]
 8003f3a:	0028      	movs	r0, r5
 8003f3c:	47b8      	blx	r7
 8003f3e:	1c43      	adds	r3, r0, #1
 8003f40:	d1c5      	bne.n	8003ece <__sflush_r+0x32>
 8003f42:	682b      	ldr	r3, [r5, #0]
 8003f44:	2b00      	cmp	r3, #0
 8003f46:	d0c2      	beq.n	8003ece <__sflush_r+0x32>
 8003f48:	2b1d      	cmp	r3, #29
 8003f4a:	d001      	beq.n	8003f50 <__sflush_r+0xb4>
 8003f4c:	2b16      	cmp	r3, #22
 8003f4e:	d101      	bne.n	8003f54 <__sflush_r+0xb8>
 8003f50:	602e      	str	r6, [r5, #0]
 8003f52:	e7af      	b.n	8003eb4 <__sflush_r+0x18>
 8003f54:	2340      	movs	r3, #64	; 0x40
 8003f56:	89a2      	ldrh	r2, [r4, #12]
 8003f58:	4313      	orrs	r3, r2
 8003f5a:	81a3      	strh	r3, [r4, #12]
 8003f5c:	e7ab      	b.n	8003eb6 <__sflush_r+0x1a>
 8003f5e:	2340      	movs	r3, #64	; 0x40
 8003f60:	430b      	orrs	r3, r1
 8003f62:	2001      	movs	r0, #1
 8003f64:	81a3      	strh	r3, [r4, #12]
 8003f66:	4240      	negs	r0, r0
 8003f68:	e7a5      	b.n	8003eb6 <__sflush_r+0x1a>
 8003f6a:	690f      	ldr	r7, [r1, #16]
 8003f6c:	2f00      	cmp	r7, #0
 8003f6e:	d0a1      	beq.n	8003eb4 <__sflush_r+0x18>
 8003f70:	680b      	ldr	r3, [r1, #0]
 8003f72:	600f      	str	r7, [r1, #0]
 8003f74:	1bdb      	subs	r3, r3, r7
 8003f76:	9301      	str	r3, [sp, #4]
 8003f78:	2300      	movs	r3, #0
 8003f7a:	0792      	lsls	r2, r2, #30
 8003f7c:	d100      	bne.n	8003f80 <__sflush_r+0xe4>
 8003f7e:	694b      	ldr	r3, [r1, #20]
 8003f80:	60a3      	str	r3, [r4, #8]
 8003f82:	9b01      	ldr	r3, [sp, #4]
 8003f84:	2b00      	cmp	r3, #0
 8003f86:	dc00      	bgt.n	8003f8a <__sflush_r+0xee>
 8003f88:	e794      	b.n	8003eb4 <__sflush_r+0x18>
 8003f8a:	9b01      	ldr	r3, [sp, #4]
 8003f8c:	003a      	movs	r2, r7
 8003f8e:	6a21      	ldr	r1, [r4, #32]
 8003f90:	0028      	movs	r0, r5
 8003f92:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8003f94:	47b0      	blx	r6
 8003f96:	2800      	cmp	r0, #0
 8003f98:	dc03      	bgt.n	8003fa2 <__sflush_r+0x106>
 8003f9a:	2340      	movs	r3, #64	; 0x40
 8003f9c:	89a2      	ldrh	r2, [r4, #12]
 8003f9e:	4313      	orrs	r3, r2
 8003fa0:	e7df      	b.n	8003f62 <__sflush_r+0xc6>
 8003fa2:	9b01      	ldr	r3, [sp, #4]
 8003fa4:	183f      	adds	r7, r7, r0
 8003fa6:	1a1b      	subs	r3, r3, r0
 8003fa8:	9301      	str	r3, [sp, #4]
 8003faa:	e7ea      	b.n	8003f82 <__sflush_r+0xe6>
 8003fac:	20400001 	.word	0x20400001

08003fb0 <_fflush_r>:
 8003fb0:	690b      	ldr	r3, [r1, #16]
 8003fb2:	b570      	push	{r4, r5, r6, lr}
 8003fb4:	0005      	movs	r5, r0
 8003fb6:	000c      	movs	r4, r1
 8003fb8:	2b00      	cmp	r3, #0
 8003fba:	d101      	bne.n	8003fc0 <_fflush_r+0x10>
 8003fbc:	2000      	movs	r0, #0
 8003fbe:	bd70      	pop	{r4, r5, r6, pc}
 8003fc0:	2800      	cmp	r0, #0
 8003fc2:	d004      	beq.n	8003fce <_fflush_r+0x1e>
 8003fc4:	6983      	ldr	r3, [r0, #24]
 8003fc6:	2b00      	cmp	r3, #0
 8003fc8:	d101      	bne.n	8003fce <_fflush_r+0x1e>
 8003fca:	f7ff fa57 	bl	800347c <__sinit>
 8003fce:	4b0b      	ldr	r3, [pc, #44]	; (8003ffc <_fflush_r+0x4c>)
 8003fd0:	429c      	cmp	r4, r3
 8003fd2:	d109      	bne.n	8003fe8 <_fflush_r+0x38>
 8003fd4:	686c      	ldr	r4, [r5, #4]
 8003fd6:	220c      	movs	r2, #12
 8003fd8:	5ea3      	ldrsh	r3, [r4, r2]
 8003fda:	2b00      	cmp	r3, #0
 8003fdc:	d0ee      	beq.n	8003fbc <_fflush_r+0xc>
 8003fde:	0021      	movs	r1, r4
 8003fe0:	0028      	movs	r0, r5
 8003fe2:	f7ff ff5b 	bl	8003e9c <__sflush_r>
 8003fe6:	e7ea      	b.n	8003fbe <_fflush_r+0xe>
 8003fe8:	4b05      	ldr	r3, [pc, #20]	; (8004000 <_fflush_r+0x50>)
 8003fea:	429c      	cmp	r4, r3
 8003fec:	d101      	bne.n	8003ff2 <_fflush_r+0x42>
 8003fee:	68ac      	ldr	r4, [r5, #8]
 8003ff0:	e7f1      	b.n	8003fd6 <_fflush_r+0x26>
 8003ff2:	4b04      	ldr	r3, [pc, #16]	; (8004004 <_fflush_r+0x54>)
 8003ff4:	429c      	cmp	r4, r3
 8003ff6:	d1ee      	bne.n	8003fd6 <_fflush_r+0x26>
 8003ff8:	68ec      	ldr	r4, [r5, #12]
 8003ffa:	e7ec      	b.n	8003fd6 <_fflush_r+0x26>
 8003ffc:	0800430c 	.word	0x0800430c
 8004000:	0800432c 	.word	0x0800432c
 8004004:	080042ec 	.word	0x080042ec

08004008 <_lseek_r>:
 8004008:	b570      	push	{r4, r5, r6, lr}
 800400a:	0005      	movs	r5, r0
 800400c:	0008      	movs	r0, r1
 800400e:	0011      	movs	r1, r2
 8004010:	2200      	movs	r2, #0
 8004012:	4c06      	ldr	r4, [pc, #24]	; (800402c <_lseek_r+0x24>)
 8004014:	6022      	str	r2, [r4, #0]
 8004016:	001a      	movs	r2, r3
 8004018:	f7ff f926 	bl	8003268 <_lseek>
 800401c:	1c43      	adds	r3, r0, #1
 800401e:	d103      	bne.n	8004028 <_lseek_r+0x20>
 8004020:	6823      	ldr	r3, [r4, #0]
 8004022:	2b00      	cmp	r3, #0
 8004024:	d000      	beq.n	8004028 <_lseek_r+0x20>
 8004026:	602b      	str	r3, [r5, #0]
 8004028:	bd70      	pop	{r4, r5, r6, pc}
 800402a:	46c0      	nop			; (mov r8, r8)
 800402c:	2000181c 	.word	0x2000181c

08004030 <__swhatbuf_r>:
 8004030:	b570      	push	{r4, r5, r6, lr}
 8004032:	000e      	movs	r6, r1
 8004034:	001d      	movs	r5, r3
 8004036:	230e      	movs	r3, #14
 8004038:	5ec9      	ldrsh	r1, [r1, r3]
 800403a:	b090      	sub	sp, #64	; 0x40
 800403c:	0014      	movs	r4, r2
 800403e:	2900      	cmp	r1, #0
 8004040:	da07      	bge.n	8004052 <__swhatbuf_r+0x22>
 8004042:	2300      	movs	r3, #0
 8004044:	602b      	str	r3, [r5, #0]
 8004046:	89b3      	ldrh	r3, [r6, #12]
 8004048:	061b      	lsls	r3, r3, #24
 800404a:	d411      	bmi.n	8004070 <__swhatbuf_r+0x40>
 800404c:	2380      	movs	r3, #128	; 0x80
 800404e:	00db      	lsls	r3, r3, #3
 8004050:	e00f      	b.n	8004072 <__swhatbuf_r+0x42>
 8004052:	aa01      	add	r2, sp, #4
 8004054:	f000 f8c4 	bl	80041e0 <_fstat_r>
 8004058:	2800      	cmp	r0, #0
 800405a:	dbf2      	blt.n	8004042 <__swhatbuf_r+0x12>
 800405c:	22f0      	movs	r2, #240	; 0xf0
 800405e:	9b02      	ldr	r3, [sp, #8]
 8004060:	0212      	lsls	r2, r2, #8
 8004062:	4013      	ands	r3, r2
 8004064:	4a05      	ldr	r2, [pc, #20]	; (800407c <__swhatbuf_r+0x4c>)
 8004066:	189b      	adds	r3, r3, r2
 8004068:	425a      	negs	r2, r3
 800406a:	4153      	adcs	r3, r2
 800406c:	602b      	str	r3, [r5, #0]
 800406e:	e7ed      	b.n	800404c <__swhatbuf_r+0x1c>
 8004070:	2340      	movs	r3, #64	; 0x40
 8004072:	2000      	movs	r0, #0
 8004074:	6023      	str	r3, [r4, #0]
 8004076:	b010      	add	sp, #64	; 0x40
 8004078:	bd70      	pop	{r4, r5, r6, pc}
 800407a:	46c0      	nop			; (mov r8, r8)
 800407c:	ffffe000 	.word	0xffffe000

08004080 <__smakebuf_r>:
 8004080:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8004082:	2602      	movs	r6, #2
 8004084:	898b      	ldrh	r3, [r1, #12]
 8004086:	0005      	movs	r5, r0
 8004088:	000c      	movs	r4, r1
 800408a:	4233      	tst	r3, r6
 800408c:	d006      	beq.n	800409c <__smakebuf_r+0x1c>
 800408e:	0023      	movs	r3, r4
 8004090:	3347      	adds	r3, #71	; 0x47
 8004092:	6023      	str	r3, [r4, #0]
 8004094:	6123      	str	r3, [r4, #16]
 8004096:	2301      	movs	r3, #1
 8004098:	6163      	str	r3, [r4, #20]
 800409a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800409c:	ab01      	add	r3, sp, #4
 800409e:	466a      	mov	r2, sp
 80040a0:	f7ff ffc6 	bl	8004030 <__swhatbuf_r>
 80040a4:	9900      	ldr	r1, [sp, #0]
 80040a6:	0007      	movs	r7, r0
 80040a8:	0028      	movs	r0, r5
 80040aa:	f7ff fa7d 	bl	80035a8 <_malloc_r>
 80040ae:	2800      	cmp	r0, #0
 80040b0:	d108      	bne.n	80040c4 <__smakebuf_r+0x44>
 80040b2:	220c      	movs	r2, #12
 80040b4:	5ea3      	ldrsh	r3, [r4, r2]
 80040b6:	059a      	lsls	r2, r3, #22
 80040b8:	d4ef      	bmi.n	800409a <__smakebuf_r+0x1a>
 80040ba:	2203      	movs	r2, #3
 80040bc:	4393      	bics	r3, r2
 80040be:	431e      	orrs	r6, r3
 80040c0:	81a6      	strh	r6, [r4, #12]
 80040c2:	e7e4      	b.n	800408e <__smakebuf_r+0xe>
 80040c4:	4b0f      	ldr	r3, [pc, #60]	; (8004104 <__smakebuf_r+0x84>)
 80040c6:	62ab      	str	r3, [r5, #40]	; 0x28
 80040c8:	2380      	movs	r3, #128	; 0x80
 80040ca:	89a2      	ldrh	r2, [r4, #12]
 80040cc:	6020      	str	r0, [r4, #0]
 80040ce:	4313      	orrs	r3, r2
 80040d0:	81a3      	strh	r3, [r4, #12]
 80040d2:	9b00      	ldr	r3, [sp, #0]
 80040d4:	6120      	str	r0, [r4, #16]
 80040d6:	6163      	str	r3, [r4, #20]
 80040d8:	9b01      	ldr	r3, [sp, #4]
 80040da:	2b00      	cmp	r3, #0
 80040dc:	d00d      	beq.n	80040fa <__smakebuf_r+0x7a>
 80040de:	230e      	movs	r3, #14
 80040e0:	5ee1      	ldrsh	r1, [r4, r3]
 80040e2:	0028      	movs	r0, r5
 80040e4:	f000 f88e 	bl	8004204 <_isatty_r>
 80040e8:	2800      	cmp	r0, #0
 80040ea:	d006      	beq.n	80040fa <__smakebuf_r+0x7a>
 80040ec:	2203      	movs	r2, #3
 80040ee:	89a3      	ldrh	r3, [r4, #12]
 80040f0:	4393      	bics	r3, r2
 80040f2:	001a      	movs	r2, r3
 80040f4:	2301      	movs	r3, #1
 80040f6:	4313      	orrs	r3, r2
 80040f8:	81a3      	strh	r3, [r4, #12]
 80040fa:	89a0      	ldrh	r0, [r4, #12]
 80040fc:	4338      	orrs	r0, r7
 80040fe:	81a0      	strh	r0, [r4, #12]
 8004100:	e7cb      	b.n	800409a <__smakebuf_r+0x1a>
 8004102:	46c0      	nop			; (mov r8, r8)
 8004104:	080033f9 	.word	0x080033f9

08004108 <memchr>:
 8004108:	b2c9      	uxtb	r1, r1
 800410a:	1882      	adds	r2, r0, r2
 800410c:	4290      	cmp	r0, r2
 800410e:	d101      	bne.n	8004114 <memchr+0xc>
 8004110:	2000      	movs	r0, #0
 8004112:	4770      	bx	lr
 8004114:	7803      	ldrb	r3, [r0, #0]
 8004116:	428b      	cmp	r3, r1
 8004118:	d0fb      	beq.n	8004112 <memchr+0xa>
 800411a:	3001      	adds	r0, #1
 800411c:	e7f6      	b.n	800410c <memchr+0x4>

0800411e <__malloc_lock>:
 800411e:	4770      	bx	lr

08004120 <__malloc_unlock>:
 8004120:	4770      	bx	lr
	...

08004124 <_free_r>:
 8004124:	b570      	push	{r4, r5, r6, lr}
 8004126:	0005      	movs	r5, r0
 8004128:	2900      	cmp	r1, #0
 800412a:	d010      	beq.n	800414e <_free_r+0x2a>
 800412c:	1f0c      	subs	r4, r1, #4
 800412e:	6823      	ldr	r3, [r4, #0]
 8004130:	2b00      	cmp	r3, #0
 8004132:	da00      	bge.n	8004136 <_free_r+0x12>
 8004134:	18e4      	adds	r4, r4, r3
 8004136:	0028      	movs	r0, r5
 8004138:	f7ff fff1 	bl	800411e <__malloc_lock>
 800413c:	4a1d      	ldr	r2, [pc, #116]	; (80041b4 <_free_r+0x90>)
 800413e:	6813      	ldr	r3, [r2, #0]
 8004140:	2b00      	cmp	r3, #0
 8004142:	d105      	bne.n	8004150 <_free_r+0x2c>
 8004144:	6063      	str	r3, [r4, #4]
 8004146:	6014      	str	r4, [r2, #0]
 8004148:	0028      	movs	r0, r5
 800414a:	f7ff ffe9 	bl	8004120 <__malloc_unlock>
 800414e:	bd70      	pop	{r4, r5, r6, pc}
 8004150:	42a3      	cmp	r3, r4
 8004152:	d909      	bls.n	8004168 <_free_r+0x44>
 8004154:	6821      	ldr	r1, [r4, #0]
 8004156:	1860      	adds	r0, r4, r1
 8004158:	4283      	cmp	r3, r0
 800415a:	d1f3      	bne.n	8004144 <_free_r+0x20>
 800415c:	6818      	ldr	r0, [r3, #0]
 800415e:	685b      	ldr	r3, [r3, #4]
 8004160:	1841      	adds	r1, r0, r1
 8004162:	6021      	str	r1, [r4, #0]
 8004164:	e7ee      	b.n	8004144 <_free_r+0x20>
 8004166:	0013      	movs	r3, r2
 8004168:	685a      	ldr	r2, [r3, #4]
 800416a:	2a00      	cmp	r2, #0
 800416c:	d001      	beq.n	8004172 <_free_r+0x4e>
 800416e:	42a2      	cmp	r2, r4
 8004170:	d9f9      	bls.n	8004166 <_free_r+0x42>
 8004172:	6819      	ldr	r1, [r3, #0]
 8004174:	1858      	adds	r0, r3, r1
 8004176:	42a0      	cmp	r0, r4
 8004178:	d10b      	bne.n	8004192 <_free_r+0x6e>
 800417a:	6820      	ldr	r0, [r4, #0]
 800417c:	1809      	adds	r1, r1, r0
 800417e:	1858      	adds	r0, r3, r1
 8004180:	6019      	str	r1, [r3, #0]
 8004182:	4282      	cmp	r2, r0
 8004184:	d1e0      	bne.n	8004148 <_free_r+0x24>
 8004186:	6810      	ldr	r0, [r2, #0]
 8004188:	6852      	ldr	r2, [r2, #4]
 800418a:	1841      	adds	r1, r0, r1
 800418c:	6019      	str	r1, [r3, #0]
 800418e:	605a      	str	r2, [r3, #4]
 8004190:	e7da      	b.n	8004148 <_free_r+0x24>
 8004192:	42a0      	cmp	r0, r4
 8004194:	d902      	bls.n	800419c <_free_r+0x78>
 8004196:	230c      	movs	r3, #12
 8004198:	602b      	str	r3, [r5, #0]
 800419a:	e7d5      	b.n	8004148 <_free_r+0x24>
 800419c:	6821      	ldr	r1, [r4, #0]
 800419e:	1860      	adds	r0, r4, r1
 80041a0:	4282      	cmp	r2, r0
 80041a2:	d103      	bne.n	80041ac <_free_r+0x88>
 80041a4:	6810      	ldr	r0, [r2, #0]
 80041a6:	6852      	ldr	r2, [r2, #4]
 80041a8:	1841      	adds	r1, r0, r1
 80041aa:	6021      	str	r1, [r4, #0]
 80041ac:	6062      	str	r2, [r4, #4]
 80041ae:	605c      	str	r4, [r3, #4]
 80041b0:	e7ca      	b.n	8004148 <_free_r+0x24>
 80041b2:	46c0      	nop			; (mov r8, r8)
 80041b4:	2000129c 	.word	0x2000129c

080041b8 <_read_r>:
 80041b8:	b570      	push	{r4, r5, r6, lr}
 80041ba:	0005      	movs	r5, r0
 80041bc:	0008      	movs	r0, r1
 80041be:	0011      	movs	r1, r2
 80041c0:	2200      	movs	r2, #0
 80041c2:	4c06      	ldr	r4, [pc, #24]	; (80041dc <_read_r+0x24>)
 80041c4:	6022      	str	r2, [r4, #0]
 80041c6:	001a      	movs	r2, r3
 80041c8:	f7ff f80e 	bl	80031e8 <_read>
 80041cc:	1c43      	adds	r3, r0, #1
 80041ce:	d103      	bne.n	80041d8 <_read_r+0x20>
 80041d0:	6823      	ldr	r3, [r4, #0]
 80041d2:	2b00      	cmp	r3, #0
 80041d4:	d000      	beq.n	80041d8 <_read_r+0x20>
 80041d6:	602b      	str	r3, [r5, #0]
 80041d8:	bd70      	pop	{r4, r5, r6, pc}
 80041da:	46c0      	nop			; (mov r8, r8)
 80041dc:	2000181c 	.word	0x2000181c

080041e0 <_fstat_r>:
 80041e0:	2300      	movs	r3, #0
 80041e2:	b570      	push	{r4, r5, r6, lr}
 80041e4:	4c06      	ldr	r4, [pc, #24]	; (8004200 <_fstat_r+0x20>)
 80041e6:	0005      	movs	r5, r0
 80041e8:	0008      	movs	r0, r1
 80041ea:	0011      	movs	r1, r2
 80041ec:	6023      	str	r3, [r4, #0]
 80041ee:	f7ff f834 	bl	800325a <_fstat>
 80041f2:	1c43      	adds	r3, r0, #1
 80041f4:	d103      	bne.n	80041fe <_fstat_r+0x1e>
 80041f6:	6823      	ldr	r3, [r4, #0]
 80041f8:	2b00      	cmp	r3, #0
 80041fa:	d000      	beq.n	80041fe <_fstat_r+0x1e>
 80041fc:	602b      	str	r3, [r5, #0]
 80041fe:	bd70      	pop	{r4, r5, r6, pc}
 8004200:	2000181c 	.word	0x2000181c

08004204 <_isatty_r>:
 8004204:	2300      	movs	r3, #0
 8004206:	b570      	push	{r4, r5, r6, lr}
 8004208:	4c06      	ldr	r4, [pc, #24]	; (8004224 <_isatty_r+0x20>)
 800420a:	0005      	movs	r5, r0
 800420c:	0008      	movs	r0, r1
 800420e:	6023      	str	r3, [r4, #0]
 8004210:	f7ff f828 	bl	8003264 <_isatty>
 8004214:	1c43      	adds	r3, r0, #1
 8004216:	d103      	bne.n	8004220 <_isatty_r+0x1c>
 8004218:	6823      	ldr	r3, [r4, #0]
 800421a:	2b00      	cmp	r3, #0
 800421c:	d000      	beq.n	8004220 <_isatty_r+0x1c>
 800421e:	602b      	str	r3, [r5, #0]
 8004220:	bd70      	pop	{r4, r5, r6, pc}
 8004222:	46c0      	nop			; (mov r8, r8)
 8004224:	2000181c 	.word	0x2000181c

08004228 <_init>:
 8004228:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800422a:	46c0      	nop			; (mov r8, r8)
 800422c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800422e:	bc08      	pop	{r3}
 8004230:	469e      	mov	lr, r3
 8004232:	4770      	bx	lr

08004234 <_fini>:
 8004234:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004236:	46c0      	nop			; (mov r8, r8)
 8004238:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800423a:	bc08      	pop	{r3}
 800423c:	469e      	mov	lr, r3
 800423e:	4770      	bx	lr
